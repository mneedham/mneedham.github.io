<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Refactoring on Mark Needham</title>
    <link>https://mneedham.github.io/tag/refactoring/</link>
    <description>Recent content in Refactoring on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 25 Apr 2010 22:48:37 +0000</lastBuildDate>
    
	<atom:link href="https://mneedham.github.io/tag/refactoring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Small step refactoring: Overload constructor</title>
      <link>https://mneedham.github.io/2010/04/25/small-step-refactoring-overload-constructor/</link>
      <pubDate>Sun, 25 Apr 2010 22:48:37 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/04/25/small-step-refactoring-overload-constructor/</guid>
      <description>I&amp;rsquo;ve previously written about some approaches that I&amp;rsquo;ve been taught with respect to taking small steps when refactoring code and another approach which a couple of colleagues have been using recently is the idea of overloading the constructor when refactoring objects.
On a couple of occasions we&amp;rsquo;ve been trying to completely change the way an object was designed and changing the current constructor would mean that we&amp;rsquo;d have to change all the tests against that object before checking if the new design was actually going to work or not.</description>
    </item>
    
    <item>
      <title>Refactoring: Small steps to pull out responsibilities</title>
      <link>https://mneedham.github.io/2010/02/24/refactoring-small-steps-to-pull-out-responsibilities/</link>
      <pubDate>Wed, 24 Feb 2010 00:45:38 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/02/24/refactoring-small-steps-to-pull-out-responsibilities/</guid>
      <description>I wrote previously about how I&amp;rsquo;ve been using effect sketches to identify responsibilities in objects so that I can pull them out into other objects and once I&amp;rsquo;ve done this I often find that I can&amp;rsquo;t see a small next step to take.
At this stage in the past I&amp;rsquo;ve often then stopped and left the refactoring until I have more time to complete it but this hasn&amp;rsquo;t really worked and a lot of the time I end up only seeing the code change in my mind and not in the actual code.</description>
    </item>
    
    <item>
      <title>Safe refactoring: Removing object initializer, introducing builder</title>
      <link>https://mneedham.github.io/2009/06/26/safe-refactoring-removing-object-initializer-introducing-builder/</link>
      <pubDate>Fri, 26 Jun 2009 00:02:45 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/06/26/safe-refactoring-removing-object-initializer-introducing-builder/</guid>
      <description>I previously wrote about an approach we took to safely remove some duplication and I recently followed a similar mantra to replace an object initializer call which had around 40 properties being setup with a builder to try and make the code a bit easier to understand.
We did have tests checking the values being setup by the object initializer so I was already able to refactor with some degree of safety - it would probably have been possible to just create the builder and build the object from that and then delete the old code and replace it with the new but I&amp;rsquo;ve caused myself too many problems from doing that before that I decided to try a more incremental approach.</description>
    </item>
    
    <item>
      <title>Coding: Why do we extract method?</title>
      <link>https://mneedham.github.io/2009/06/04/coding-why-do-we-extract-method/</link>
      <pubDate>Thu, 04 Jun 2009 20:30:47 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/06/04/coding-why-do-we-extract-method/</guid>
      <description>Ever since I&amp;rsquo;ve read Uncle Bob&amp;rsquo;s Clean Code book my approach to coding has been all about the &amp;lsquo;extract method&amp;rsquo; refactoring - I pretty much look to extract method as much as I can until I get to the point where extracting another method would result in me just describing the language semantics in the method name.
One of the approaches that I&amp;rsquo;ve come across with regards to doing this refactoring is that it&amp;rsquo;s only used when there is duplication of code and we want to reduce that duplication so that it&amp;rsquo;s all in one place and then call that method from two places.</description>
    </item>
    
    <item>
      <title>Pair Programming: Refactoring</title>
      <link>https://mneedham.github.io/2009/05/26/pair-programming-refactoring/</link>
      <pubDate>Tue, 26 May 2009 23:44:36 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/05/26/pair-programming-refactoring/</guid>
      <description>One area of development where I have sometimes wondered about the value that we can get from pair programming is when we&amp;rsquo;re spending time doing some major refactoring of our code base.
The reason I felt that pairing on big refactoring tasks might be difficult compared to when working on a story together is that with a story there tends to be a more defined goal and the business have defined that goal whereas with a refactoring task that goal is often less clear and people have much wider ranging differing opinions about the approach that should be taken.</description>
    </item>
    
    <item>
      <title>Refactoring: Removing duplication more safely</title>
      <link>https://mneedham.github.io/2009/05/26/refactoring-removing-duplication-more-safely/</link>
      <pubDate>Tue, 26 May 2009 13:20:01 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/05/26/refactoring-removing-duplication-more-safely/</guid>
      <description>One of the most important things that I&amp;rsquo;ve learnt from the coding dojo sessions that we&amp;rsquo;ve been running over the last six months is the importance of small step refactorings.
Granted we have been trying to take some of the practices to the extreme but the basic idea of trying to keep the tests green for as much time as well as keeping our code in a state where it still compiles (in a static language) is very useful no matter what code we&amp;rsquo;re working on.</description>
    </item>
    
    <item>
      <title>F#: Refactoring that little twitter application into objects</title>
      <link>https://mneedham.github.io/2009/04/18/f-refactoring-that-little-twitter-application-into-objects/</link>
      <pubDate>Sat, 18 Apr 2009 08:47:06 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/04/18/f-refactoring-that-little-twitter-application-into-objects/</guid>
      <description>I previously wrote about a little twitter application I&amp;rsquo;ve been writing to go through my twitter feed and find only the tweets with links it and while it works I realised that I was finding it quite difficult to add any additional functionality to it.
I&amp;rsquo;ve been following the examples in Real World Functional Programming which has encouraged an approach of creating functions to do everything that you want to do and then mixing them together.</description>
    </item>
    
  </channel>
</rss>