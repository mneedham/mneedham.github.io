<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tdd on Mark Needham</title>
    <link>https://mneedham.github.io/tag/tdd/</link>
    <description>Recent content in Tdd on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Jul 2010 10:44:05 +0000</lastBuildDate>
    
	<atom:link href="https://mneedham.github.io/tag/tdd/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kent Beck&#39;s Test Driven Development Screencasts</title>
      <link>https://mneedham.github.io/2010/07/28/kent-becks-test-driven-development-screencasts/</link>
      <pubDate>Wed, 28 Jul 2010 10:44:05 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/07/28/kent-becks-test-driven-development-screencasts/</guid>
      <description>Following the recommendations of Corey Haines, Michael Guterl, James Martin and Michael Hunger I decided to get Kent Beck&amp;rsquo;s screencasts on Test Driven Development which have been published by the Pragmatic Programmers.
I read Kent&amp;rsquo;s &amp;lsquo;Test Driven Development By Example&amp;rsquo; book a couple of years ago and remember enjoying that so I was intrigued as to what it would be like to see some of those ideas put into practice in real time.</description>
    </item>
    
    <item>
      <title>TDD: Call your shots</title>
      <link>https://mneedham.github.io/2010/07/28/tdd-call-your-shots/</link>
      <pubDate>Wed, 28 Jul 2010 07:39:03 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/07/28/tdd-call-your-shots/</guid>
      <description>One of the other neat ideas I was reminded of when watching Kent Beck&amp;rsquo;s TDD screencasts is the value of &amp;lsquo;calling your shots&amp;rsquo; i.e. writing a test and then saying what&amp;rsquo;s going to happen when you run that test.
It reminds me of an exercise we used to do in tennis training when I was younger.
The coach would feed the ball to you and just before you hit it you had to say exactly where on the court you were going to place it - cross court/down the line and short/deep.</description>
    </item>
    
    <item>
      <title>TDD: Testing collections</title>
      <link>https://mneedham.github.io/2010/07/28/tdd-testing-collections/</link>
      <pubDate>Wed, 28 Jul 2010 06:05:25 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/07/28/tdd-testing-collections/</guid>
      <description>I&amp;rsquo;ve been watching Kent Beck&amp;rsquo;s TDD screencasts and in the 3rd episode he reminded me of a mistake I used to make when I was first learning how to test drive code.
The mistake happens when testing collections and I would write a test which would pass even if the collection had nothing in it.
The code would look something like this:
[Test] public void SomeTestOfACollection() { var someObject = new Object(); var aCollection = someObject.</description>
    </item>
    
    <item>
      <title>TDD, small steps and no need for comments</title>
      <link>https://mneedham.github.io/2010/07/23/tdd-small-steps-and-no-need-for-comments/</link>
      <pubDate>Fri, 23 Jul 2010 02:52:03 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/07/23/tdd-small-steps-and-no-need-for-comments/</guid>
      <description>I recently came a blog post written by Matt Ward describing some habits to make you a better coder and while he presented a lot of good ideas I found myself disagreeing with his 2nd tip:
 2. Write Your Logic through Comments When it comes to coding, there are many tenets and ideas I stand by. One of this is that code is 95% logic. Another is that logic doesn’t change when translated from human language into a programming language.</description>
    </item>
    
    <item>
      <title>TDD: I hate deleting unit tests</title>
      <link>https://mneedham.github.io/2010/07/15/tdd-i-hate-deleting-unit-tests/</link>
      <pubDate>Thu, 15 Jul 2010 23:15:54 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/07/15/tdd-i-hate-deleting-unit-tests/</guid>
      <description>Following on from my post about the value we found in acceptance tests on our project when doing a large scale refactoring I had an interesting discussion with Jak Charlton and Ben Hall about deleting unit tests when they&amp;rsquo;re no longer needed.
The following is part of our discussion:
Ben:  @JakCharlton @markhneedham a lot (not all) of the unit tests created can be deleted once the acceptance tests are passing&amp;hellip;</description>
    </item>
    
    <item>
      <title>TDD: Consistent test structure</title>
      <link>https://mneedham.github.io/2010/03/24/tdd-consistent-test-structure/</link>
      <pubDate>Wed, 24 Mar 2010 06:53:55 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/03/24/tdd-consistent-test-structure/</guid>
      <description>While pairing with Damian we came across the fairly common situation where we&amp;rsquo;d written two different tests - one to handle the positive case and one the negative case.
While tidying up the tests after we&amp;rsquo;d got them passing we noticed that the test structure wasn&amp;rsquo;t exactly the same. The two tests looked a bit like this:
[Test] public void ShouldSetSomethingIfWeHaveAFoo() { var aFoo = FooBuilder.Build.WithBar(&amp;quot;bar&amp;quot;).WithBaz(&amp;quot;baz&amp;quot;).AFoo(); // some random setup // some stubs/expectations var result = new Controller(.</description>
    </item>
    
    <item>
      <title>TDD: Expressive test names</title>
      <link>https://mneedham.github.io/2010/03/19/tdd-expressive-test-names/</link>
      <pubDate>Fri, 19 Mar 2010 18:06:51 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/03/19/tdd-expressive-test-names/</guid>
      <description>Towards the end of a post I wrote just over a year ago I suggested that I wasn&amp;rsquo;t really bothered about test names anymore because I could learn what I wanted from reading the test body.
Recently, however, I&amp;rsquo;ve come across several tests that I wrote previously which were testing the wrong thing and had such generic test names that it wasn&amp;rsquo;t obvious that it was happening.
The tests in question were around code which partially clones an object but doesn&amp;rsquo;t copy some fields for various reasons.</description>
    </item>
    
    <item>
      <title>TDD: Rewriting/refactoring tests</title>
      <link>https://mneedham.github.io/2010/01/25/tdd-rewritingrefactoring-tests/</link>
      <pubDate>Mon, 25 Jan 2010 22:06:23 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/25/tdd-rewritingrefactoring-tests/</guid>
      <description>I&amp;rsquo;ve read several times about the dangers of the big rewrite when it comes to production code but I&amp;rsquo;ve recently been wondering whether or not we should apply the same rules when it comes to test code or not.
I worked with Raphael Speyer for a few weeks last year and on the code base we were working on he often spent some time rewriting tests originally written using rMock to use mockito which was the framework we were driving towards.</description>
    </item>
    
    <item>
      <title>TDD: Simplifying a test with a hand rolled stub</title>
      <link>https://mneedham.github.io/2010/01/25/tdd-simplifying-a-test-with-a-hand-rolled-stub/</link>
      <pubDate>Mon, 25 Jan 2010 21:23:31 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/25/tdd-simplifying-a-test-with-a-hand-rolled-stub/</guid>
      <description>I wrote a couple of weeks ago about my thoughts on hand written stubs vs framework generated stubs and I noticed an interesting situation where it helped me out while trying to simplify some test code.
The code in question was making use of several framework generated stubs/mocks and one in particular was trying to return different values depending on the value passed as a parameter.
The test was failing and I spent about half an hour unsuccessfully trying to work out why it wasn&amp;rsquo;t working as expected before I decided to replace it with a hand rolled stub that did exactly what I wanted.</description>
    </item>
    
    <item>
      <title>TDD: Removing the clutter</title>
      <link>https://mneedham.github.io/2010/01/24/tdd-removing-the-clutter/</link>
      <pubDate>Sun, 24 Jan 2010 01:13:57 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/24/tdd-removing-the-clutter/</guid>
      <description>I got the chance to work with Phil for a couple of weeks last year and one of the most interesting things that he started teaching me was the importance of reducing the clutter in our tests and ensuring that we take some time to refactor them as well as the code as part of the &amp;lsquo;red-green-refactor&amp;rsquo; cycle.
I&amp;rsquo;m still trying to work out the best way to do this but I came across a really interesting post by J.</description>
    </item>
    
    <item>
      <title>TDD: Thoughts on using a clock in tests</title>
      <link>https://mneedham.github.io/2010/01/15/tdd-thoughts-on-using-a-clock-in-tests/</link>
      <pubDate>Fri, 15 Jan 2010 21:56:48 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/15/tdd-thoughts-on-using-a-clock-in-tests/</guid>
      <description>A few months ago Uncle Bob wrote a post about TDD where he suggested that he preferred to use hand created stubs in his tests wherever possible and only resorted to using a Mockito created stub as a last resort.
I wrote previously about my thoughts of where to use each of the two approaches and one example of where hand written stubs seems to make sense is the clock.</description>
    </item>
    
    <item>
      <title>TDD: Hand written stubs vs Framework generated stubs</title>
      <link>https://mneedham.github.io/2010/01/15/tdd-hand-written-stubs-vs-framework-generated-stubs/</link>
      <pubDate>Fri, 15 Jan 2010 21:44:36 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/15/tdd-hand-written-stubs-vs-framework-generated-stubs/</guid>
      <description>A few months ago Uncle Bob wrote a post about TDD where he suggested that he preferred to use hand created stubs in his tests wherever possible and only resorted to using a Mockito created stub as a last resort.
I&amp;rsquo;ve tended to use framework created ones but my colleague Matt Dunn and I noticed that it didn&amp;rsquo;t seem to work out too well for us writing some tests around a controller where the majority of our tests were making exactly the same call to that repository and expected to receive the same return value but a few select edge cases expected something different.</description>
    </item>
    
    <item>
      <title>Roy Osherove&#39;s TDD Kata: An F# attempt</title>
      <link>https://mneedham.github.io/2010/01/10/roy-osheroves-tdd-kata-an-f-attempt/</link>
      <pubDate>Sun, 10 Jan 2010 01:46:07 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/10/roy-osheroves-tdd-kata-an-f-attempt/</guid>
      <description>As I&amp;rsquo;ve mentioned in a few of my recent posts I&amp;rsquo;ve been having another go at Roy Osherove&amp;rsquo;s TDD Kata but this time in F#.
One thing I&amp;rsquo;ve been struggling with when coding in F# is working out how many intermediate variables we actually need. They can be useful for expressing intent better but they&amp;rsquo;re clutter in a way.
I&amp;rsquo;ve included my solution at the end and in the active pattern which determines whether or not we have a custom delimeter defined in our input string I can&amp;rsquo;t decide whether or not to create a value to represent the expressions that determine that.</description>
    </item>
    
    <item>
      <title>TDD: Hungarian notation for mocks/stubs</title>
      <link>https://mneedham.github.io/2010/01/06/tdd-hungarian-notation-for-mocksstubs/</link>
      <pubDate>Wed, 06 Jan 2010 00:08:14 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2010/01/06/tdd-hungarian-notation-for-mocksstubs/</guid>
      <description>A fairly common discussion that I&amp;rsquo;ve had with several of my colleagues is around the way that we name the variables used for mocks and stubs in our tests.
There seems to be about a 50&amp;frasl;50 split between including &amp;lsquo;Stub&amp;rsquo; or &amp;lsquo;Mock&amp;rsquo; on the end of those variable names and not doing so.
In a simple example test using Rhino Mocks as the testing framework this would be the contrast between the two approaches:</description>
    </item>
    
    <item>
      <title>Roy Osherove&#39;s TDD Kata: My first attempt</title>
      <link>https://mneedham.github.io/2009/12/25/roy-osheroves-tdd-kata-my-first-attempt/</link>
      <pubDate>Fri, 25 Dec 2009 22:25:57 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/12/25/roy-osheroves-tdd-kata-my-first-attempt/</guid>
      <description>I recently came across Roy Osherove&amp;rsquo;s commentary on Corey Haines&amp;rsquo; attempt at Roy&amp;rsquo;s TDD Kata so I thought I&amp;rsquo;d try it out in C#.
Andrew Woodward has recorded his version of the kata where he avoids using the mouse for the whole exercise so I tried to avoid using the mouse as well and it was surprisingly difficult!
I&amp;rsquo;ve only done the first part of the exercise so far which is as follows:</description>
    </item>
    
    <item>
      <title>TDD: Only mock types you own</title>
      <link>https://mneedham.github.io/2009/12/13/tdd-only-mock-types-you-own/</link>
      <pubDate>Sun, 13 Dec 2009 21:47:04 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/12/13/tdd-only-mock-types-you-own/</guid>
      <description>Liz recently posted about mock objects and the original &amp;lsquo;mock roles, not objects&amp;rsquo; paper and one thing that stood out for me is the idea that we should only mock types that we own.
I think this is quite an important guideline to follow otherwise we can end up in a world of pain.
One area which seems particularly vulnerable to this type of thing is when it comes to testing code which interacts with Hibernate.</description>
    </item>
    
    <item>
      <title>TDD: Big leaps and small steps</title>
      <link>https://mneedham.github.io/2009/12/10/tdd-big-leaps-and-small-steps/</link>
      <pubDate>Thu, 10 Dec 2009 22:14:26 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/12/10/tdd-big-leaps-and-small-steps/</guid>
      <description>About a month ago or so Gary Bernhardt wrote a post showing how to get started with TDD and while the post is quite interesting, several comments on the post pointed out that he had jumped from iteratively solving the problem straight to the solution with his final step.
Something which I&amp;rsquo;ve noticed while solving algorithmic problems in couple of different functional programming languages is that the test driven approach doesn&amp;rsquo;t work so well for these types of problems.</description>
    </item>
    
    <item>
      <title>TDD: Testing delegation</title>
      <link>https://mneedham.github.io/2009/11/27/tdd-testing-delegation/</link>
      <pubDate>Fri, 27 Nov 2009 14:43:45 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/11/27/tdd-testing-delegation/</guid>
      <description>I recently came across an interesting blog post by Rod Hilton on unit testing and it reminded me of a couple of conversations Phil, Raph and I were having about the best way to test classes which delegate some responsibility to another class.
An example that we ran into recently was where we wrote some code which required one controller to delegate to another.
public class ControllerOne extends Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { } }  public class ControllerTwo extends Controller { private final ControllerOne controllerOne; public ControllerTwo(ControllerOne controllerOne) { this.</description>
    </item>
    
    <item>
      <title>TDD: Useful when new on a project</title>
      <link>https://mneedham.github.io/2009/11/06/tdd-useful-when-new-on-a-project/</link>
      <pubDate>Fri, 06 Nov 2009 21:57:10 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/11/06/tdd-useful-when-new-on-a-project/</guid>
      <description>Something which I&amp;rsquo;ve noticed over the last few projects that I&amp;rsquo;ve worked on is that at the beginning when I don&amp;rsquo;t know very much at all about the code base, domain and so on is that pairing with someone to TDD something seems to make it significantly easier for me to follow what&amp;rsquo;s going on than other approaches I&amp;rsquo;ve seen.
I thought that it was probably because I&amp;rsquo;m more used to that approach than any other but in Michael Feathers&amp;rsquo; description of TDD in &amp;lsquo;Working Effectively With Legacy Code&amp;rsquo; he points out the following:</description>
    </item>
    
    <item>
      <title>TDD: Keeping assertions clear</title>
      <link>https://mneedham.github.io/2009/10/10/tdd-keeping-assertions-clear/</link>
      <pubDate>Sat, 10 Oct 2009 11:07:21 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/10/10/tdd-keeping-assertions-clear/</guid>
      <description>Something which I noticed was a problem with the first example test that I provided in my post about API readability and testability is that the assertion we are making is not that great.
[Test] public void ShouldConstructModelForSomeSituation() { Assert.AreEqual(DateTime.Today.ToDisplayFormat(), model.SomeDate()); }  It&amp;rsquo;s not really obvious what the expected result is supposed to be except that it should be the &amp;lsquo;DisplayFormat&amp;rsquo;. If that fails then we&amp;rsquo;ll need to navigate to the &amp;lsquo;ToDisplayFormat&amp;rsquo; method to work out what that method does.</description>
    </item>
    
    <item>
      <title>Coding: API readability/testability</title>
      <link>https://mneedham.github.io/2009/10/10/coding-api-readabilitytestability/</link>
      <pubDate>Sat, 10 Oct 2009 00:21:45 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/10/10/coding-api-readabilitytestability/</guid>
      <description>About a month ago or so I described how we did some work to ensure that we were calling a class the same way in our tests as in our production code and while I think that was a good choice in that situation we came across a similar problem this week where we weren&amp;rsquo;t so sure.
The piece of code in question was being used to create the view model for a page and one of the pieces of data that we wanted to show on this page was the date on which something would be valid which is currently today&amp;rsquo;s date.</description>
    </item>
    
    <item>
      <title>TDD: It makes you question what you&#39;re doing</title>
      <link>https://mneedham.github.io/2009/09/25/tdd-it-makes-you-question-what-youre-doing/</link>
      <pubDate>Fri, 25 Sep 2009 23:48:33 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/25/tdd-it-makes-you-question-what-youre-doing/</guid>
      <description>My colleague Matt Dunn and I have been putting a lot of tests around some code over the last few days so that we can safely make some changes around that area and having finally created our safety net we&amp;rsquo;ve moved onto adding in the new functionality.
We&amp;rsquo;re test driving the new bit of functionality whereas with the previous code only the code had been written with no unit tests and it&amp;rsquo;s been quite interesting seeing the contrast in the style of code which seems to come out from these differing styles.</description>
    </item>
    
    <item>
      <title>TDD: Copying and pasting tests</title>
      <link>https://mneedham.github.io/2009/09/22/tdd-copying-and-pasting-tests/</link>
      <pubDate>Tue, 22 Sep 2009 23:39:56 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/22/tdd-copying-and-pasting-tests/</guid>
      <description>I&amp;rsquo;ve been re-reading a post my colleague Ian Cartwright wrote earlier this year about treating test code the same way as production code and one thing which stands out as something which I&amp;rsquo;m certainly guilty off is copying and pasting tests.
Ian lists the following problems with doing this:
 The first one is cut &amp; paste, for some reason when it comes to unit tests people suddenly start cutting and pasting all over the place.</description>
    </item>
    
    <item>
      <title>TDD: Tests that give us a false confidence of coverage</title>
      <link>https://mneedham.github.io/2009/09/21/tdd-tests-that-give-us-a-false-confidence-of-coverage/</link>
      <pubDate>Mon, 21 Sep 2009 22:49:49 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/21/tdd-tests-that-give-us-a-false-confidence-of-coverage/</guid>
      <description>During J.B. Rainsberger&amp;rsquo;s presentation at Agile 2009 titled &amp;lsquo;Integration tests are a scam&amp;rsquo; he suggests that having lots of integrationt tests covering our code can give us a false sense of confidence that we are testing our code and I think the same can happen with unit tests as well if we&amp;rsquo;re not careful how we write them.
It&amp;rsquo;s important to ensure that our unit tests are actually testing something useful otherwise the cost of writing and maintaining them will outweigh the benefits that we derive from doing so.</description>
    </item>
    
    <item>
      <title>TDD: Keeping test intent when using test builders</title>
      <link>https://mneedham.github.io/2009/09/20/tdd-keeping-test-intent-when-using-test-builders/</link>
      <pubDate>Sun, 20 Sep 2009 12:06:04 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/20/tdd-keeping-test-intent-when-using-test-builders/</guid>
      <description>While the test data builder pattern is quite a useful one for simplifying the creation of test data in our tests I think we need to be quite careful when using it that we don&amp;rsquo;t lose the intent of the test that we&amp;rsquo;re writing.
The main advantage that I see with this pattern is that by using it we can provide default values for properties of our objects which aren&amp;rsquo;t important for the bit of functionality that we&amp;rsquo;re currently testing but which need to be provided otherwise the test can&amp;rsquo;t actually be run.</description>
    </item>
    
    <item>
      <title>TDD: Testing with generic abstract classes</title>
      <link>https://mneedham.github.io/2009/09/18/tdd-testing-with-generic-abstract-classes/</link>
      <pubDate>Fri, 18 Sep 2009 00:40:09 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/18/tdd-testing-with-generic-abstract-classes/</guid>
      <description>In a post I wrote earlier in the week I described a dilemma we were having testing some code which made use of abstract classes and Perryn Fowler, Liz Keogh and Pat Maddox pointed out that a useful approach for this problem would be to make use of an abstract test class.
The idea here is that we create an equivalent hierarchy to our production code for our tests which in the example that I provided would mean that we have roughly the following setup:</description>
    </item>
    
    <item>
      <title>TDD: Testing sub classes</title>
      <link>https://mneedham.github.io/2009/09/13/tdd-testing-sub-classes/</link>
      <pubDate>Sun, 13 Sep 2009 22:21:22 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/13/tdd-testing-sub-classes/</guid>
      <description>We ran into another interesting testing dilemma while refactoring the view model code which I described in an earlier post to the point where we have an abstract class and three sub classes which means that we now have 3 classes which did the same thing 80% of the time.
As I mentioned in a post a couple of weeks ago one of the main refactorings that we did was to move some calls to dependency methods from the constructor and into properties so that those calls would only be made if necessary.</description>
    </item>
    
    <item>
      <title>TDD: Test only constructors</title>
      <link>https://mneedham.github.io/2009/09/12/tdd-test-only-constructors/</link>
      <pubDate>Sat, 12 Sep 2009 00:35:12 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/12/tdd-test-only-constructors/</guid>
      <description>I wrote previously how we&amp;rsquo;d been doing some work to change the way that we get a &amp;lsquo;User&amp;rsquo; object into our system and one mistake that we made intially was to have another constructor on the &amp;lsquo;User&amp;rsquo; object which was being used in all our unit tests which involved the user in some way.
The original reason that this &amp;lsquo;test constructor&amp;rsquo; was created was to make it easier to construct a &amp;lsquo;fake user&amp;rsquo; which we were using in some of our functional tests but had ended up being used in unit tests as well.</description>
    </item>
    
    <item>
      <title>TDD: Test the behaviour rather than implementation</title>
      <link>https://mneedham.github.io/2009/09/02/tdd-test-the-behaviour-rather-than-implementation/</link>
      <pubDate>Wed, 02 Sep 2009 00:42:52 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/09/02/tdd-test-the-behaviour-rather-than-implementation/</guid>
      <description>I previously wrote about some duplicated code we&amp;rsquo;d taken the time to remove from our code base and one something else that we found when working with this code is that a lot of the tests around this code were testing the implementation/internal state of the object rather than testing the behaviour that they expected to see.
I find it makes more sense to test the behaviour since this is the way that the object will most likely be used in our production code.</description>
    </item>
    
    <item>
      <title>Rock Scissors Paper: TDD as if you meant it</title>
      <link>https://mneedham.github.io/2009/08/24/rock-scissors-paper-tdd-as-if-you-meant-it/</link>
      <pubDate>Mon, 24 Aug 2009 22:11:26 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/08/24/rock-scissors-paper-tdd-as-if-you-meant-it/</guid>
      <description>I decided to spend a bit of time on Saturday having another go at writing Rock Scissors Paper while following Keith Braithwaite&amp;rsquo;s TDD as if you meant it exercise.
We previously did this exercise at a coding dojo but I wanted to see what happens when you code for a longer period of time with this exercise since we typically only code for maybe a couple of hours at a dojo.</description>
    </item>
    
    <item>
      <title>TDD: Asserting on test dependency code</title>
      <link>https://mneedham.github.io/2009/08/19/tdd-asserting-on-test-dependency-code/</link>
      <pubDate>Wed, 19 Aug 2009 23:19:45 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/08/19/tdd-asserting-on-test-dependency-code/</guid>
      <description>Something I&amp;rsquo;ve noticed a bit lately is tests which setup a load of dependencies for a test and then do assertions on that setup before getting on to calling the system under test.
The code tends to be similar to this:
public void ShouldHopefullyDoSomeAwesomeStuff() { // setup via expectations for dependency1 and dependency2 Assert.IsNotNull(dependency1.DependedOnMethod);	new SystemUnderTest(dependency1, dependency2).DoThatStuff(); // test assertions }  I&amp;rsquo;ve done this a fair few times myself and I used to believe that it actually made the test more valuable since we were ensuring that the dependencies were in a good state before we executed the test.</description>
    </item>
    
    <item>
      <title>TDD: Making the test green quickly</title>
      <link>https://mneedham.github.io/2009/05/24/tdd-making-the-test-green-quickly/</link>
      <pubDate>Sun, 24 May 2009 23:43:28 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/05/24/tdd-making-the-test-green-quickly/</guid>
      <description>Although I pointed out some things that I disagreed with in Nick&amp;rsquo;s post about pair programming one thing that I really liked in that post was that he emphasised the importance of getting tests from red to green as quickly as possible.
 I remember the best programming sessions I’ve had was with Stacy Curl, now an ex-thoughtworker and whom I believe was also a chess player. He would always look to quickly make my tests pass, even if it was to just echo the output that my tests would sometimes expect.</description>
    </item>
    
    <item>
      <title>TDD: Balancing DRYness and Readability</title>
      <link>https://mneedham.github.io/2009/04/13/tdd-balancing-dryness-and-readability/</link>
      <pubDate>Mon, 13 Apr 2009 00:47:00 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/04/13/tdd-balancing-dryness-and-readability/</guid>
      <description>I wrote previously about creating DRY tests and after some conversations with my colleagues recently about the balance between reducing duplication but maintaining readability I think I&amp;rsquo;ve found the compromise between the two that works best for me.
The underlying idea is that in any unit test I want to be aiming for a distinct 3 sections in the test - Given/When/Then, Arrange/Act/Assert or whatever your favourite description for those is.</description>
    </item>
    
    <item>
      <title>TDD: Testing mapping code</title>
      <link>https://mneedham.github.io/2009/04/02/tdd-testing-mapping-code/</link>
      <pubDate>Thu, 02 Apr 2009 23:11:12 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/04/02/tdd-testing-mapping-code/</guid>
      <description>I&amp;rsquo;ve previously written about some of the aspects of the mapping efforts that we&amp;rsquo;ve done on recent projects and what we&amp;rsquo;ve found from our testing (or lack of) around this type of code is that somewhere along the line you are going to have to check that you&amp;rsquo;re mapping these values correctly, be it in an automated test or just by manually checking that the correct values are being sent across our integration points and into other systems.</description>
    </item>
    
    <item>
      <title>Coding: Making the debugger redundant</title>
      <link>https://mneedham.github.io/2009/03/22/coding-making-the-debugger-redundant/</link>
      <pubDate>Sun, 22 Mar 2009 19:52:31 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/03/22/coding-making-the-debugger-redundant/</guid>
      <description>I recently wrote my dislike of the debugger and related to this, I spent some time last year watching some videos from JAOO 2007 on MSDN&amp;rsquo;s Channel 9. One of my favourites is an interview featuring Joe Armstrong and Eric Meijer where Joe Armstrong points out that when coding Erlang he never has to use a debugger because state is immutable.
In Erlang, once you set the value of a variable &amp;lsquo;x&amp;rsquo; it cannot be changed.</description>
    </item>
    
    <item>
      <title>TDD: Test DRYness</title>
      <link>https://mneedham.github.io/2009/01/30/tdd-test-dryness/</link>
      <pubDate>Fri, 30 Jan 2009 11:16:27 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/01/30/tdd-test-dryness/</guid>
      <description>I had a discussion recently with Fabio about DRYness in our tests and how we don&amp;rsquo;t tend to adhere to this principal as often in test code as in production code.
I think certainly some of the reason for this is that we don&amp;rsquo;t take as much care of our test code as we do production code but for me at least some of it is down to the fact that if we make our tests too DRY then they become very difficult to read and perhaps more importantly, very difficult to debug when there is a failure.</description>
    </item>
    
    <item>
      <title>TDD: Design tests for failure</title>
      <link>https://mneedham.github.io/2009/01/28/tdd-design-tests-for-failure/</link>
      <pubDate>Wed, 28 Jan 2009 00:48:16 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2009/01/28/tdd-design-tests-for-failure/</guid>
      <description>As with most code, tests are read many more times than they are written and as the majority of the time the reason for reading them is to identify a test failure I think it makes sense that we should be designing our tests with failure in mind.
Several ideas come to mind when thinking about ways to write/design our tests so that when we do have to read them our task is made easier.</description>
    </item>
    
    <item>
      <title>TDD: Does it make you slower?</title>
      <link>https://mneedham.github.io/2008/12/25/tdd-does-it-make-you-slower/</link>
      <pubDate>Thu, 25 Dec 2008 09:41:50 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/12/25/tdd-does-it-make-you-slower/</guid>
      <description>There have been several times where we have been writing code in a test driven way and it has been suggested that we would be able to go much quicker if we stopped writing the tests and just wrote the code.
I feel this is a very short term way of looking at the problem and it does eventually come back to haunt you.
One of the problems seems to be that in many organisations only the first release of a piece of software is considered, and in this case then yes maybe it would be quicker to develop code in a non TDD fashion.</description>
    </item>
    
    <item>
      <title>Testing First vs Testing Last</title>
      <link>https://mneedham.github.io/2008/12/22/testing-first-vs-testing-last/</link>
      <pubDate>Mon, 22 Dec 2008 21:39:22 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/12/22/testing-first-vs-testing-last/</guid>
      <description>I recently posted about my experiences of testing last where it became clear to me how important writing the test before the code is.
If we view the tests purely as a way of determining whether or not our code works correctly for a given set of examples then it doesn&amp;rsquo;t make much difference whether we test before or after we have written the code.
If on the other hand we want to get more value out of our tests such as having them the tests act as documentation, drive the design of our APIs and generally prove useful reading to ourself and others in future then a test first approach is the way to go.</description>
    </item>
    
    <item>
      <title>TDD: Mock expectations in Setup</title>
      <link>https://mneedham.github.io/2008/12/19/tdd-mock-expectations-in-setup/</link>
      <pubDate>Fri, 19 Dec 2008 20:57:23 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/12/19/tdd-mock-expectations-in-setup/</guid>
      <description>One of the ideas that I mentioned in a recent post about what I consider to be a good unit test was the ideas that we shouldn&amp;rsquo;t necessarily consider the DRY (Don&amp;rsquo;t Repeat Yourself) principle to be our number one driver.
I consider putting mock expectations in the setup methods of our tests to be one of those occasions where we shouldn&amp;rsquo;t obey this principle and I thought this would be fairly unanimously agreed upon but putting the question to the Twittersphere led to mixed opinions.</description>
    </item>
    
    <item>
      <title>TDD: One test at a time</title>
      <link>https://mneedham.github.io/2008/12/09/tdd-one-test-at-a-time/</link>
      <pubDate>Tue, 09 Dec 2008 22:07:37 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/12/09/tdd-one-test-at-a-time/</guid>
      <description>My colleague Sarah Taraporewalla has written a series of posts recently about her experiences with TDD and introducing it at her current client.
While I agreed with the majority of the posts, one thing I found interesting was that in the conversation with a TDDer there were two tests being worked on at the same time (at least as far as I understand from the example).
This means that there will be two tests failing if we run our test suite, something which I try to avoid wherever possible.</description>
    </item>
    
    <item>
      <title>What makes a good unit test?</title>
      <link>https://mneedham.github.io/2008/12/04/what-make-a-good-unit-test/</link>
      <pubDate>Thu, 04 Dec 2008 00:31:29 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/12/04/what-make-a-good-unit-test/</guid>
      <description>Following on from my post around the definition of a unit test, a recent discussion on the Test Driven Development mailing list led me to question what my own approach is for writing unit tests.
To self quote from my previous post:
 A well written unit test in my book should be simple to understand and run quickly.  Quite simple in theory but as I have learnt (and am still learning) the hard way, much harder to do in practice.</description>
    </item>
    
    <item>
      <title>TDD: If it&#39;s hard to test reflect on your approach</title>
      <link>https://mneedham.github.io/2008/11/30/tdd-if-its-hard-to-test-reflect-on-your-approach/</link>
      <pubDate>Sun, 30 Nov 2008 18:42:29 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/11/30/tdd-if-its-hard-to-test-reflect-on-your-approach/</guid>
      <description>Chad Myers gets it spot on in his recent post about not testing private methods - private methods are private because they should be inaccessible from outside the class and their functionality should be tested via one of the public methods that calls them.
I&amp;rsquo;ve found that when a piece of code seems really difficult to test without exposing a private method then we&amp;rsquo;re probably trying to test that functionality from the wrong place.</description>
    </item>
    
    <item>
      <title>TDD: Suffering from testing last</title>
      <link>https://mneedham.github.io/2008/11/28/tdd-suffering-from-testing-last/</link>
      <pubDate>Fri, 28 Nov 2008 00:34:24 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/11/28/tdd-suffering-from-testing-last/</guid>
      <description>I&amp;rsquo;ve always been a big proponent of writing tests before writing code, and I roll off the standard reasons to people who question this approach:
 They help to drive the design They provide a safety net when making future changes They provide a way of communicating the intent of the code to the rest of the team  And so on. Despite knowing all this I recently took a non test driven approach to writing some bits of code - we were keen to get the system working end to end so it seemed a trade off worth making to prove that it was doable.</description>
    </item>
    
    <item>
      <title>Testing Test Code</title>
      <link>https://mneedham.github.io/2008/11/23/testing-test-code/</link>
      <pubDate>Sun, 23 Nov 2008 23:21:46 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/11/23/testing-test-code/</guid>
      <description>One of the interesting discussions that has come up on several projects I&amp;rsquo;ve worked on is whether or not we should test code that was written purely to help us test production code.
One of the main arguments used against testing test utility code is that it is not production code and therefore perhaps doesn&amp;rsquo;t need to be held to the same standards because it lacks the complexity of production code.</description>
    </item>
    
    <item>
      <title>Testing Hibernate mappings: Where to test from?</title>
      <link>https://mneedham.github.io/2008/10/27/testing-hibernate-mappings-where-to-test-from/</link>
      <pubDate>Mon, 27 Oct 2008 22:55:15 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/27/testing-hibernate-mappings-where-to-test-from/</guid>
      <description>I&amp;rsquo;ve had the opportunity to work with Hibernate and it&amp;rsquo;s .NET twin NHibernate on several of my projects and one of the more interesting decisions around its use is working out the best way to test the hibernate mappings that hook together our domain model and the database.
There are three decisions to make around how best to do this:
 Where to test the mappings from? How to test for equality?</description>
    </item>
    
    <item>
      <title>Using test guided techniques for spiking</title>
      <link>https://mneedham.github.io/2008/10/12/using-test-guided-techniques-for-spiking/</link>
      <pubDate>Sun, 12 Oct 2008 13:49:35 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/12/using-test-guided-techniques-for-spiking/</guid>
      <description>I think that out of all the Extreme Programming practices Test Driven Development is the one which I like the best. I feel it provides a structure for development work and helps me to remain focused on what I am trying to achieve rather than writing code which may not necessarily be needed.
However, there are times when it&amp;rsquo;s difficult to use a TDD approach, and Pat Kua suggested earlier this year that if you&amp;rsquo;re using a TDD approach all the time you&amp;rsquo;re doing something wrong.</description>
    </item>
    
    <item>
      <title>What is a unit test?</title>
      <link>https://mneedham.github.io/2008/10/10/what-is-a-unit-test/</link>
      <pubDate>Fri, 10 Oct 2008 23:21:43 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/10/what-is-a-unit-test/</guid>
      <description>One of the questions which came up during the Sydney Alt.NET User Group meeting at the start of October was around what a unit test actually is.
I suppose the somewhat naive or simplistic definition is that it is just any test written using an xUnit framework such as NUnit or JUnit. However, integration or acceptance tests are often written using these frameworks so this definition doesn&amp;rsquo;t hold.
While discussing this last week a colleague came up with what I considered to be a very clear yet precise definition.</description>
    </item>
    
    <item>
      <title>Test Driven Development By Example: Book Review</title>
      <link>https://mneedham.github.io/2008/10/07/test-driven-development-by-example-book-review/</link>
      <pubDate>Tue, 07 Oct 2008 23:17:19 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/07/test-driven-development-by-example-book-review/</guid>
      <description>The Book Test Driven Development by Example by Kent Beck
The Review I know this book is quite old but I haven&amp;rsquo;t read it before - it&amp;rsquo;s been recommended to me several times but I never got round to reading it, possibly because of my somewhat misguided opinion that seeing as I do TDD nearly every day I shouldn&amp;rsquo;t need to read it.
More by chance than anything else, I was browsing through a friend&amp;rsquo;s copy of the book and came across several gems of information which persuaded me that I should take the time to read the rest of it.</description>
    </item>
    
    <item>
      <title>It&#39;s not all about the acceptance tests</title>
      <link>https://mneedham.github.io/2008/10/03/its-not-all-about-the-acceptance-tests/</link>
      <pubDate>Fri, 03 Oct 2008 01:26:13 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/03/its-not-all-about-the-acceptance-tests/</guid>
      <description>A few of my colleagues recently posted their opinions about acceptance tests which tied in nicely with a discussion about acceptance testing that was had at the Alt.NET conference in London.
For the sake of argument I will assume that when we refer to acceptance tests we are talking about tests at the GUI level which are being automatically driven by a tool, usually Selenium but maybe something like White if it is a client side application.</description>
    </item>
    
    <item>
      <title>TDD without the design</title>
      <link>https://mneedham.github.io/2008/10/01/tdd-without-the-design/</link>
      <pubDate>Wed, 01 Oct 2008 00:32:20 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/10/01/tdd-without-the-design/</guid>
      <description>Roy Osherove and several others have posted recently about introducing TDD to the &amp;lsquo;masses&amp;rsquo;
As I understand it Roy&amp;rsquo;s idea is to separate the learning of TDD from the learning of good design principles - good design principles in this case being the OOP principles described in Uncle Bob&amp;rsquo;s Agile Software Development Principles, Practices and Practices or on the Object Mentor website.
I am usually in favour of an approach that breaks a skill down into chunks so that it is easier to learn but in this case I feel that some of the big gains in coding in a TDD way is the decoupled design it encourages, which in my experience is more likely to follow good design principles.</description>
    </item>
    
    <item>
      <title>Testing file system operations</title>
      <link>https://mneedham.github.io/2008/09/17/testing-file-system-operations/</link>
      <pubDate>Wed, 17 Sep 2008 15:48:37 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/09/17/testing-file-system-operations/</guid>
      <description>On my previous project one of the areas that we needed to work out how to test was around interaction with the file system.
The decision that we needed to make was whether we should unit test this type of functionality or whether it could just be covered by a functional test.
To Unit Test One of the patterns to use when unit testing things like this is the Gateway pattern.</description>
    </item>
    
    <item>
      <title>BDD style unit test names</title>
      <link>https://mneedham.github.io/2008/09/04/bdd-style-unit-test-names/</link>
      <pubDate>Thu, 04 Sep 2008 00:05:18 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/09/04/bdd-style-unit-test-names/</guid>
      <description>A couple of my colleagues have been posting about how to name your unit tests based on this original post by Jay Fields.
I think that test names are useful, especially when written in a BDD style expressing what a test is supposed to be doing.
For example, in a C# NUnit test we might see the following as a test name:
[Test] public void ShouldDoSomething() { // Code testing that we&#39;re doing something }  I write all my tests like this and I&amp;rsquo;m often asked what the point of the &amp;lsquo;Should&amp;rsquo; is, why not just name it &amp;lsquo;DoSomething&amp;rsquo;.</description>
    </item>
    
    <item>
      <title>Resharper templates</title>
      <link>https://mneedham.github.io/2008/08/27/resharper-templates/</link>
      <pubDate>Wed, 27 Aug 2008 11:58:03 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/08/27/resharper-templates/</guid>
      <description>One of the first things that I do when I go onto a project is setup a ReSharper template for writing tests.
I generally set this up so that when I type &amp;lsquo;should&amp;rsquo; I can press tab and it will automatically create an outline of a test method for me.
Creating a template is as simple as going to &amp;lsquo;ReSharper &amp;gt; Live Templates&amp;rsquo; from Visual Studio.
I have attached several templates that I seem to end up writing over and over again.</description>
    </item>
    
    <item>
      <title>If they were that rubbish...</title>
      <link>https://mneedham.github.io/2008/08/08/if-they-were-that-rubbish/</link>
      <pubDate>Fri, 08 Aug 2008 19:15:56 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2008/08/08/if-they-were-that-rubbish/</guid>
      <description>Jay Fields certainly seemed to make some waves in the blogosphere with his recent post about 50% of the people in business software development needing to find a new profession.
As a consultant I often go onto projects where a significant amount of difficult to understand and often untested code is in place. At times it feels like the people who have written it really don&amp;rsquo;t care about the quality of their work which can be very disheartening.</description>
    </item>
    
  </channel>
</rss>