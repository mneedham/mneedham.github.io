<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Mark Needham</title>
    <link>https://mneedham.github.io/category/algorithms/</link>
    <description>Recent content in Algorithms on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 20 Jan 2013 19:14:08 +0000</lastBuildDate>
    
	<atom:link href="https://mneedham.github.io/category/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Bellman-Ford algorithm in Python using vectorisation/numpy</title>
      <link>https://mneedham.github.io/2013/01/20/bellman-ford-algorithm-in-python-using-vectorisationnumpy/</link>
      <pubDate>Sun, 20 Jan 2013 19:14:08 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2013/01/20/bellman-ford-algorithm-in-python-using-vectorisationnumpy/</guid>
      <description>I recently wrote about an implementation of the Bellman Ford shortest path algorithm and concluded by saying that it took 27 seconds to calculate the shortest path in the graph for any node.
This seemed a bit slow and while browsing the Coursera forums I came across a suggestion that the algorithm would run much more quickly if we used vectorization with numpy rather than nested for loops.
Vectorisation refers to a problem solving approach where we make use of matrices operations which is what numpy allows us to do.</description>
    </item>
    
    <item>
      <title>Bellman-Ford algorithm in Python</title>
      <link>https://mneedham.github.io/2013/01/18/bellman-ford-algorithm-in-python/</link>
      <pubDate>Fri, 18 Jan 2013 00:40:32 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2013/01/18/bellman-ford-algorithm-in-python/</guid>
      <description>The latest problem of the Algorithms 2 class required us to write an algorithm to calculate the shortest path between two nodes on a graph and one algorithm which allows us to do this is Bellman-Ford.
Bellman-Ford computes the single source shortest path which means that if we have a 5 vertex graph we&#39;d need to run it 5 times to find the shortest path for each vertex and then find the shortest paths of those shortest paths.</description>
    </item>
    
    <item>
      <title>Knapsack Problem in Haskell</title>
      <link>https://mneedham.github.io/2013/01/09/knapsack-problem-in-haskell/</link>
      <pubDate>Wed, 09 Jan 2013 00:12:25 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2013/01/09/knapsack-problem-in-haskell/</guid>
      <description>I recently described two versions of the Knapsack problem written in Ruby and Python and one common thing is that I used a global cache to store the results of previous calculations.
From my experience of coding in Haskell it&#39;s not considered very idiomatic to write code like that and although I haven&#39;t actually tried it, potentially more tricky to achieve.
I thought it&#39;d be interesting to try and write the algorithm in Haskell with that constraint in mind and my first version looked like this:</description>
    </item>
    
    <item>
      <title>Knapsack Problem: Python vs Ruby</title>
      <link>https://mneedham.github.io/2013/01/07/knapsack-problem-python-vs-ruby/</link>
      <pubDate>Mon, 07 Jan 2013 00:47:34 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2013/01/07/knapsack-problem-python-vs-ruby/</guid>
      <description>The latest algorithm that we had to code in Algorithms 2 was the Knapsack problem which is as follows:
 The knapsack problem or rucksack problem is a problem in combinatorial optimization: Given a set of items, each with a weight and a value, determine the number of each item to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.</description>
    </item>
    
    <item>
      <title>Kruskal&#39;s Algorithm using union find in Ruby</title>
      <link>https://mneedham.github.io/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 21:43:42 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</guid>
      <description>I recently wrote a blog post describing my implementation of Kruskal&#39;s algorithm - a greedy algorithm using to find a minimum spanning tree (MST) of a graph - and while it does the job it&#39;s not particularly quick.
It takes 20 seconds to calculate the MST for a 500 node, ~2000 edge graph.
One way that we can improve the performance of the algorithm is by storing the MST in a union find/disjoint set data structure.</description>
    </item>
    
    <item>
      <title>Kruskal&#39;s Algorithm in Ruby</title>
      <link>https://mneedham.github.io/2012/12/23/kruskals-algorithm-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 14:18:53 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/12/23/kruskals-algorithm-in-ruby/</guid>
      <description>Last week I wrote a couple of posts showing different implementations of Prim&#39;s algorithm - an algorithm using to find a minimum spanning tree in a graph - and a similar algorithm is Kruskal&#39;s algorithm.
Kruskal&#39;s algorithm also finds a minimum spanning tree but it goes about it in a slightly different way.
Prim&#39;s algorithm takes an approach whereby we select nodes and then find connecting edges until we&#39;ve covered all the nodes.</description>
    </item>
    
    <item>
      <title>Prim&#39;s algorithm using a heap/priority queue in Ruby</title>
      <link>https://mneedham.github.io/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 16:31:05 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</guid>
      <description>I recently wrote a blog post describing my implementation of Prim&#39;s Algorithm for the Algorithms 2 class and while it comes up with the right answer for the supplied data set it takes almost 30 seconds to do so!
In one of the lectures Tim Roughgarden points out that we&#39;re doing the same calculations multiple times to work out the next smallest edge to include in our minimal spanning tree and could use a heap to speed things up.</description>
    </item>
    
    <item>
      <title>Prim&#39;s Algorithm in Ruby</title>
      <link>https://mneedham.github.io/2012/12/15/prims-algorithm-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 02:51:14 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/12/15/prims-algorithm-in-ruby/</guid>
      <description>One of theÂ first programming assignments of the Algorithms 2 course was to code Prim&#39;s algorithm - a greedy algorithm used to find the minimum spanning tree of a connected weighted undirected graph.
In simpler terms we need to find the path of least cost which connects all of the nodes together and there can&#39;t be any cycles in that path.
Wikipedia has a neat diagram which shows this more clearly:</description>
    </item>
    
    <item>
      <title>Algorithms: Rabin Karp in Haskell</title>
      <link>https://mneedham.github.io/2012/04/25/algorithms-rabin-karp-in-haskell/</link>
      <pubDate>Wed, 25 Apr 2012 21:28:42 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/04/25/algorithms-rabin-karp-in-haskell/</guid>
      <description>I recently came across a blog post describing the Rabin Karp algorithm - an algorithm that uses hashing to find a pattern string in some text - and thought it would be interesting to try and write a version of it in Haskell.
This algorithm is typically used when we want to search for multiple pattern strings in a text e.g. when detecting plagiarism or a primitive way of detecting code duplication but my initial version only lets your search for one pattern.</description>
    </item>
    
    <item>
      <title>Algo Class: Start simple and build up</title>
      <link>https://mneedham.github.io/2012/04/24/algo-class-start-simple-and-build-up/</link>
      <pubDate>Tue, 24 Apr 2012 07:17:24 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/04/24/algo-class-start-simple-and-build-up/</guid>
      <description>Over the last six weeks I&amp;rsquo;ve been working through Stanford&amp;rsquo;s Design and Analysis of Algorithms I class and each week there&amp;rsquo;s been a programming assignment on a specific algorithm for which a huge data set is provided.
For the first couple of assignments I tried writing the code for the algorithm and then running it directly against the provided data set.
As you might imagine it never worked first time and this approach led to me becoming very frustrated because there&amp;rsquo;s no way of telling what went wrong.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell - Abstracting the common</title>
      <link>https://mneedham.github.io/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</link>
      <pubDate>Tue, 17 Apr 2012 07:22:12 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</guid>
      <description>In the comments of my blog post describing the flood fill algorithm in Haskell David Turner pointed out that the way I was passing the grid around was quite error prone.
floodFill :: Array (Int, Int) Colour -&amp;gt; (Int, Int) -&amp;gt; Colour -&amp;gt; Colour -&amp;gt; Array (Int, Int) Colour floodFill grid point@(x, y) target replacement = if((not $ inBounds grid point) || grid ! (x,y) /= target) then grid else gridNorth where grid&#39; = replace grid point replacement gridEast = floodFill grid&#39; (x+1, y) target replacement gridWest = floodFill gridEast (x-1, y) target replacement gridSouth = floodFill gridWest (x, y+1) target replacement gridNorth = floodFill gridSouth (x, y-1) target replacement  I actually did pass the wrong grid variable around while I was writing it and ended up quite confused as to why it wasn&amp;rsquo;t working as I expected.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell</title>
      <link>https://mneedham.github.io/2012/04/07/algorithms-flood-fill-in-haskell/</link>
      <pubDate>Sat, 07 Apr 2012 00:25:34 +0000</pubDate>
      
      <guid>https://mneedham.github.io/2012/04/07/algorithms-flood-fill-in-haskell/</guid>
      <description>Flood fill is an algorithm used to work out which nodes are connected to a certain node in a multi dimensional array. In this case we&amp;rsquo;ll use a two dimensional array.
The idea is that we decide that we want to change the colour of one of the cells in the array and have its immediate neighbours who share its initial colour have their colour changed too i.e. the colour floods its way through the grid.</description>
    </item>
    
  </channel>
</rss>