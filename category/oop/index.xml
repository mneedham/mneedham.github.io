<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Oop on Mark Needham</title>
    <link>http://mneedham.github.io/category/oop/</link>
    <description>Recent content in Oop on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 31 Dec 2009 16:08:25 +0000</lastBuildDate>
    
	<atom:link href="http://mneedham.github.io/category/oop/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>OOP: Behavioural and Structural constraints</title>
      <link>http://mneedham.github.io/2009/12/31/oop-behavioural-and-structural-constraints/</link>
      <pubDate>Thu, 31 Dec 2009 16:08:25 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/12/31/oop-behavioural-and-structural-constraints/</guid>
      <description>A few months ago I wrote a post describing how we should test the behaviour of code rather than the implementation whereby we would write tests against the public API of an object rather than exposing other internal data of the object and testing against that directly.
While I still think this is a useful way of testing code I didn&amp;rsquo;t really have a good definition for what makes that a test of an object&amp;rsquo;s behaviour.</description>
    </item>
    
    <item>
      <title>OO with a bit of functional mixed in</title>
      <link>http://mneedham.github.io/2009/04/25/oo-with-a-bit-of-functional-mixed-in/</link>
      <pubDate>Sat, 25 Apr 2009 11:14:12 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/04/25/oo-with-a-bit-of-functional-mixed-in/</guid>
      <description>From my experiences playing around with F# and doing a bit of functional C# I&amp;rsquo;m beginning to think that the combination of functional and object oriented programming actually results in code which I think is more expressive and easy to work with than code written only with an object oriented approach in mind.
I&amp;rsquo;m also finding it much more fun to write code this way!
In a recent post Dean Wampler questions whether the supremacy of object oriented programming is over before going on to suggest that the future is probably going to be a mix of functional programming and object oriented programming.</description>
    </item>
    
    <item>
      <title>QTB: Lean Times Require Lean Thinking</title>
      <link>http://mneedham.github.io/2009/03/25/qtb-lean-times-require-lean-thinking/</link>
      <pubDate>Wed, 25 Mar 2009 00:36:09 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/03/25/qtb-lean-times-require-lean-thinking/</guid>
      <description>I went to watch the latest ThoughtWorks Quarterly Technology Briefing on Tuesday, which was presented by my colleague Jason Yip and Paul Heaton, titled &amp;lsquo;Lean Times Require Lean Thinking&amp;lsquo;
I&amp;rsquo;ve been reading quite a bit of lean related material lately but I thought it would be interesting to hear about it directly from the perspective of two people who have been involved with applying the concepts in organisations.
What did I learn?</description>
    </item>
    
    <item>
      <title>OO: Reducing the cost of...lots of stuff!</title>
      <link>http://mneedham.github.io/2009/03/12/oo-reducing-the-cost-oflots-of-stuff/</link>
      <pubDate>Thu, 12 Mar 2009 04:04:22 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/03/12/oo-reducing-the-cost-oflots-of-stuff/</guid>
      <description>I&amp;rsquo;ve been working in the world of professional software development for a few years now and pretty much take it as a given that the best way to write code which is easy for other people to understand and work with is to write that code in an object oriented way.
Not everyone agrees with this approach of course and I&amp;rsquo;ve been told on occasions that I&amp;rsquo;m &amp;lsquo;over object orienting&amp;rsquo; (is that even a word?</description>
    </item>
    
    <item>
      <title>OO: Micro Types</title>
      <link>http://mneedham.github.io/2009/03/10/oo-micro-types/</link>
      <pubDate>Tue, 10 Mar 2009 22:40:57 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/03/10/oo-micro-types/</guid>
      <description>Micro or Tiny types present an approach to coding which seems to divide opinion in my experience, from those who think it&amp;rsquo;s a brilliant idea to those who believe it&amp;rsquo;s static typing gone mad.
I fall into the former group.
So what is it?
The idea is fairly simple - all primitives and strings in our code are wrapped by a class, meaning that we never pass primitives around.
In essence Rule #3 of Jeff Bay&amp;rsquo;s Object Calisthenics.</description>
    </item>
    
    <item>
      <title>OOP: What does an object&#39;s responsibility entail?</title>
      <link>http://mneedham.github.io/2009/02/09/oop-what-does-an-objects-responsibility-entail/</link>
      <pubDate>Mon, 09 Feb 2009 16:52:10 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2009/02/09/oop-what-does-an-objects-responsibility-entail/</guid>
      <description>One of the interesting discussions I&amp;rsquo;ve been having recently with some colleagues is around where the responsibility lies for describing the representation of an object when it is to be used in another bounded context - e.g. on the user interface or in a call to another system.
I believe that an object should be responsible for deciding how its data is used rather than having another object reach into it, retrieve its data and then decide what to do with it.</description>
    </item>
    
    <item>
      <title>Similarities between Domain Driven Design &amp; Object Oriented Programming</title>
      <link>http://mneedham.github.io/2008/09/20/similarities-between-domain-driven-design-object-oriented-programming/</link>
      <pubDate>Sat, 20 Sep 2008 13:12:25 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2008/09/20/similarities-between-domain-driven-design-object-oriented-programming/</guid>
      <description>At the Alt.NET UK Conference which I attended over the weekend it occurred to me while listening to some of the discussions on Domain Driven Design that a lot of the ideas in DDD are actually very similar to those being practiced in Object Oriented Programming and related best practices.
The similarities Anaemic Domain Model/Law of Demeter There was quite a bit of discussion in the session about anaemic domain models.</description>
    </item>
    
  </channel>
</rss>