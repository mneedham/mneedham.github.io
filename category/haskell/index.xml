<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Haskell on Mark Needham</title>
    <link>http://mneedham.github.io/category/haskell/</link>
    <description>Recent content in Haskell on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jan 2013 00:12:25 +0000</lastBuildDate>
    
	<atom:link href="http://mneedham.github.io/category/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Knapsack Problem in Haskell</title>
      <link>http://mneedham.github.io/2013/01/09/knapsack-problem-in-haskell/</link>
      <pubDate>Wed, 09 Jan 2013 00:12:25 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2013/01/09/knapsack-problem-in-haskell/</guid>
      <description>I recently described two versions of the Knapsack problem written in Ruby and Python and one common thing is that I used a global cache to store the results of previous calculations.
From my experience of coding in Haskell it&#39;s not considered very idiomatic to write code like that and although I haven&#39;t actually tried it, potentially more tricky to achieve.
I thought it&#39;d be interesting to try and write the algorithm in Haskell with that constraint in mind and my first version looked like this:</description>
    </item>
    
    <item>
      <title>Haskell: Reading files</title>
      <link>http://mneedham.github.io/2013/01/02/haskell-reading-files/</link>
      <pubDate>Wed, 02 Jan 2013 00:16:50 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2013/01/02/haskell-reading-files/</guid>
      <description>In writing the clustering algorithm which I&#39;ve mentioned way too many times already I needed to process a text file which contained all the points and my initial approach looked like this:
import System.IO main = do withFile &amp;quot;clustering2.txt&amp;quot; ReadMode (\handle -&amp;gt; do contents &amp;lt;- hGetContents handle putStrLn contents)  It felt a bit clunky but I didn&#39;t realise there was an easier way until I came across this thread. We can simplify reading a file to the following by using the readFile function:</description>
    </item>
    
    <item>
      <title>Haskell: Downloading the core library source code</title>
      <link>http://mneedham.github.io/2012/12/31/haskell-downloading-the-core-library-source-code/</link>
      <pubDate>Mon, 31 Dec 2012 22:39:15 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/31/haskell-downloading-the-core-library-source-code/</guid>
      <description>I&#39;ve started playing around with Haskell again and since I&#39;m doing so on a new machine I don&#39;t have a copy of the language source code. I wanted to rectify that situation but my Google fu was weak and it took me way too long to figure out how to get it so I thought I&#39;d better document it for future me.
The easiest way is to clone the copy of the GHC repository on github:</description>
    </item>
    
    <item>
      <title>Haskell: Strictness and the monadic bind</title>
      <link>http://mneedham.github.io/2012/12/31/haskell-strictness-and-the-monadic-bind/</link>
      <pubDate>Mon, 31 Dec 2012 22:27:15 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/31/haskell-strictness-and-the-monadic-bind/</guid>
      <description>As I mentioned towards the end of my post about implementing the union find data structure in Haskell I wrote another version using a mutable array and having not seen much of a performance improvement started commenting out code to try and find the problem.
I eventually narrowed it down to the union function which was defined like so:
union :: IO (IOArray Int Int) -&amp;gt; Int -&amp;gt; Int -&amp;gt; IO (IOArray Int Int) union arrayContainer x y = do actualArray &amp;lt;- arrayContainer ls &amp;lt;- getAssocs actualArray leader1 &amp;lt;- readArray actualArray x leader2 &amp;lt;- readArray actualArray y let newValues = (map (\(index, value) -&amp;gt; (index, leader1)) .</description>
    </item>
    
    <item>
      <title>Haskell: An impressively non performant union find</title>
      <link>http://mneedham.github.io/2012/12/31/haskell-an-impressively-non-performant-union-find/</link>
      <pubDate>Mon, 31 Dec 2012 20:44:56 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/31/haskell-an-impressively-non-performant-union-find/</guid>
      <description>I&#39;ve spent the best part of the last day debugging a clustering algorithm I wrote as part of the Algorithms 2 course, eventually coming to the conclusion that the union find data structure I was using wasn&#39;t working as expected.
In our algorithm we&#39;re trying to group together points which are &#39;close&#39; to each other and the data structure is particular useful for doing that.
To paraphrase from my previous post about how we use the union find data structure:</description>
    </item>
    
    <item>
      <title>Bitwise operations in Ruby and Haskell</title>
      <link>http://mneedham.github.io/2012/12/31/bitwise-operations-in-ruby-and-haskell/</link>
      <pubDate>Mon, 31 Dec 2012 13:14:42 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/31/bitwise-operations-in-ruby-and-haskell/</guid>
      <description>Part of one of the most recent problems in the Algorithms 2 course required us to find the &#39;neighbours&#39; of binary values.
In this case a neighbour is described as being any other binary value which has an equivalent value or differs in 1 or 2 bits.
e.g. the neighbours of &#39;10000&#39; would be &#39;00000&#39;, &#39;00001&#39;, &#39;00010&#39;, &#39;00100&#39;, &#39;&#39;01000&#39;, &#39;10001&#39;, &#39;10010&#39;, &#39;10011&#39;, &#39;10100&#39;, &#39;10101&#39;, &#39;10110&#39;, &#39;11000&#39;, &#39;11001&#39;, &#39;11010&#39; and &#39;11100&#39;~~~ I initially treated &#39;10000&#39; as an array of 1s and 0s and wrote a function to recursively come up with the above combinations before it was pointed out to me that it&#39;d be much easier to use bit wise logic instead.</description>
    </item>
    
    <item>
      <title>Haskell: Using qualified imports to avoid polluting the namespace</title>
      <link>http://mneedham.github.io/2012/12/30/haskell-using-qualified-imports-to-avoid-polluting-the-namespace/</link>
      <pubDate>Sun, 30 Dec 2012 23:16:48 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/30/haskell-using-qualified-imports-to-avoid-polluting-the-namespace/</guid>
      <description>In most of the Haskell code I&#39;ve read any functions from other modules have been imported directly into the namespace and I reached the stage where I had this list of imports in a file:
import System.IO import Data.List.Split import Data.Char import Data.Bits import Control.Monad import Data.Map import Data.Set import Data.List import Data.Maybe  This becomes a problem when you want to use a function which is defined in multiple modules such as filter:</description>
    </item>
    
    <item>
      <title>Haskell: Pattern matching a list</title>
      <link>http://mneedham.github.io/2012/12/30/haskell-pattern-matching-a-list/</link>
      <pubDate>Sun, 30 Dec 2012 22:39:16 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/30/haskell-pattern-matching-a-list/</guid>
      <description>As I mentioned in a post yesterday I&#39;ve been converting a clustering algorithm into Haskell and I wanted to get the value from doing a bit wise or on two values in a list.
I forgot it was possible to pattern match on lists until I came across a post I wrote about 8 months ago where I&#39;d done this so my initial code looked like this:
&amp;gt; import Data.Bits &amp;gt; map (\pair -&amp;gt; (pair !</description>
    </item>
    
    <item>
      <title>Haskell: A cleaner way of initialising a map</title>
      <link>http://mneedham.github.io/2012/12/29/haskell-a-cleaner-way-of-initialising-a-map/</link>
      <pubDate>Sat, 29 Dec 2012 20:14:12 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/29/haskell-a-cleaner-way-of-initialising-a-map/</guid>
      <description>I recently wrote a blog post showing a way of initialising a Haskell map and towards the end of the post I realised how convoluted my approach was and wondered if there was an easier way and indeed there is!
To recap, this is the code I ended up with to populate a map with binary based values as the keys and node ids as the values:
import Data.Map toMap :: [Int] -&amp;gt; Map Int [Int] toMap nodes = fromList $ map asMapEntry $ (groupIgnoringIndex .</description>
    </item>
    
    <item>
      <title>Haskell: Initialising a map</title>
      <link>http://mneedham.github.io/2012/12/29/haskell-initialising-a-map/</link>
      <pubDate>Sat, 29 Dec 2012 19:27:46 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/12/29/haskell-initialising-a-map/</guid>
      <description>I&#39;ve been converting a variation of Kruskal&#39;s algorithm from Ruby into Haskell and one thing I needed to do was create a map of binary based values to node ids.
In Ruby I wrote the following code to do this:
nodes = [1,2,5,7,2,4] @magical_hash = {} nodes.each_with_index do |node, index| @magical_hash[node] ||= [] @magical_hash[node] &amp;lt;&amp;lt; index end =&amp;gt; {1=&amp;gt;[0], 2=&amp;gt;[1, 4], 5=&amp;gt;[2], 7=&amp;gt;[3], 4=&amp;gt;[5]}  From looking at the documentation it seemed like the easiest way to do this in Haskell would be to convert the nodes into an appropriate list and then call the fromList function to build the map.</description>
    </item>
    
    <item>
      <title>Haskell: Mixed type lists</title>
      <link>http://mneedham.github.io/2012/06/19/haskell-mixed-type-lists/</link>
      <pubDate>Tue, 19 Jun 2012 23:09:39 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/06/19/haskell-mixed-type-lists/</guid>
      <description>I&amp;rsquo;ve been continuing to work through the exercises in The Little Schemer and came across a problem which needed me to write a function to take a mixed list of Integers and Strings and filter out the Integers.
As I mentioned in my previous post I&amp;rsquo;ve been doing the exercises in Haskell but I thought I might struggle with that approach here because Haskell collections are homogeneous i.e. all the elements need to be of the same type.</description>
    </item>
    
    <item>
      <title>Haskell: Writing a function that can take Ints or Doubles</title>
      <link>http://mneedham.github.io/2012/06/05/haskell-writing-a-function-that-can-take-ints-or-doubles/</link>
      <pubDate>Tue, 05 Jun 2012 00:10:29 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/06/05/haskell-writing-a-function-that-can-take-ints-or-doubles/</guid>
      <description>In my continued reading of SICP I wanted to recreate a &amp;lsquo;sum&amp;rsquo; function used to demonstrate a function which could take another function as one of its parameters.
In Scheme the function is defined like this:
(define (sum term a next b) (if (&amp;gt; a b) 0 (+ (term a) (sum term (next a) next b))))  And can be used like this to sum the values between two numbers:</description>
    </item>
    
    <item>
      <title>Haskell: Building a range of numbers from command line arguments</title>
      <link>http://mneedham.github.io/2012/06/03/haskell-building-a-range-of-numbers-from-command-line-arguments/</link>
      <pubDate>Sun, 03 Jun 2012 20:13:54 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/06/03/haskell-building-a-range-of-numbers-from-command-line-arguments/</guid>
      <description>I&amp;rsquo;m working through some of the SICP problems in Haskell and for problem 1.22 you need to write a function which will indicate the first 3 prime numbers above a starting value.
It is also suggested to only consider odd numbers so to find the prime numbers above 1000 the function call would look like this:
&amp;gt; searchForPrimes [1001,1003..] [1009,1013,1019]  I wanted to be able to feed in the range of numbers from the command line so that I&amp;rsquo;d be able to call the function with different values and see how long it took to work it out.</description>
    </item>
    
    <item>
      <title>Haskell: Using type classes to generify Project Euler #31</title>
      <link>http://mneedham.github.io/2012/05/30/haskell-using-type-classes-to-generify-project-euler-31/</link>
      <pubDate>Wed, 30 May 2012 12:08:25 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/30/haskell-using-type-classes-to-generify-project-euler-31/</guid>
      <description>As I mentioned in my previous post I&amp;rsquo;ve been working on Project Euler #31 and initially wasn&amp;rsquo;t sure how to write the algorithm.
I came across a post on StackOverflow which explained it in more detail but unfortunately the example used US coins rather than UK ones like in the Project Euler problem.
To start with I created two versions of the function - one for US coins and one for UK coins:</description>
    </item>
    
    <item>
      <title>Haskell: Java Style Enums</title>
      <link>http://mneedham.github.io/2012/05/30/haskell-java-style-enums/</link>
      <pubDate>Wed, 30 May 2012 11:10:15 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/30/haskell-java-style-enums/</guid>
      <description>I&amp;rsquo;ve been playing around with problem 31 of Project Euler which is defined as follows:
 In England the currency is made up of pound, £, and pence, p, and there are eight coins in general circulation: 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p). It is possible to make £2 in the following way: 1 £1 + 150p + 220p + 15p + 12p + 31p How many different ways can £2 be made using any number of coins?</description>
    </item>
    
    <item>
      <title>Haskell: Finding the minimum &amp; maximum values of a Foldable in one pass</title>
      <link>http://mneedham.github.io/2012/05/28/haskell-finding-the-minimum-maximum-values-of-a-foldable-in-one-pass/</link>
      <pubDate>Mon, 28 May 2012 11:18:13 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/28/haskell-finding-the-minimum-maximum-values-of-a-foldable-in-one-pass/</guid>
      <description>I recently came across Dan Piponi&amp;rsquo;s blog post &amp;lsquo;Haskell Monoids &amp;amp; their Uses&amp;rsquo; and towards the end of the post he suggests creating monoids to work out the maximum and minimum values of a Foldable value in one pass.
 The Foldable type class provides a generic approach to walking through a datastructure, accumulating values as we go. The foldMap function applies a function to each element of our structure and then accumulates the return values of each of these applications.</description>
    </item>
    
    <item>
      <title>Haskell: Debugging code</title>
      <link>http://mneedham.github.io/2012/05/27/haskell-debugging-code/</link>
      <pubDate>Sun, 27 May 2012 22:16:38 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/27/haskell-debugging-code/</guid>
      <description>In my continued attempts to learn QuickCheck, one thing I&amp;rsquo;ve been doing is comparing the results of my brute force and divide &amp;amp; conquer versions of the closest pairs algorithm.
I started with this property:
let prop_dc_bf xs = (length xs &amp;gt; 2) ==&amp;gt; (fromJust $ bfClosest xs) == dcClosest xs  And then ran it from GHCI, which resulted in the following error:
&amp;gt; quickCheck (prop_dc_bf :: [(Double, Double)] -&amp;gt; Property) *** Failed!</description>
    </item>
    
    <item>
      <title>Haskell: Using monoids when sorting by multiple parameters</title>
      <link>http://mneedham.github.io/2012/05/23/haskell-using-monoids-when-sorting-by-multiple-parameters/</link>
      <pubDate>Wed, 23 May 2012 06:44:41 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/23/haskell-using-monoids-when-sorting-by-multiple-parameters/</guid>
      <description>On the project I&amp;rsquo;ve been working on we had a requirement to sort a collection of rows by 4 different criteria such that if two items matched for the first criteria we should consider the second criteria and so on.
If we wrote that code in Haskell it would read a bit like this:
data Row = Row { shortListed :: Bool, cost :: Float, distance1 :: Int, distance2 :: Int } deriving (Show, Eq)  import Data.</description>
    </item>
    
    <item>
      <title>Scala/Haskell: A simple example of type classes</title>
      <link>http://mneedham.github.io/2012/05/22/scalahaskell-a-simple-example-of-type-classes/</link>
      <pubDate>Tue, 22 May 2012 10:26:49 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/22/scalahaskell-a-simple-example-of-type-classes/</guid>
      <description>I never really understood type classes when I was working with Scala but I recently came across a video where Dan Rosen explains them pretty well.
Since the last time I worked in Scala I&amp;rsquo;ve been playing around with Haskell where type classes are much more common - for example if we want to compare two values we need to make sure that their type extends the &amp;lsquo;Eq&amp;rsquo; type class.</description>
    </item>
    
    <item>
      <title>Haskell: My first attempt with QuickCheck and HUnit</title>
      <link>http://mneedham.github.io/2012/05/20/haskell-my-first-attempt-with-quickcheck-and-hunit/</link>
      <pubDate>Sun, 20 May 2012 19:09:52 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/20/haskell-my-first-attempt-with-quickcheck-and-hunit/</guid>
      <description>As I mentioned in a blog post a few days I&amp;rsquo;ve started learning QuickCheck with the test-framework package as suggested by David Turner.
I first needed to install test-framework and some dependencies using cabal:
&amp;gt; cabal install test-framework &amp;gt; cabal install test-framework-quickcheck &amp;gt; cabal install test-framework-hunit  I thought it&amp;rsquo;d be interesting to try and write some tests around the windowed function that I wrote a few months ago:
Windowed.hs</description>
    </item>
    
    <item>
      <title>Haskell: Writing a custom equality operator</title>
      <link>http://mneedham.github.io/2012/05/16/haskell-writing-a-custom-equality-operator/</link>
      <pubDate>Wed, 16 May 2012 13:16:48 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/16/haskell-writing-a-custom-equality-operator/</guid>
      <description>In the comments on my post about generating random numbers to test a function David Turner suggested that this was exactly the use case for which QuickCheck was intended for so I&amp;rsquo;ve been learning a bit more about that this week.
I started with a simple property to check that the brute force (bf) and divide and conquer (dc) versions of the algorithm returned the same result, assuming that there were enough values in the list to have a closest pair:</description>
    </item>
    
    <item>
      <title>Haskell: Removing if statements</title>
      <link>http://mneedham.github.io/2012/05/12/haskell-removing-if-statements/</link>
      <pubDate>Sat, 12 May 2012 15:46:31 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/12/haskell-removing-if-statements/</guid>
      <description>When I was looking over my solution to the closest pairs algorithm which I wrote last week I realised there there were quite a few if statements, something I haven&amp;rsquo;t seen in other Haskell code I&amp;rsquo;ve read.
This is the initial version that I wrote:
dcClosest :: (Ord a, Floating a) =&amp;gt; [Point a] -&amp;gt; (Point a, Point a) dcClosest pairs if length pairs &amp;lt;= 3 then = fromJust $ bfClosest pairs else foldl (\closest (p1:p2:_) -&amp;gt; if distance (p1, p2) &amp;lt; distance closest then (p1, p2) else closest) closestPair (windowed 2 pairsWithinMinimumDelta) where sortedByX = sortBy compare pairs	(leftByX:rightByX:_) = chunk (length sortedByX `div` 2) sortedByX closestPair = if distance closestLeftPair &amp;lt; distance closestRightPair then closestLeftPair else closestRightPair where closestLeftPair = dcClosest leftByX closestRightPair = dcClosest rightByX pairsWithinMinimumDelta = sortBy (compare `on` snd) $ filter withinMinimumDelta sortedByX where withinMinimumDelta (x, _) = abs (xMidPoint - x) &amp;lt;= distance closestPair where (xMidPoint, _) = last leftByX  We can remove the first if statement which checks the length of the list and replace it with pattern matching code like so:</description>
    </item>
    
    <item>
      <title>Haskell: Explicit type declarations in GHCI</title>
      <link>http://mneedham.github.io/2012/05/10/haskell-explicit-type-declarations-in-ghci/</link>
      <pubDate>Thu, 10 May 2012 07:11:17 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/10/haskell-explicit-type-declarations-in-ghci/</guid>
      <description>On a few occasions I&amp;rsquo;ve wanted to be able to explicitly define the type of something when trying things out in the Haskell REPL (GHCI) but I didn&amp;rsquo;t actually realise this was possible until a couple of days ago.
For example say we want to use the read function to parse an input string into an integer.
We could do this:
&amp;gt; read &amp;quot;1&amp;quot; :: Int 1  But if we just evaluate the function alone and try and assign the result without casting to a type we get an exception:</description>
    </item>
    
    <item>
      <title>Haskell: Closest Pairs Algorithm</title>
      <link>http://mneedham.github.io/2012/05/09/haskell-closest-pairs-algorithm/</link>
      <pubDate>Wed, 09 May 2012 00:05:56 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/09/haskell-closest-pairs-algorithm/</guid>
      <description>As I mentioned in a post a couple of days ago I&amp;rsquo;ve been writing the closest pairs algorithm in Haskell and while the brute force version works for small numbers of pairs it starts to fall apart as the number of pairs increases:
time ./closest_pairs 100 bf ./closest_pairs 100 bf 0.01s user 0.00s system 87% cpu 0.016 total time ./closest_pairs 1000 bf ./closest_pairs 1000 bf 3.59s user 0.01s system 99% cpu 3.</description>
    </item>
    
    <item>
      <title>Haskell: Generating random numbers</title>
      <link>http://mneedham.github.io/2012/05/08/haskell-generating-random-numbers/</link>
      <pubDate>Tue, 08 May 2012 22:09:17 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/08/haskell-generating-random-numbers/</guid>
      <description>As I mentioned in my last post I&amp;rsquo;ve been coding the closest pairs algorithm in Haskell and needed to create some pairs of coordinates to test it against.
I&amp;rsquo;ve tried to work out how to create lists of random numbers in Haskell before and always ended up giving up because it seemed way more difficult than it should be but this time I came across a really good explanation of how to do it by jrockway on Stack Overflow.</description>
    </item>
    
    <item>
      <title>Haskell: Maximum Int value</title>
      <link>http://mneedham.github.io/2012/05/07/haskell-maximum-int-value/</link>
      <pubDate>Mon, 07 May 2012 09:18:02 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/05/07/haskell-maximum-int-value/</guid>
      <description>One of the algorithms covered in Algo Class was the closest pairs algorithm - an algorithm used to determine which pair of points on a plane are closest to each other based on their Euclidean distance.
My real interest lies in writing the divide and conquer version of the algorithm but I started with the brute force version so that I&amp;rsquo;d be able to compare my answers.
This is the algorithm:</description>
    </item>
    
    <item>
      <title>Haskell: Colour highlighting when writing to the shell</title>
      <link>http://mneedham.github.io/2012/04/29/haskell-colour-highlighting-when-writing-to-the-shell/</link>
      <pubDate>Sun, 29 Apr 2012 00:01:07 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/29/haskell-colour-highlighting-when-writing-to-the-shell/</guid>
      <description>I spent a few hours writing a simple front end on top of the Rabin Karp algorithm so that I could show the line of the first occurrence of a pattern in a piece of text on the shell.
I thought it would be quite cool if I could highlight the appropriate text on the line like how grep does when the &amp;lsquo;&amp;ndash;color=auto&amp;rsquo; flag is supplied.
We can make use of ANSI escape codes to do this.</description>
    </item>
    
    <item>
      <title>Haskell: Int and Integer</title>
      <link>http://mneedham.github.io/2012/04/28/haskell-int-and-integer/</link>
      <pubDate>Sat, 28 Apr 2012 17:39:54 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/28/haskell-int-and-integer/</guid>
      <description>In my last post about the Rabin Karp algorithm I mentioned that I was having some problems when trying to write a hash function which closely matched its English description.
 ((rm-1 * ascii char) + (rm-2 * ascii char) + … (r0 * ascii char)) % q where r = 256, q = 1920475943  This is my current version of the hash function:
hash = hash&#39; globalR globalQ hash&#39; r q string m = foldl (\acc x -&amp;gt; (r * acc + ord x) `mod` q) 0 $ take m string  And my initial attempt to write the alternate version was this:</description>
    </item>
    
    <item>
      <title>Algorithms: Rabin Karp in Haskell</title>
      <link>http://mneedham.github.io/2012/04/25/algorithms-rabin-karp-in-haskell/</link>
      <pubDate>Wed, 25 Apr 2012 21:28:42 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/25/algorithms-rabin-karp-in-haskell/</guid>
      <description>I recently came across a blog post describing the Rabin Karp algorithm - an algorithm that uses hashing to find a pattern string in some text - and thought it would be interesting to try and write a version of it in Haskell.
This algorithm is typically used when we want to search for multiple pattern strings in a text e.g. when detecting plagiarism or a primitive way of detecting code duplication but my initial version only lets your search for one pattern.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell - Abstracting the common</title>
      <link>http://mneedham.github.io/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</link>
      <pubDate>Tue, 17 Apr 2012 07:22:12 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</guid>
      <description>In the comments of my blog post describing the flood fill algorithm in Haskell David Turner pointed out that the way I was passing the grid around was quite error prone.
floodFill :: Array (Int, Int) Colour -&amp;gt; (Int, Int) -&amp;gt; Colour -&amp;gt; Colour -&amp;gt; Array (Int, Int) Colour floodFill grid point@(x, y) target replacement = if((not $ inBounds grid point) || grid ! (x,y) /= target) then grid else gridNorth where grid&#39; = replace grid point replacement gridEast = floodFill grid&#39; (x+1, y) target replacement gridWest = floodFill gridEast (x-1, y) target replacement gridSouth = floodFill gridWest (x, y+1) target replacement gridNorth = floodFill gridSouth (x, y-1) target replacement  I actually did pass the wrong grid variable around while I was writing it and ended up quite confused as to why it wasn&amp;rsquo;t working as I expected.</description>
    </item>
    
    <item>
      <title>Haskell: A simple parsing example using pattern matching</title>
      <link>http://mneedham.github.io/2012/04/15/haskell-a-simple-parsing-example-using-pattern-matching/</link>
      <pubDate>Sun, 15 Apr 2012 14:22:45 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/15/haskell-a-simple-parsing-example-using-pattern-matching/</guid>
      <description>As part of the second question in the Google Code Jam I needed to be able to parse lines of data which looked like this:
3 1 5 15 13 11  where
The first integer will be N, the number of Googlers, and the second integer will be S, the number of surprising triplets of scores. The third integer will be p, as described above. Next will be N integers ti: the total points of the Googlers.</description>
    </item>
    
    <item>
      <title>Haskell: Reading in multiple lines of arguments</title>
      <link>http://mneedham.github.io/2012/04/15/haskell-reading-in-multiple-lines-of-arguments/</link>
      <pubDate>Sun, 15 Apr 2012 13:44:09 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/15/haskell-reading-in-multiple-lines-of-arguments/</guid>
      <description>I&amp;rsquo;ve mostly avoided doing any I/O in Haskell but as part of the Google Code Jam I needed to work out how to read a variable number of lines as specified by the user.
The input looks like this:
4 3 1 5 15 13 11 3 0 8 23 22 21 2 1 1 8 0 6 2 8 29 20 8 18 18 21  The first line indicates how many lines will follow.</description>
    </item>
    
    <item>
      <title>Haskell: Processing program arguments</title>
      <link>http://mneedham.github.io/2012/04/08/haskell-processing-program-arguments/</link>
      <pubDate>Sun, 08 Apr 2012 20:11:57 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/08/haskell-processing-program-arguments/</guid>
      <description>My Prismatic news feed recently threw up an interesting tutorial titled &amp;lsquo;Haskell the Hard Way&amp;rsquo; which has an excellent and easy to understand section showing how to do IO in Haskell.
About half way down the page there&amp;rsquo;s an exercise to write a program which sums all its arguments which I thought I&amp;rsquo;d have a go at.
We need to use the System.getArgs function to get the arguments passed to the program.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell</title>
      <link>http://mneedham.github.io/2012/04/07/algorithms-flood-fill-in-haskell/</link>
      <pubDate>Sat, 07 Apr 2012 00:25:34 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/07/algorithms-flood-fill-in-haskell/</guid>
      <description>Flood fill is an algorithm used to work out which nodes are connected to a certain node in a multi dimensional array. In this case we&amp;rsquo;ll use a two dimensional array.
The idea is that we decide that we want to change the colour of one of the cells in the array and have its immediate neighbours who share its initial colour have their colour changed too i.e. the colour floods its way through the grid.</description>
    </item>
    
    <item>
      <title>Haskell: Print friendly representation of an Array</title>
      <link>http://mneedham.github.io/2012/04/03/haskell-print-friendly-representation-of-an-array/</link>
      <pubDate>Tue, 03 Apr 2012 21:52:56 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/04/03/haskell-print-friendly-representation-of-an-array/</guid>
      <description>Quite frequently I play around with 2D arrays in Haskell but I&amp;rsquo;ve never quite worked out how to print them in a way that makes it easy to see the contents.
I&amp;rsquo;m using the array from the &amp;lsquo;Data.Array&amp;rsquo; module because it seems to be easier to transform them into a new representation if I want to change a value in one of the cells.
The function to create one therefore looks like this:</description>
    </item>
    
    <item>
      <title>Haskell: Pattern matching data types with named fields</title>
      <link>http://mneedham.github.io/2012/03/31/haskell-pattern-matching-data-types-with-named-fields/</link>
      <pubDate>Sat, 31 Mar 2012 22:49:18 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/31/haskell-pattern-matching-data-types-with-named-fields/</guid>
      <description>One of my favourite things about coding in Haskell is that I often end up pattern matching against data types.
I&amp;rsquo;ve been playing around with modelling cars coming into and out from a car park and changing the state of the car park accordingly.
I started with these data type definitions:
data CarParkState = Available Bool Int Int | AlmostFull Bool Int Int | Full Bool Int deriving (Show) data Action = Entering | Leaving deriving (Show) data Sticker = Handicap | None deriving (Show)  which were used in the following function:</description>
    </item>
    
    <item>
      <title>Haskell: Memoization using the power of laziness</title>
      <link>http://mneedham.github.io/2012/03/24/haskell-memoization-using-the-power-of-laziness/</link>
      <pubDate>Sat, 24 Mar 2012 12:28:03 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/24/haskell-memoization-using-the-power-of-laziness/</guid>
      <description>I&amp;rsquo;ve been trying to solve problem 15 of Project Euler which requires you to find the number of routes that can be taken to navigate from the top corner of a grid down to the bottom right corner.
For example there are six routes across a 2x2 grid:
 My initial solution looked like this:
routes :: (Int, Int) -&amp;gt; Int -&amp;gt; Int routes origin size = inner origin size where inner origin@(x, y) size | x == size &amp;amp;&amp;amp; y == size = 0 | x == size || y == size = 1 | otherwise = inner (x+1, y) size + inner (x, y+1) size  Which can be called like this:</description>
    </item>
    
    <item>
      <title>Haskell: Newbie currying mistake</title>
      <link>http://mneedham.github.io/2012/03/20/haskell-newbie-currying-mistake/</link>
      <pubDate>Tue, 20 Mar 2012 23:55:51 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/20/haskell-newbie-currying-mistake/</guid>
      <description>As I mentioned in my last post I&amp;rsquo;ve spent a bit of this evening writing a merge sort function and one of the mistakes I made a few times was incorrectly passing arguments to the recursive calls of &amp;lsquo;merge&amp;rsquo;.
For example, this is one of the earlier versions of the function:
middle :: [Int] -&amp;gt; Int middle = floor . (\y -&amp;gt; y / 2) . fromIntegral . length	msort :: [Int] -&amp;gt; [Int] msort unsorted = let n = middle unsorted in if n == 0 then unsorted else let (left, right) = splitAt n unsorted in merge (msort left) (msort right) where merge [] right = right merge left [] = left merge left@(x:xs) right@(y:ys) = if x &amp;lt; y then x : merge(xs, right) else y : merge (left, ys)  Which doesn&amp;rsquo;t actually compile:</description>
    </item>
    
    <item>
      <title>Haskell: Chaining functions to find the middle value in a collection</title>
      <link>http://mneedham.github.io/2012/03/20/haskell-chaining-functions-to-find-the-middle-value-in-a-collection/</link>
      <pubDate>Tue, 20 Mar 2012 23:36:03 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/20/haskell-chaining-functions-to-find-the-middle-value-in-a-collection/</guid>
      <description>I&amp;rsquo;ve been playing around with writing merge sort in Haskell and eventually ended up with the following function:
msort :: [Int] -&amp;gt; [Int] msort unsorted = let n = floor (fromIntegral(length unsorted) / 2) in if n == 0 then unsorted else let (left, right) = splitAt n unsorted in merge (msort left) (msort right) where merge [] right = right merge left [] = left merge left@(x:xs) right@(y:ys) = if x &amp;lt; y then x : merge xs right else y : merge left ys  The 3rd line was annoying me as it has way too many brackets on it and I was fairly sure that it should be possible to just combine the functions like I learnt to do in F# a few years ago.</description>
    </item>
    
    <item>
      <title>Functional Programming: One function at a time</title>
      <link>http://mneedham.github.io/2012/03/19/functional-programming-one-function-at-a-time/</link>
      <pubDate>Mon, 19 Mar 2012 23:25:47 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/19/functional-programming-one-function-at-a-time/</guid>
      <description>As I mentioned in an earlier post I got a bit stuck working out all the diagonals in the 20x20 grid of Project Euler problem 11 and my colleague Uday ended up showing me how to do it.
I realised while watching him solve the problem that we&amp;rsquo;d been using quite different approaches to solving the problem and that his way worked way better than mine, at least in this context.</description>
    </item>
    
    <item>
      <title>Functional Programming: Shaping the data to fit a function</title>
      <link>http://mneedham.github.io/2012/03/13/functional-programming-shaping-the-data-to-fit-a-function/</link>
      <pubDate>Tue, 13 Mar 2012 22:55:10 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/13/functional-programming-shaping-the-data-to-fit-a-function/</guid>
      <description>As I mentioned in my last post I&amp;rsquo;ve been working on Project Euler problem 11 and one thing I noticed was that I was shaping the data around a windowed function since it seemed to fit the problem quite well.
Problem 11 is defined like so:
 In the 20x20 grid below, four numbers along a diagonal line have been marked in red. The product of these numbers is 26 63 78 14 = 1788696.</description>
    </item>
    
    <item>
      <title>Haskell: Couldn&#39;t match expected type `Int&#39; with actual type `Integer&#39;</title>
      <link>http://mneedham.github.io/2012/03/13/haskell-couldnt-match-expected-type-int-with-actual-type-integer/</link>
      <pubDate>Tue, 13 Mar 2012 19:42:42 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/03/13/haskell-couldnt-match-expected-type-int-with-actual-type-integer/</guid>
      <description>One of the most frequent compilation error messages that I&amp;rsquo;ve been getting while working through the Project Euler problems in Haskell is the following:
Couldn&#39;t match expected type `Int&#39; with actual type `Integer&#39;  In problem 11, for example, I define the grid of numbers like so:
grid = [[08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08], [49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00], [81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65], [52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91], [22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80], [24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50], [32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70], [67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21], [24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72], [21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95], [78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92], [16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57], [86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58], [19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40], [04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66], [88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69], [04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36], [20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16], [20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54], [01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48]]  Which has the following type:</description>
    </item>
    
    <item>
      <title>Haskell: Creating a sliding window over a collection</title>
      <link>http://mneedham.github.io/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/</link>
      <pubDate>Tue, 28 Feb 2012 00:21:59 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/</guid>
      <description>A couple of years ago when I was playing around with F# I came across the Seq.windowed function which allows you to create a sliding window of a specific size over a collection.
Taking an example from the F# documentation page:
let seqNumbers = [ 1.0; 1.5; 2.0; 1.5; 1.0; 1.5 ] :&amp;gt; seq&amp;lt;float&amp;gt; let seqWindows = Seq.windowed 3 seqNumbers  We end up with this:
Initial sequence: 1.0 1.5 2.</description>
    </item>
    
    <item>
      <title>Haskell: Getting the nth element in a list</title>
      <link>http://mneedham.github.io/2012/02/28/haskell-getting-the-nth-element-in-a-list/</link>
      <pubDate>Tue, 28 Feb 2012 00:02:21 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/02/28/haskell-getting-the-nth-element-in-a-list/</guid>
      <description>I started trying to solve some of the Project Euler problems as a way to learn a bit of Haskell and problem 7 is defined like so:
 By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10 001st prime number?  I read that the Sieve of Eratosthenes is a useful algorithm for working out all the prime numbers and there&amp;rsquo;s a page on the Literate Programs wiki explaining how to derive them using it.</description>
    </item>
    
    <item>
      <title>Haskell: Viewing the steps of a reduce</title>
      <link>http://mneedham.github.io/2012/02/25/haskell-viewing-the-steps-of-a-reduce/</link>
      <pubDate>Sat, 25 Feb 2012 23:40:07 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2012/02/25/haskell-viewing-the-steps-of-a-reduce/</guid>
      <description>I&amp;rsquo;ve been playing around with Haskell a bit over the last week and in the bit of code I was working on I wanted to fold over a collection but see the state of the fold after each step.
I remembered Don Syme showing me how to do something similar during the F# Exchange last year while we were writing some code to score a tennis game by using Seq.scan.</description>
    </item>
    
    <item>
      <title>Haskell: parse error on input `=&#39;</title>
      <link>http://mneedham.github.io/2010/04/22/haskell-parse-error-on-input/</link>
      <pubDate>Thu, 22 Apr 2010 23:35:27 +0000</pubDate>
      
      <guid>http://mneedham.github.io/2010/04/22/haskell-parse-error-on-input/</guid>
      <description>I&amp;rsquo;ve been trying to follow the &amp;lsquo;Monads for Java/C++ programmers&amp;rsquo; post in ghci and getting the following type of error when trying out the code snippets:
Prelude&amp;gt; a = 3 &amp;lt;interactive&amp;gt;:1:2: parse error on input `=&#39;  I figured there must be something wrong with my installation of the compiler since I was copying and pasting the example across and having this problem. Having reinstalled that, however, I still had the same problem.</description>
    </item>
    
  </channel>
</rss>