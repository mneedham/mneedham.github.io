<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kruskal on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/kruskal/</link>
    <description>Recent content in kruskal on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 23 Dec 2012 21:43:42 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/kruskal/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Kruskal&#39;s Algorithm using union find in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 21:43:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</guid>
      <description>class UnionFind def initialize(n) @leaders = 1.upto(n).inject([]) { |leaders, i| leaders[i] = i; leaders } end def connected?(id1,id2) @leaders[id1] == @leaders[id2] end def union(id1,id2) leader_1, leader_2 = @leaders[id1], @leaders[id2] @leaders.map! {|i| (i == leader_1) ? leader_2 : i } end end &amp;gt; uf = UnionFind.new 5 =&amp;gt; #&amp;lt;UnionFind:0x45e5a9b3 @leaders=[nil, 1, 2, 3, 4, 5]&amp;gt; &amp;gt; uf.connected?(1,2) =&amp;gt; false &amp;gt; uf.union(1,2) =&amp;gt; [nil, 2, 2, 3, 4, 5] &amp;gt; uf.union(2,3) =&amp;gt; [nil, 3, 3, 3, 4, 5] set = UnionFind.</description>
    </item>
    
    <item>
      <title>Kruskal&#39;s Algorithm in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 14:18:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-in-ruby/</guid>
      <description>@minimum_spanning_tree = [] edges = file.drop(1). map { |x| x.gsub(/\n/, &amp;#34;&amp;#34;).split(&amp;#34; &amp;#34;).map(&amp;amp;:to_i) }. map { |one, two, weight| { :from =&amp;gt; one, :to =&amp;gt; two, :weight =&amp;gt; weight}}. sort_by { |x| x[:weight]} edges.each do |edge| @minimum_spanning_tree &amp;lt;&amp;lt; edge unless has_cycles edge end def has_cycles(edge) node_one, node_two = edge[:from], edge[:to] @minimum_spanning_tree.each { |x| x[:explored] = false } cycle_between(node_one, node_two, @minimum_spanning_tree.dup) end def cycle_between(one, two, edges) adjacent_edges = edges.select { |edge| edge[:to] == one || edge[:from] == one} return false if adjacent_edges.</description>
    </item>
    
  </channel>
</rss>