<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ranking-systems on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/ranking-systems/</link>
    <description>Recent content in ranking-systems on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Sep 2013 20:26:35 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/ranking-systems/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Elo Rating System: Ranking Champions League teams using Clojure Part 2</title>
      <link>https://markhneedham.com/blog/2013/09/30/elo-rating-system-ranking-champions-league-teams-using-clojure-part-2/</link>
      <pubDate>Mon, 30 Sep 2013 20:26:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/30/elo-rating-system-ranking-champions-league-teams-using-clojure-part-2/</guid>
      <description>(ns ranking-algorithms.uefa (:require [clj-time.format :as f]) (:require [clojure.data.json :as json])) (defn as-date [date-field] (f/parse (f/formatter &amp;#34;dd MMM YYYY&amp;#34;) date-field )) (defn date-aware-value-reader [key value] (if (= key :date) (as-date value) value)) (defn read-from-file [file] (json/read-str (slurp file) :value-fn date-aware-value-reader :key-fn keyword)) &amp;gt; (def the-matches (read-from-file &amp;#34;data/cl-matches-2013.json&amp;#34;)) #&amp;#39;ranking-algorithms.uefa/the-matches &amp;gt; (count the-matches) 213 (comment &amp;#34;other functions excluded for brevity&amp;#34;) (defn format-for-printing [all-matches idx [team ranking &amp;amp; [rd]]] (let [team-matches (show-matches team all-matches)] (merge {:rank (inc idx) :team team :ranking ranking :rd rd :round (performance team-matches)} (match-record team-matches)))) (defn print-top-teams ([number all-matches] (print-top-teams number all-matches {})) ([number all-matches base-rankings] (clojure.</description>
    </item>
    
    <item>
      <title>Elo Rating System: Ranking Champions League teams using Clojure</title>
      <link>https://markhneedham.com/blog/2013/08/31/elo-rating-system-ranking-champions-league-teams-using-clojure/</link>
      <pubDate>Sat, 31 Aug 2013 13:01:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/31/elo-rating-system-ranking-champions-league-teams-using-clojure/</guid>
      <description>(defn ranking-after-win [{ ranking :ranking opponent-ranking :opponent-ranking importance :importance}] (+ ranking (* importance (- 1 (expected ranking opponent-ranking) )))) (defn ranking-after-loss [{ ranking :ranking opponent-ranking :opponent-ranking importance :importance}] (+ ranking (* importance (- 0 (expected ranking opponent-ranking) )))) (defn expected [my-ranking opponent-ranking] (/ 1.0 (+ 1 (math/expt 10 (/ (- opponent-ranking my-ranking) 400))))) &amp;gt; (ranking-after-win { :ranking 1200 :opponent-ranking 1500 :importance 32 }) 1227.1686541692377 &amp;gt; (expected 1200 1500) 0.15097955721132328 (defn top-teams [number matches] (let [teams-with-rankings (apply array-map (mapcat (fn [x] [x {:points 1200}]) (extract-teams matches)))] (take number (sort-by (fn [x] (:points (val x))) &amp;gt; (seq (reduce process-match teams-with-rankings matches)))))) (defn process-match [ts match] (let [{:keys [home away home_score away_score]} match] (cond (&amp;gt; home_score away_score) (-&amp;gt; ts (update-in [home :points] #(ranking-after-win {:ranking % :opponent-ranking (:points (get ts away)) :importance 32})) (update-in [away :points] #(ranking-after-loss {:ranking % :opponent-ranking (:points (get ts home)) :importance 32}))) (&amp;gt; away_score home_score) (-&amp;gt; ts (update-in [home :points] #(ranking-after-loss {:ranking % :opponent-ranking (:points (get ts away)) :importance 32})) (update-in [away :points] #(ranking-after-win {:ranking % :opponent-ranking (:points (get ts home)) :importance 32}))) (= home_score away_score) ts))) &amp;gt; (take 5 all-matches) ({:home &amp;#34;Tampere&amp;#34;, :away &amp;#34;Pyunik Erewan&amp;#34;, :home_score 0, :away_score 4} {:home &amp;#34;Pyunik Erewan&amp;#34;, :away &amp;#34;Tampere&amp;#34;, :home_score 2, :away_score 0} {:home &amp;#34;Skonto Riga&amp;#34;, :away &amp;#34;Barry Town&amp;#34;, :home_score 5, :away_score 0} {:home &amp;#34;Barry Town&amp;#34;, :away &amp;#34;Skonto Riga&amp;#34;, :home_score 0, :away_score 1} {:home &amp;#34;Portadown&amp;#34;, :away &amp;#34;Belshina Bobruisk&amp;#34;, :home_score 0, :away_score 0}) &amp;gt; (extract-teams (take 5 all-matches)) #{&amp;#34;Portadown&amp;#34; &amp;#34;Tampere&amp;#34; &amp;#34;Pyunik Erewan&amp;#34; &amp;#34;Barry Town&amp;#34; &amp;#34;Skonto Riga&amp;#34;} &amp;gt; (mapcat (fn [x] [x {:points 1200}]) (extract-teams (take 5 all-matches))) (&amp;#34;Portadown&amp;#34; {:points 1200} &amp;#34;Tampere&amp;#34; {:points 1200} &amp;#34;Pyunik Erewan&amp;#34; {:points 1200} &amp;#34;Barry Town&amp;#34; {:points 1200} &amp;#34;Skonto Riga&amp;#34; {:points 1200}) &amp;gt; (apply array-map (mapcat (fn [x] [x {:points 1200}]) (extract-teams (take 5 all-matches)))) {&amp;#34;Portadown&amp;#34; {:points 1200}, &amp;#34;Tampere&amp;#34; {:points 1200}, &amp;#34;Pyunik Erewan&amp;#34; {:points 1200}, &amp;#34;Barry Town&amp;#34; {:points 1200}, &amp;#34;Skonto Riga&amp;#34; {:points 1200}} &amp;gt; (top-teams 10 all-matches) ([&amp;#34;CF Barcelona&amp;#34; {:points 1343.</description>
    </item>
    
    <item>
      <title>Ranking Systems: What I&#39;ve learnt so far</title>
      <link>https://markhneedham.com/blog/2013/08/24/ranking-systems-what-ive-learnt-so-far/</link>
      <pubDate>Sat, 24 Aug 2013 11:05:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/24/ranking-systems-what-ive-learnt-so-far/</guid>
      <description>Players start out with an average rating which then increases/decreases based on games they take part in. If they beat someone much more highly ranked then they&amp;rsquo;d gain a lot of points whereas losing to someone similarly ranked wouldn&amp;rsquo;t affect their ranking too much.
I came across a version used to rank country football teams. and the algorithm is quite well described in Christopher Allen&amp;rsquo;s article on competitive ranking systems.This algorithm therefore introduces the concept of a ratings deviation (RD) to measure uncertainty in a rating.</description>
    </item>
    
  </channel>
</rss>