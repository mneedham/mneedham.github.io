<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algo-class on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/algo-class/</link>
    <description>Recent content in algo-class on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Dec 2012 16:31:05 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/algo-class/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Prim&#39;s algorithm using a heap/priority queue in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 16:31:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</guid>
      <description>MAX_VALUE = (2**(0.size * 8 -2) -1) adjacency_matrix = create_adjacency_matrix @nodes_spanned_so_far, spanning_tree_cost = [1], 0 heap = PriorityQueue.new nodes_left_to_cover.each do |node| cheapest_nodes = get_edges(adjacency_matrix, node-1). select { |_, other_node_index| @nodes_spanned_so_far.include?(other_node_index + 1) } || [] cheapest = cheapest_nodes.inject([]) do |all_edges, (weight, index)| all_edges &amp;lt;&amp;lt; { :start =&amp;gt; node, :end =&amp;gt; index + 1, :weight =&amp;gt; weight } all_edges end.sort { |x,y| x[:weight] y[:weight] }.first weight = !cheapest.nil? ? cheapest[:weight]: MAX_VALUE heap[node] = weight end while !</description>
    </item>
    
    <item>
      <title>Algo Class: Start simple and build up</title>
      <link>https://markhneedham.com/blog/2012/04/24/algo-class-start-simple-and-build-up/</link>
      <pubDate>Tue, 24 Apr 2012 07:17:24 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/24/algo-class-start-simple-and-build-up/</guid>
      <description>Over the last six weeks I&amp;rsquo;ve been working through Stanford&amp;rsquo;s Design and Analysis of Algorithms Iclass and each week there&amp;rsquo;s been a programming assignment on a specific algorithm for which a huge data set is provided.
For the first couple of assignments I tried writing the code for the algorithm and then running it directly against the provided data set.
As you might imagine it never worked first time and this approach led to me becoming very frustrated because there&amp;rsquo;s no way of telling what went wrong.</description>
    </item>
    
    <item>
      <title>Scala: Counting number of inversions (via merge sort) for an unsorted collection</title>
      <link>https://markhneedham.com/blog/2012/03/20/scala-counting-number-of-inversions-via-merge-sort-for-an-unsorted-collection/</link>
      <pubDate>Tue, 20 Mar 2012 06:53:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/20/scala-counting-number-of-inversions-via-merge-sort-for-an-unsorted-collection/</guid>
      <description>The first programming questions of algo-classrequires you to calculate the number of inversions it would take using merge sort to sort a collection in ascending order.
I found quite a nice explanation here too:
e.g.
2 4 1 3 5
1 2 3 4 5
The sequence 2, 4, 1, 3, 5 has three inversions (2,1), (4,1), (4,3).
The simple/naive way of solving this problem is to iterate through the collection in two loops and compare each value and its current index with the others, looking for ones which are not in the right order.</description>
    </item>
    
  </channel>
</rss>