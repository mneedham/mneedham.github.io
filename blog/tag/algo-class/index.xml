<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algo Class on Mark Needham</title>
    <link>https://mneedham.github.io/blog/tag/algo-class/</link>
    <description>Recent content in Algo Class on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 15 Dec 2012 16:31:05 +0000</lastBuildDate>
    
	<atom:link href="https://mneedham.github.io/blog/tag/algo-class/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Prim&#39;s algorithm using a heap/priority queue in Ruby</title>
      <link>https://mneedham.github.io/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 16:31:05 +0000</pubDate>
      
      <guid>https://mneedham.github.io/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</guid>
      <description>I recently wrote a blog post describing my implementation of Prim&#39;s Algorithm for the Algorithms 2 class and while it comes up with the right answer for the supplied data set it takes almost 30 seconds to do so!
In one of the lectures Tim Roughgarden points out that we&#39;re doing the same calculations multiple times to work out the next smallest edge to include in our minimal spanning tree and could use a heap to speed things up.</description>
    </item>
    
    <item>
      <title>Algo Class: Start simple and build up</title>
      <link>https://mneedham.github.io/blog/2012/04/24/algo-class-start-simple-and-build-up/</link>
      <pubDate>Tue, 24 Apr 2012 07:17:24 +0000</pubDate>
      
      <guid>https://mneedham.github.io/blog/2012/04/24/algo-class-start-simple-and-build-up/</guid>
      <description>Over the last six weeks I&amp;rsquo;ve been working through Stanford&amp;rsquo;s Design and Analysis of Algorithms I class and each week there&amp;rsquo;s been a programming assignment on a specific algorithm for which a huge data set is provided.
For the first couple of assignments I tried writing the code for the algorithm and then running it directly against the provided data set.
As you might imagine it never worked first time and this approach led to me becoming very frustrated because there&amp;rsquo;s no way of telling what went wrong.</description>
    </item>
    
    <item>
      <title>Scala: Counting number of inversions (via merge sort) for an unsorted collection</title>
      <link>https://mneedham.github.io/blog/2012/03/20/scala-counting-number-of-inversions-via-merge-sort-for-an-unsorted-collection/</link>
      <pubDate>Tue, 20 Mar 2012 06:53:18 +0000</pubDate>
      
      <guid>https://mneedham.github.io/blog/2012/03/20/scala-counting-number-of-inversions-via-merge-sort-for-an-unsorted-collection/</guid>
      <description>The first programming questions of algo-class requires you to calculate the number of inversions it would take using merge sort to sort a collection in ascending order.
I found quite a nice explanation here too:
 Finding &#34;similarity&#34; between two rankings. Given a sequence of n numbers 1..n (assume all numbers are distinct). Define a measure that tells us how far this list is from being in ascending order. The value should be 0 if a_1 The simple/naive way of solving this problem is to iterate through the collection in two loops and compare each value and its current index with the others, looking for ones which are not in the right order.</description>
    </item>
    
  </channel>
</rss>