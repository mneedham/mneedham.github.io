<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/algorithms/</link>
    <description>Recent content in algorithms on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Aug 2013 20:00:45 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>9 algorithms that changed the future - John MacCormick: Book Review</title>
      <link>https://markhneedham.com/blog/2013/08/13/9-algorithms-that-changed-the-future-john-maccormick-book-review/</link>
      <pubDate>Tue, 13 Aug 2013 20:00:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/13/9-algorithms-that-changed-the-future-john-maccormick-book-review/</guid>
      <description>I didn&amp;rsquo;t realise that Sergey Brin and Larry Page had published a paper back in 1998 titled &amp;lsquo;The Anatomy of a Large-Scale Hypertextual Web Search Engine&amp;rsquo; which explains the initial PageRank algorithm in more detail.</description>
    </item>
    
    <item>
      <title>Bellman-Ford algorithm in Python using vectorisation/numpy</title>
      <link>https://markhneedham.com/blog/2013/01/20/bellman-ford-algorithm-in-python-using-vectorisationnumpy/</link>
      <pubDate>Sun, 20 Jan 2013 19:14:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/20/bellman-ford-algorithm-in-python-using-vectorisationnumpy/</guid>
      <description>for i in range(1, vertices): for v in range(0, vertices): previous_cache = cache least_adjacent_cost = calculate_least_adjacent_cost(adjacency_list, i, v, previous_cache) cache[v] = min(previous_cache[v], least_adjacent_cost) # detecting negative cycles for v in range(0, vertices): previous_cache = copy.deepcopy(cache) least_adjacent_cost = calculate_least_adjacent_cost(adjacency_list, i, v, previous_cache) cache[v] = min(previous_cache[v], least_adjacent_cost) if(not cache == previous_cache): raise Exception(&amp;#34;negative cycle detected&amp;#34;) shortest_path = min(cache) # We want to get to this point previous_cache = cache[:] # here we copy the contents of cache into previous_cache cache = minimum(previous_cache, new_shortest_paths) 1 2 3 4 5 6 # these are the previous shortest paths for vertex 0,1â€¦,n inf inf 4 inf inf inf # edges for vertex 0 -2 inf inf inf inf inf # edges for vertex 1 inf -1 inf inf inf inf # and so on.</description>
    </item>
    
    <item>
      <title>Bellman-Ford algorithm in Python</title>
      <link>https://markhneedham.com/blog/2013/01/18/bellman-ford-algorithm-in-python/</link>
      <pubDate>Fri, 18 Jan 2013 00:40:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/18/bellman-ford-algorithm-in-python/</guid>
      <description>import os file = open(os.path.dirname(os.path.realpath(__file__)) + &amp;#34;/g_small.txt&amp;#34;) vertices, edges = map(lambda x: int(x), file.readline().replace(&amp;#34;\n&amp;#34;, &amp;#34;&amp;#34;).split(&amp;#34; &amp;#34;)) adjacency_list = [[] for k in xrange(vertices)] for line in file.readlines(): tail, head, weight = line.split(&amp;#34; &amp;#34;) adjacency_list[int(head)-1].append({&amp;#34;from&amp;#34; : int(tail), &amp;#34;weight&amp;#34; : int(weight)}) s=0 cache = [[0 for k in xrange(vertices+1)] for j in xrange(vertices+1)] cache[0][s] = 0 for v in range(0, vertices): if v != s: cache[0][v] = float(&amp;#34;inf&amp;#34;) for i in range(1, vertices): for v in range(0, vertices): least_adjacent_cost = calculate_least_adjacent_cost(adjacency_list, i, v, cache[i-1]) cache[i][v] = min(cache[i-1][v], least_adjacent_cost) # detecting negative cycles for v in range(0, vertices): least_adjacent_cost = calculate_least_adjacent_cost(adjacency_list, i, v, cache[vertices-1]) cache[vertices][v] = min(cache[vertices-1][v], least_adjacent_cost) if(not cache[vertices] == cache[vertices-1]): raise Exception(&amp;#34;negative cycle detected&amp;#34;) shortest_path = min(cache[vertices-1]) print(&amp;#34;Shortest Path: &amp;#34; + str(shortest_path)) def calculate_least_adjacent_cost(adjacency_list, i, v, cache): adjacent_nodes = adjacency_list[v] least_adjacent_cost = float(&amp;#34;inf&amp;#34;) for node in adjacent_nodes: adjacent_cost = cache[node[&amp;#34;from&amp;#34;]-1] + node[&amp;#34;weight&amp;#34;] if adjacent_cost &amp;lt; least_adjacent_cost: least_adjacent_cost = adjacent_cost return least_adjacent_cost s=0 cache = [[] for j in xrange(vertices+1)] cache[s] = 0 for v in range(0, vertices): if v !</description>
    </item>
    
    <item>
      <title>Kruskal&#39;s Algorithm using union find in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 21:43:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-using-union-find-in-ruby/</guid>
      <description>class UnionFind def initialize(n) @leaders = 1.upto(n).inject([]) { |leaders, i| leaders[i] = i; leaders } end def connected?(id1,id2) @leaders[id1] == @leaders[id2] end def union(id1,id2) leader_1, leader_2 = @leaders[id1], @leaders[id2] @leaders.map! {|i| (i == leader_1) ? leader_2 : i } end end &amp;gt; uf = UnionFind.new 5 =&amp;gt; #&amp;lt;UnionFind:0x45e5a9b3 @leaders=[nil, 1, 2, 3, 4, 5]&amp;gt; &amp;gt; uf.connected?(1,2) =&amp;gt; false &amp;gt; uf.union(1,2) =&amp;gt; [nil, 2, 2, 3, 4, 5] &amp;gt; uf.union(2,3) =&amp;gt; [nil, 3, 3, 3, 4, 5] set = UnionFind.</description>
    </item>
    
    <item>
      <title>Kruskal&#39;s Algorithm in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-in-ruby/</link>
      <pubDate>Sun, 23 Dec 2012 14:18:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/23/kruskals-algorithm-in-ruby/</guid>
      <description>@minimum_spanning_tree = [] edges = file.drop(1). map { |x| x.gsub(/\n/, &amp;#34;&amp;#34;).split(&amp;#34; &amp;#34;).map(&amp;amp;:to_i) }. map { |one, two, weight| { :from =&amp;gt; one, :to =&amp;gt; two, :weight =&amp;gt; weight}}. sort_by { |x| x[:weight]} edges.each do |edge| @minimum_spanning_tree &amp;lt;&amp;lt; edge unless has_cycles edge end def has_cycles(edge) node_one, node_two = edge[:from], edge[:to] @minimum_spanning_tree.each { |x| x[:explored] = false } cycle_between(node_one, node_two, @minimum_spanning_tree.dup) end def cycle_between(one, two, edges) adjacent_edges = edges.select { |edge| edge[:to] == one || edge[:from] == one} return false if adjacent_edges.</description>
    </item>
    
    <item>
      <title>Prim&#39;s algorithm using a heap/priority queue in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 16:31:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/15/prims-algorithm-using-a-heappriority-queue-in-ruby/</guid>
      <description>MAX_VALUE = (2**(0.size * 8 -2) -1) adjacency_matrix = create_adjacency_matrix @nodes_spanned_so_far, spanning_tree_cost = [1], 0 heap = PriorityQueue.new nodes_left_to_cover.each do |node| cheapest_nodes = get_edges(adjacency_matrix, node-1). select { |_, other_node_index| @nodes_spanned_so_far.include?(other_node_index + 1) } || [] cheapest = cheapest_nodes.inject([]) do |all_edges, (weight, index)| all_edges &amp;lt;&amp;lt; { :start =&amp;gt; node, :end =&amp;gt; index + 1, :weight =&amp;gt; weight } all_edges end.sort { |x,y| x[:weight] y[:weight] }.first weight = !cheapest.nil? ? cheapest[:weight]: MAX_VALUE heap[node] = weight end while !</description>
    </item>
    
    <item>
      <title>Prim&#39;s Algorithm in Ruby</title>
      <link>https://markhneedham.com/blog/2012/12/15/prims-algorithm-in-ruby/</link>
      <pubDate>Sat, 15 Dec 2012 02:51:14 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/15/prims-algorithm-in-ruby/</guid>
      <description>adjacency_matrix = create_adjacency_matrix first_edge = select_first_edge(adjacency_matrix) @nodes_spanned_so_far, @edges = [first_edge[:start], first_edge[:end]], [first_edge] while !nodes_left_to_cover.empty? cheapest_edge = find_cheapest_edge(adjacency_matrix, @nodes_spanned_so_far, number_of_nodes) @edges &amp;lt;&amp;lt; cheapest_edge @nodes_spanned_so_far &amp;lt;&amp;lt; cheapest_edge[:start] end def find_cheapest_edge(adjacency_matrix, nodes_spanned_so_far, number_of_nodes) available_nodes = (0..number_of_nodes-1).to_a.reject { |node_index| nodes_spanned_so_far.include?(node_index + 1) } cheapest_edges = available_nodes.inject([]) do |acc, node_index| get_edges(adjacency_matrix, node_index).select { |_, other_node_index| nodes_spanned_so_far.include?(other_node_index + 1) }.each do |weight, other_node_index| acc &amp;lt;&amp;lt; { :start =&amp;gt; node_index + 1, :end =&amp;gt; other_node_index + 1, :weight =&amp;gt; weight } end acc end cheapest_edges.</description>
    </item>
    
    <item>
      <title>Algorithms: Rabin Karp in Haskell</title>
      <link>https://markhneedham.com/blog/2012/04/25/algorithms-rabin-karp-in-haskell/</link>
      <pubDate>Wed, 25 Apr 2012 21:28:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/25/algorithms-rabin-karp-in-haskell/</guid>
      <description>I recently came across a blog post describing the Rabin Karp algorithm- an algorithm that uses hashing to find a pattern string in some text - and thought it would be interesting to try and write a version of it in Haskell.
This algorithm is typically used when we want to search for multiple pattern strings in a text e.g. when detecting plagiarism or a primitive way of detecting code duplication but my initial version only lets your search for one pattern.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell - Abstracting the common</title>
      <link>https://markhneedham.com/blog/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</link>
      <pubDate>Tue, 17 Apr 2012 07:22:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</guid>
      <description>In the comments of my blog post describing the flood fill algorithm in HaskellDavid Turner pointed out that the way I was passing the grid around was quite error prone.
floodFill :: Array (Int, Int) Colour -&amp;gt; (Int, Int) -&amp;gt; Colour -&amp;gt; Colour -&amp;gt; Array (Int, Int) Colour floodFill grid point@(x, y) target replacement = if((not $ inBounds grid point) || grid ! (x,y) /= target) then grid else gridNorth where grid&amp;#39; = replace grid point replacement gridEast = floodFill grid&amp;#39; (x+1, y) target replacement gridWest = floodFill gridEast (x-1, y) target replacement gridSouth = floodFill gridWest (x, y+1) target replacement gridNorth = floodFill gridSouth (x, y-1) target replacement I actually did pass the wrong grid variable around while I was writing it and ended up quite confused as to why it wasn&amp;rsquo;t working as I expected.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell</title>
      <link>https://markhneedham.com/blog/2012/04/07/algorithms-flood-fill-in-haskell/</link>
      <pubDate>Sat, 07 Apr 2012 00:25:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/07/algorithms-flood-fill-in-haskell/</guid>
      <description>Flood fillis an algorithm used to work out which nodes are connected to a certain node in a multi dimensional array. In this case we&amp;rsquo;ll use a two dimensional array.
The idea is that we decide that we want to change the colour of one of the cells in the array and have its immediate neighbours who share its initial colour have their colour changed too i.e. the colour floods its way through the grid.</description>
    </item>
    
  </channel>
</rss>