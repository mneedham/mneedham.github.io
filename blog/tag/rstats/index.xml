<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rstats on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/rstats/</link>
    <description>Recent content in rstats on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 02 Oct 2015 18:42:47 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/rstats/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>R: data.table - Finding the maximum row</title>
      <link>https://markhneedham.com/blog/2015/10/02/r-data-table-finding-the-maximum-row/</link>
      <pubDate>Fri, 02 Oct 2015 18:42:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/10/02/r-data-table-finding-the-maximum-row/</guid>
      <description>&amp;gt; blogDT = data.table(name = c(&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;), price = c(10000, 12500, 18000, 245000, 512000, 1000000), date = c(&amp;#34;Day 1&amp;#34;, &amp;#34;Day 7&amp;#34;, &amp;#34;Day 10&amp;#34;, &amp;#34;Day 3&amp;#34;, &amp;#34;Day 5&amp;#34;, &amp;#34;Day 12&amp;#34;)) &amp;gt; blogDT[, lag.price := c(NA, price[-.N]), by = name] &amp;gt; blogDT[, diff := price - lag.price] &amp;gt; blogDT name price date lag.price diff 1: Property 1 10000 Day 1 NA NA 2: Property 1 12500 Day 7 10000 2500 3: Property 1 18000 Day 10 12500 5500 4: Property 2 245000 Day 3 NA NA 5: Property 2 512000 Day 5 245000 267000 6: Property 2 1000000 Day 12 512000 488000 &amp;gt; blogDT[!</description>
    </item>
    
    <item>
      <title>R: data.table - Comparing adjacent rows</title>
      <link>https://markhneedham.com/blog/2015/09/27/r-data-table-comparing-adjacent-rows/</link>
      <pubDate>Sun, 27 Sep 2015 22:02:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/09/27/r-data-table-comparing-adjacent-rows/</guid>
      <description>&amp;gt; blogDT = data.table(name = c(&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;), price = c(10000, 12500, 18000, 245000, 512000, 1000000)) &amp;gt; blogDT name price 1: Property 1 10000 2: Property 1 12500 3: Property 1 18000 4: Property 2 245000 5: Property 2 512000 6: Property 2 1000000 &amp;gt; blogDT[, lag.price := c(NA, price[-.N]), by = name] &amp;gt; blogDT name price lag.price 1: Property 1 10000 NA 2: Property 1 12500 10000 3: Property 1 18000 12500 4: Property 2 245000 NA 5: Property 2 512000 245000 6: Property 2 1000000 512000 &amp;gt; blogDT[, diff := price - lag.</description>
    </item>
    
    <item>
      <title>R: Date for given week/year</title>
      <link>https://markhneedham.com/blog/2015/07/10/r-date-for-given-weekyear/</link>
      <pubDate>Fri, 10 Jul 2015 22:01:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/10/r-date-for-given-weekyear/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; df = read.csv(&amp;#34;posts.csv&amp;#34;) &amp;gt; df$date = ymd_hms(df$date) &amp;gt; df %&amp;gt;% sample_n(10) title date 538 Nygard Big Data Model: The Investigation Stage 2012-10-10 00:00:36 341 The read-only database 2011-08-29 23:32:26 1112 CSS in Internet Explorer - Some lessons learned 2008-10-31 15:24:51 143 Coding: Mutating parameters 2010-08-26 07:47:23 433 Scala: Counting number of inversions (via merge sort) for an unsorted collection 2012-03-20 06:53:18 618 neo4j/cypher: SQL style GROUP BY functionality 2013-02-17 21:05:27 1111 Testing Hibernate mappings: Setting up test data 2008-10-30 13:24:14 462 neo4j: What question do you want to answer?</description>
    </item>
    
    <item>
      <title>R: dplyr - Error: cannot modify grouping variable</title>
      <link>https://markhneedham.com/blog/2015/07/09/r-dplyr-error-cannot-modify-grouping-variable/</link>
      <pubDate>Thu, 09 Jul 2015 05:55:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/09/r-dplyr-error-cannot-modify-grouping-variable/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; df %&amp;gt;% sample_n(5) title date 1148 Taiichi Ohno&amp;#39;s Workplace Management: Book Review 2008-12-08 14:14:48 158 Rails: Faking a delete method with &amp;#39;form_for&amp;#39; 2010-09-20 18:52:15 331 Retrospectives: The 4 L&amp;#39;s Retrospective 2011-07-25 21:00:30 1035 msbuild - Use OutputPath instead of OutDir 2008-08-14 18:54:03 1181 The danger of commenting out code 2009-01-17 06:02:33 &amp;gt; df %&amp;gt;% mutate(day = as.Date(date)) %&amp;gt;% count(day) %&amp;gt;% arrange(desc(n)) Source: local data frame [1,140 x 2] day n 1 2012-12-31 6 2 2014-05-31 6 3 2008-08-08 5 4 2013-01-27 5 5 2009-08-24 4 6 2012-06-24 4 7 2012-09-30 4 8 2012-10-27 4 9 2012-11-24 4 10 2013-02-28 4 &amp;gt; df %&amp;gt;% mutate(day = as.</description>
    </item>
    
    <item>
      <title>R: ggplot geom_density - Error in exists(name, envir = env, mode = mode) : argument &#34;env&#34; is missing, with no default</title>
      <link>https://markhneedham.com/blog/2015/06/03/r-ggplot-geom_density-error-in-existsname-envir-env-mode-mode-argument-env-is-missing-with-no-default/</link>
      <pubDate>Wed, 03 Jun 2015 05:52:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/03/r-ggplot-geom_density-error-in-existsname-envir-env-mode-mode-argument-env-is-missing-with-no-default/</guid>
      <description>library(dplyr) df2011 = read.csv(&amp;#34;~/projects/rLearning/showcases.2011.csv&amp;#34;, na.strings = c(&amp;#34;&amp;#34;, &amp;#34;NA&amp;#34;)) df2011 = df2011 %&amp;gt;% na.omit() &amp;gt; df2011 %&amp;gt;% head() X Sep..19 Sep..20 Sep..21 Sep..22 Sep..23 Sep..26 Sep..27 Sep..28 Sep..29 Sep..30 Oct..3 3 Showcase 1 50969 21901 32815 44432 24273 30554 20963 28941 25851 28800 37703 4 Showcase 2 45429 34061 53186 31428 22320 24337 41373 45437 41125 36319 38752 6 Bid 1 42000 14000 32000 27000 18750 27222 25000 35000 22500 21300 21567 7 Bid 2 34000 59900 45000 38000 23000 18525 32000 45000 32000 27500 23800 9 Difference 1 8969 7901 815 17432 5523 3332 -4037 -6059 3351 7500 16136 10 Difference 2 11429 -25839 8186 -6572 -680 5812 9373 437 9125 8819 14952 .</description>
    </item>
    
    <item>
      <title>R: Think Bayes Euro Problem</title>
      <link>https://markhneedham.com/blog/2015/05/31/r-think-bayes-euro-problem/</link>
      <pubDate>Sun, 31 May 2015 23:11:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/31/r-think-bayes-euro-problem/</guid>
      <description>When spun on edge 250 times, a Belgian one-euro coin came up heads 140 times and tails 110. ‘It looks very suspicious to me,’ said Barry Blight, a statistics lecturer at the London School of Economics. ‘If the coin were unbiased, the chance of getting a result as extreme as that would be less than 7%.’
But do these data give evidence that the coin is biased rather than fair?</description>
    </item>
    
    <item>
      <title>R: ggplot - Displaying multiple charts with a for loop</title>
      <link>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</link>
      <pubDate>Thu, 14 May 2015 00:17:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</guid>
      <description>library(RNeo4j) graph = startGraph(&amp;#34;http://127.0.0.1:7474/db/data/&amp;#34;) eventId = &amp;#34;220750415&amp;#34; query = &amp;#34;match (g:Group {name: &amp;#39;Neo4j - London User Group&amp;#39;})-[:HOSTED_EVENT]-&amp;gt; (e {id: {id}})&amp;lt;-[:TO]-(rsvp {response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(person) WITH rsvp, person MATCH (person)-[:RSVPD]-&amp;gt;(otherRSVP) WITH person, rsvp, otherRSVP ORDER BY person.id, otherRSVP.time WITH person, rsvp, COLLECT(otherRSVP)[0] AS earliestRSVP return rsvp.time, earliestRSVP.time, person.id&amp;#34; df = cypher(graph, query, id= eventId) &amp;gt; df %&amp;gt;% sample_n(10) rsvp.time earliestRSVP.time person.id 18 1.430819e+12 1.392726e+12 130976662 95 1.430069e+12 1.430069e+12 10286388 79 1.429035e+12 1.429035e+12 38344282 64 1.</description>
    </item>
    
    <item>
      <title>R: Cohort heatmap of Neo4j London meetup</title>
      <link>https://markhneedham.com/blog/2015/05/11/r-cohort-heatmap-of-neo4j-london-meetup/</link>
      <pubDate>Mon, 11 May 2015 23:16:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/11/r-cohort-heatmap-of-neo4j-london-meetup/</guid>
      <description>df = read.csv(&amp;#34;/tmp/df.csv&amp;#34;) &amp;gt; df %&amp;gt;% sample_n(5) rsvp.time person.id time date 255 1.354277e+12 12228948 2012-11-30 12:05:08 2012-11 2475 1.407342e+12 19057581 2014-08-06 16:26:04 2014-08 3988 1.421769e+12 66122172 2015-01-20 15:58:02 2015-01 4411 1.419377e+12 165750262 2014-12-23 23:27:44 2014-12 1010 1.383057e+12 74602292 2013-10-29 14:24:32 2013-10 firstMeetup = df %&amp;gt;% group_by(person.id) %&amp;gt;% summarise(firstEvent = min(time), count = n()) %&amp;gt;% arrange(desc(count)) firstMeetup$date = format(as.Date(firstMeetup$firstEvent), &amp;#34;%Y-%m&amp;#34;) countsForCohort = function(df, firstMeetup, cohort) { members = (firstMeetup %&amp;gt;% filter(date == cohort))$person.</description>
    </item>
    
    <item>
      <title>R: Neo4j London meetup group - How many events do people come to?</title>
      <link>https://markhneedham.com/blog/2015/05/09/r-neo4j-london-meetup-group-how-many-events-do-people-come-to/</link>
      <pubDate>Sat, 09 May 2015 22:33:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/09/r-neo4j-london-meetup-group-how-many-events-do-people-come-to/</guid>
      <description>How often do people come to meetups?
library(RNeo4j) library(dplyr) graph = startGraph(&amp;#34;http://localhost:7474/db/data/&amp;#34;) query = &amp;#34;MATCH (g:Group {name: &amp;#39;Neo4j - London User Group&amp;#39;})-[:HOSTED_EVENT]-&amp;gt;(event)&amp;lt;-[:TO]-({response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(profile)-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g) WHERE (event.time + event.utc_offset) &amp;lt; timestamp() RETURN event.id, event.time + event.utc_offset AS eventTime, profile.id, membership.joined&amp;#34; df = cypher(graph, query) &amp;gt; df %&amp;gt;% head() event.id eventTime profile.id membership.joined 1 20616111 1.309372e+12 6436797 1.307285e+12 2 20616111 1.309372e+12 12964956 1.307275e+12 3 20616111 1.309372e+12 14533478 1.307290e+12 4 20616111 1.309372e+12 10793775 1.307705e+12 5 24528711 1.</description>
    </item>
    
    <item>
      <title>R: dplyr - Error in (list: invalid subscript type &#39;double&#39;</title>
      <link>https://markhneedham.com/blog/2015/04/27/r-dplyr-error-in-list-invalid-subscript-type-double/</link>
      <pubDate>Mon, 27 Apr 2015 22:34:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/27/r-dplyr-error-in-list-invalid-subscript-type-double/</guid>
      <description>library(dplyr) df = data.frame(score = c(5,7,8,10,12,20), percentile = c(0.05,0.1,0.15,0.20,0.25,0.5)) &amp;gt; (df %&amp;gt;% filter(percentile &amp;gt; 0.05) %&amp;gt;% slice(1))$score [1] 7 targetPercentiles = c(0.05, 0.2) percentilesDf = data.frame(targetPercentile = targetPercentiles) &amp;gt; percentilesDf %&amp;gt;% group_by(targetPercentile) %&amp;gt;% mutate(x = (df %&amp;gt;% filter(percentile &amp;gt; targetPercentile) %&amp;gt;% slice(1))$score) Error in (list(score = c(5, 7, 8, 10, 12, 20), percentile = c(0.05, 0.1, : invalid subscript type &amp;#39;double&amp;#39; df = data.frame(score = c(5,7,8,10,12,20), percentile = c(0.05,0.1,0.15,0.20,0.25,0.5)) targetPercentiles = c(0.</description>
    </item>
    
    <item>
      <title>R: Creating an object with functions to calculate conditional probability</title>
      <link>https://markhneedham.com/blog/2015/04/12/r-creating-an-object-with-functions-to-calculate-conditional-probability/</link>
      <pubDate>Sun, 12 Apr 2015 07:55:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/12/r-creating-an-object-with-functions-to-calculate-conditional-probability/</guid>
      <description>Now suppose you choose one of the bowls at random and, without looking, select a cookie at random. The cookie is vanilla.
What is the probability that it came from Bowl 1?
pmf = Pmf() pmf.Set(&amp;#39;Bowl 1&amp;#39;, 0.5) pmf.Set(&amp;#39;Bowl 2&amp;#39;, 0.5) pmf.Mult(&amp;#39;Bowl 1&amp;#39;, 0.75) pmf.Mult(&amp;#39;Bowl 2&amp;#39;, 0.5) pmf.Normalize() print pmf.Prob(&amp;#39;Bowl 1&amp;#39;) pBowl1 = 0.5 pBowl2 = 0.5 pVanillaGivenBowl1 = 0.75 pVanillaGivenBowl2 = 0.5 &amp;gt; (pBowl1 * pVanillaGivenBowl1) / ((pBowl1 * pVanillaGivenBowl1) + (PBowl2 * pVanillaGivenBowl2)) 0.</description>
    </item>
    
    <item>
      <title>R: Cohort analysis of Neo4j meetup members</title>
      <link>https://markhneedham.com/blog/2015/02/24/r-cohort-analysis-of-neo4j-meetup-members/</link>
      <pubDate>Tue, 24 Feb 2015 01:19:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/24/r-cohort-analysis-of-neo4j-meetup-members/</guid>
      <description>library(RNeo4j) graph = startGraph(&amp;#34;http://127.0.0.1:7474/db/data/&amp;#34;) query = &amp;#34;MATCH (g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;})-[:HOSTED_EVENT]-&amp;gt;(e), (e)&amp;lt;-[:TO]-(rsvp {response: \&amp;#34;yes\&amp;#34;})&amp;lt;-[:RSVPD]-(person) RETURN rsvp.time, person.id&amp;#34; timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;, tz = &amp;#34;GMT&amp;#34;) df = cypher(graph, query) df$time = timestampToDate(df$rsvp.time) df$date = format(as.Date(df$time), &amp;#34;%Y-%m&amp;#34;) &amp;gt; df %&amp;gt;% head() ## rsvp.time person.id time date ## 612 1.404857e+12 23362191 2014-07-08 22:00:29 2014-07 ## 1765 1.380049e+12 112623332 2013-09-24 18:58:00 2013-09 ## 1248 1.390563e+12 9746061 2014-01-24 11:24:35 2014-01 ## 1541 1.</description>
    </item>
    
    <item>
      <title>R/dplyr: Extracting data frame column value for filtering with %in%</title>
      <link>https://markhneedham.com/blog/2015/02/22/rdplyr-extracting-data-frame-column-value-for-filtering-with-in/</link>
      <pubDate>Sun, 22 Feb 2015 08:58:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/22/rdplyr-extracting-data-frame-column-value-for-filtering-with-in/</guid>
      <description>library(dplyr) df = data.frame(userId = c(1,2,3,4,5), score = c(2,3,4,5,5)) highScoringPeople = df %&amp;gt;% filter(score &amp;gt; 3) %&amp;gt;% select(userId) &amp;gt; highScoringPeople userId 1 3 2 4 3 5 &amp;gt; df %&amp;gt;% filter(userId %in% highScoringPeople) [1] userId score &amp;lt;0 rows&amp;gt; (or 0-length row.names) &amp;gt; df %&amp;gt;% filter(userId %in% c(3,4,5)) userId score 1 3 4 2 4 5 3 5 5 &amp;gt; str(c(3,4,5)) num [1:3] 3 4 5 &amp;gt; str(highScoringPeople) &amp;#39;data.frame&amp;#39;:	3 obs. of 1 variable: $ userId: num 3 4 5 highScoringPeople = (df %&amp;gt;% filter(score &amp;gt; 3))$userId &amp;gt; str(highScoringPeople) num [1:3] 3 4 5 &amp;gt; df %&amp;gt;% filter(userId %in% highScoringPeople) userId score 1 3 4 2 4 5 3 5 5 highScoringPeople = (df %&amp;gt;% filter(score &amp;gt; 3) %&amp;gt;% select(userId))[[1]] &amp;gt; str(highScoringPeople) num [1:3] 3 4 5 </description>
    </item>
    
    <item>
      <title>R: Weather vs attendance at NoSQL meetups</title>
      <link>https://markhneedham.com/blog/2015/02/11/r-weather-vs-attendance-at-nosql-meetups/</link>
      <pubDate>Wed, 11 Feb 2015 07:09:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/11/r-weather-vs-attendance-at-nosql-meetups/</guid>
      <description>library(weatherData) # London City Airport getDetailedWeatherForYear = function(year) { getWeatherForDate(&amp;#34;LCY&amp;#34;, start_date= paste(sep=&amp;#34;&amp;#34;, year, &amp;#34;-01-01&amp;#34;), end_date = paste(sep=&amp;#34;&amp;#34;, year, &amp;#34;-12-31&amp;#34;), opt_detailed = FALSE, opt_all_columns = TRUE) } df = rbind(getDetailedWeatherForYear(2011), getDetailedWeatherForYear(2012), getDetailedWeatherForYear(2013), getDetailedWeatherForYear(2014), getWeatherForDate(&amp;#34;LCY&amp;#34;, start_date=&amp;#34;2015-01-01&amp;#34;, end_date = &amp;#34;2015-01-25&amp;#34;, opt_detailed = FALSE, opt_all_columns = TRUE)) write.csv(df, &amp;#39;weather/temp_data.csv&amp;#39;, row.names = FALSE) &amp;#34;Date&amp;#34;,&amp;#34;GMT&amp;#34;,&amp;#34;Max_TemperatureC&amp;#34;,&amp;#34;Mean_TemperatureC&amp;#34;,&amp;#34;Min_TemperatureC&amp;#34;,&amp;#34;Dew_PointC&amp;#34;,&amp;#34;MeanDew_PointC&amp;#34;,&amp;#34;Min_DewpointC&amp;#34;,&amp;#34;Max_Humidity&amp;#34;,&amp;#34;Mean_Humidity&amp;#34;,&amp;#34;Min_Humidity&amp;#34;,&amp;#34;Max_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Mean_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Min_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Max_VisibilityKm&amp;#34;,&amp;#34;Mean_VisibilityKm&amp;#34;,&amp;#34;Min_VisibilitykM&amp;#34;,&amp;#34;Max_Wind_SpeedKm_h&amp;#34;,&amp;#34;Mean_Wind_SpeedKm_h&amp;#34;,&amp;#34;Max_Gust_SpeedKm_h&amp;#34;,&amp;#34;Precipitationmm&amp;#34;,&amp;#34;CloudCover&amp;#34;,&amp;#34;Events&amp;#34;,&amp;#34;WindDirDegrees&amp;#34; 2011-01-01,&amp;#34;2011-1-1&amp;#34;,7,6,4,5,3,1,93,85,76,1027,1025,1023,10,9,3,14,10,NA,0,7,&amp;#34;Rain&amp;#34;,312 2011-01-02,&amp;#34;2011-1-2&amp;#34;,4,3,2,1,0,-1,87,81,75,1029,1028,1027,10,10,10,11,8,NA,0,7,&amp;#34;&amp;#34;,321 2011-01-03,&amp;#34;2011-1-3&amp;#34;,4,2,1,0,-2,-5,87,74,56,1028,1024,1019,10,10,10,8,5,NA,0,6,&amp;#34;Rain-Snow&amp;#34;,249 2011-01-04,&amp;#34;2011-1-4&amp;#34;,6,3,1,3,1,-1,93,83,65,1019,1013,1008,10,10,10,21,6,NA,0,5,&amp;#34;Rain&amp;#34;,224 2011-01-05,&amp;#34;2011-1-5&amp;#34;,8,7,5,6,3,0,93,80,61,1008,1000,994,10,9,4,26,16,45,0,4,&amp;#34;Rain&amp;#34;,200 2011-01-06,&amp;#34;2011-1-6&amp;#34;,7,4,3,6,3,1,93,90,87,1002,996,993,10,9,5,13,6,NA,0,5,&amp;#34;Rain&amp;#34;,281 2011-01-07,&amp;#34;2011-1-7&amp;#34;,11,6,2,9,5,2,100,91,82,1003,999,996,10,7,2,24,11,NA,0,5,&amp;#34;Rain-Snow&amp;#34;,124 2011-01-08,&amp;#34;2011-1-8&amp;#34;,11,7,4,8,4,-1,87,77,65,1004,997,987,10,10,5,39,23,50,0,5,&amp;#34;Rain&amp;#34;,230 2011-01-09,&amp;#34;2011-1-9&amp;#34;,7,4,3,1,0,-1,87,74,57,1018,1012,1004,10,10,10,24,16,NA,0,NA,&amp;#34;&amp;#34;,242 weather = read.csv(&amp;#34;weather/temp_data.csv&amp;#34;) weather$Date = as.POSIXct(weather$Date) &amp;gt; weather %&amp;gt;% sample_n(10) %&amp;gt;% select(Date, Min_TemperatureC, Mean_TemperatureC, Max_TemperatureC) Date Min_TemperatureC Mean_TemperatureC Max_TemperatureC 1471 2015-01-10 5 9 14 802 2013-03-12 -2 1 4 1274 2014-06-27 14 18 22 848 2013-04-27 5 8 10 832 2013-04-11 6 8 10 717 2012-12-17 6 7 9 1463 2015-01-02 6 9 13 1090 2013-12-25 4 6 7 560 2012-07-13 15 18 20 1230 2014-05-14 9 14 19 timestampToDate &amp;lt;- function(x) as.</description>
    </item>
    
    <item>
      <title>R: ggplot2 - Each group consist of only one observation. Do you need to adjust the group aesthetic?</title>
      <link>https://markhneedham.com/blog/2015/01/30/r-ggplot2-each-group-consist-of-only-one-observation-do-you-need-to-adjust-the-group-aesthetic/</link>
      <pubDate>Fri, 30 Jan 2015 00:27:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/01/30/r-ggplot2-each-group-consist-of-only-one-observation-do-you-need-to-adjust-the-group-aesthetic/</guid>
      <description>$ cat /tmp/averageTemperatureByMonth.csv &amp;#34;month&amp;#34;,&amp;#34;aveTemperature&amp;#34; &amp;#34;January&amp;#34;,6.02684563758389 &amp;#34;February&amp;#34;,5.89380530973451 &amp;#34;March&amp;#34;,7.54838709677419 &amp;#34;April&amp;#34;,10.875 &amp;#34;May&amp;#34;,13.3064516129032 &amp;#34;June&amp;#34;,15.9666666666667 &amp;#34;July&amp;#34;,18.8387096774194 &amp;#34;August&amp;#34;,18.3709677419355 &amp;#34;September&amp;#34;,16.2583333333333 &amp;#34;October&amp;#34;,13.4596774193548 &amp;#34;November&amp;#34;,9.19166666666667 &amp;#34;December&amp;#34;,7.01612903225806 df = read.csv(&amp;quot;/tmp/averageTemperatureByMonth.csv&amp;quot;) df$month = factor(df$month, month.name) ggplot(aes(x = month, y = aveTemperature), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) geom_path: Each group consist of only one observation. Do you need to adjust the group aesthetic? ggplot(aes(x = as.numeric(month), y = aveTemperature), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) ggplot(aes(x = month, y = aveTemperature, group=1), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) </description>
    </item>
    
    <item>
      <title>R: Vectorising all the things</title>
      <link>https://markhneedham.com/blog/2014/12/22/r-vectorising-all-the-things/</link>
      <pubDate>Mon, 22 Dec 2014 11:46:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/22/r-vectorising-all-the-things/</guid>
      <description>library(dplyr) library(lubridate) library(geosphere) options(&amp;#34;scipen&amp;#34;=100, &amp;#34;digits&amp;#34;=4) times = ymd_hms(&amp;#34;2002-01-01 17:00:00&amp;#34;) + c(0:99) * hours(1) data = data.frame(time = times) &amp;gt; data %&amp;gt;% head() time 1 2002-01-01 17:00:00 2 2002-01-01 18:00:00 3 2002-01-01 19:00:00 4 2002-01-01 20:00:00 5 2002-01-01 21:00:00 6 2002-01-01 22:00:00 distanceFromWeekend = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) timeToBefore = dateToLookup - before timeToAfter = after - dateToLookup if(timeToBefore &amp;lt; 0 || timeToAfter &amp;lt; 0) { 0 } else { if(timeToBefore &amp;lt; timeToAfter) { timeToBefore / dhours(1) } else { timeToAfter / dhours(1) } } } &amp;gt; system.</description>
    </item>
    
    <item>
      <title>R: Time to/from the weekend</title>
      <link>https://markhneedham.com/blog/2014/12/13/r-time-tofrom-the-weekend/</link>
      <pubDate>Sat, 13 Dec 2014 20:38:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/13/r-time-tofrom-the-weekend/</guid>
      <description>&amp;gt; library(lubridate) &amp;gt; floor_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) [1] &amp;#34;2014-12-14 UTC&amp;#34; &amp;gt; ceiling_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) [1] &amp;#34;2014-12-21 UTC&amp;#34; &amp;gt; ceiling_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) - days(1) [1] &amp;#34;2014-12-20 UTC&amp;#34; findClosestWeekendDay = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) if((dateToLookup - before) &amp;lt; (after - dateToLookup)) { before } else { after } } &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-13 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-13 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-14 18:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-15 18:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-17 11:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-17 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-20 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-19 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-20 UTC&amp;#34; distanceFromWeekend = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) timeToBefore = dateToLookup - before timeToAfter = after - dateToLookup if(timeToBefore &amp;lt; 0 || timeToAfter &amp;lt; 0) { 0 } else { if(timeToBefore &amp;lt; timeToAfter) { timeToBefore / dhours(1) } else { timeToAfter / dhours(1) } } } &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-13 13:33:29&amp;#34;)) [1] 0 &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-14 18:33:29&amp;#34;)) [1] 0 &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-15 18:33:29&amp;#34;)) [1] 18.</description>
    </item>
    
    <item>
      <title>R: Numeric representation of date time</title>
      <link>https://markhneedham.com/blog/2014/12/13/r-numeric-representation-of-date-time/</link>
      <pubDate>Sat, 13 Dec 2014 19:58:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/13/r-numeric-representation-of-date-time/</guid>
      <description>&amp;gt; december13 = as.POSIXlt(&amp;#34;2014-12-13 17:30:00&amp;#34;) &amp;gt; as.numeric(december13 - trunc(december13, &amp;#34;day&amp;#34;), units=&amp;#34;hours&amp;#34;) [1] 17.5 &amp;gt; (december13 - floor_date(december13, &amp;#34;day&amp;#34;)) Time difference of 17.5 hours &amp;gt; class((december13 - floor_date(december13, &amp;#34;day&amp;#34;))) [1] &amp;#34;difftime&amp;#34; &amp;gt; diff = (december13 - floor_date(december13, &amp;#34;day&amp;#34;)) &amp;gt; diff / dhours(1) [1] 17.5 &amp;gt; diff / ddays(1) [1] 0.7291667 &amp;gt; diff / dminutes(1) [1] 1050 &amp;gt; ymd_hms(&amp;#34;2014-12-13 17:00:00&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd_hm(&amp;#34;2014-12-13 17:00&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd_h(&amp;#34;2014-12-13 17&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd(&amp;#34;2014-12-13&amp;#34;) [1] &amp;#34;2014-12-13 UTC&amp;#34; &amp;gt; with_tz(ymd(&amp;#34;2014-12-13&amp;#34;), &amp;#34;GMT&amp;#34;) [1] &amp;#34;2014-12-13 GMT&amp;#34; </description>
    </item>
    
    <item>
      <title>R: data.table/dplyr/lubridate - Error in wday(date, label = TRUE, abbr = FALSE) :  unused arguments (label = TRUE, abbr = FALSE)</title>
      <link>https://markhneedham.com/blog/2014/12/11/r-data-tabledplyrlubridate-error-in-wdaydate-label-true-abbr-false-unused-arguments-label-true-abbr-false/</link>
      <pubDate>Thu, 11 Dec 2014 19:03:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/11/r-data-tabledplyrlubridate-error-in-wdaydate-label-true-abbr-false-unused-arguments-label-true-abbr-false/</guid>
      <description>&amp;gt; library(lubridate) &amp;gt; library(dplyr) &amp;gt; dates = data.frame(date = seq( dmy(&amp;#34;01-01-2010&amp;#34;), to=dmy(&amp;#34;01-01-2015&amp;#34;), by=&amp;#34;day&amp;#34; )) &amp;gt; dates = dates %&amp;gt;% filter(wday(date, label = TRUE, abbr = FALSE) %in% c(&amp;#34;Saturday&amp;#34;, &amp;#34;Sunday&amp;#34;)) &amp;gt; dates %&amp;gt;% head() date 1: 2010-01-02 2: 2010-01-03 3: 2010-01-09 4: 2010-01-10 5: 2010-01-16 6: 2010-01-17 &amp;gt; library(data.table) &amp;gt; dates = data.table(date = seq( dmy(&amp;#34;01-01-2010&amp;#34;), to=dmy(&amp;#34;01-01-2015&amp;#34;), by=&amp;#34;day&amp;#34; )) &amp;gt; dates = dates %&amp;gt;% filter(wday(date, label = TRUE, abbr = FALSE) %in% c(&amp;#34;Saturday&amp;#34;, &amp;#34;Sunday&amp;#34;)) Error in wday(date, label = TRUE, abbr = FALSE) : unused arguments (label = TRUE, abbr = FALSE) &amp;gt; dates = data.</description>
    </item>
    
    <item>
      <title>R: Cleaning up and plotting Google Trends data</title>
      <link>https://markhneedham.com/blog/2014/12/09/r-cleaning-up-plotting-google-trends-data/</link>
      <pubDate>Tue, 09 Dec 2014 18:14:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/09/r-cleaning-up-plotting-google-trends-data/</guid>
      <description>While I&amp;rsquo;m writing the scripts, I&amp;rsquo;m often jumping around, selectively executing individual lines or code blocks, running commands to inspect the data in the REPL (read-evaluate-print-loop, where each command is executed as soon as you type enter, in the picture above it&amp;rsquo;s the pane to the right), etc.
But I try to make sure that when I finish up, the script is runnable by itself.
&amp;gt; library(dplyr) &amp;gt; googleTrends = read.</description>
    </item>
    
    <item>
      <title>R: dplyr - mutate with strptime (incompatible size/wrong result size)</title>
      <link>https://markhneedham.com/blog/2014/12/08/r-dplyr-mutate-with-strptime-incompatible-sizewrong-result-size/</link>
      <pubDate>Mon, 08 Dec 2014 19:02:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/08/r-dplyr-mutate-with-strptime-incompatible-sizewrong-result-size/</guid>
      <description>data = data.frame(x = c(&amp;#34;2014-01-01&amp;#34;, &amp;#34;2014-02-01&amp;#34;, &amp;#34;foo&amp;#34;)) &amp;gt; data x 1 2014-01-01 2 2014-02-01 3 foo &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;)) Error: wrong result size (11), expected 3 or 1 &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.character()) x y 1 2014-01-01 2014-01-01 2 2014-02-01 2014-02-01 3 foo &amp;lt;NA&amp;gt; &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.character()) %&amp;gt;% filter(!is.na(y)) x y 1 2014-01-01 2014-01-01 2 2014-02-01 2014-02-01 &amp;gt; data %&amp;gt;% mutate(y = x %&amp;gt;% strptime(&amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.</description>
    </item>
    
    <item>
      <title>R: String to Date or NA</title>
      <link>https://markhneedham.com/blog/2014/12/07/r-string-to-date-or-na/</link>
      <pubDate>Sun, 07 Dec 2014 19:29:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/07/r-string-to-date-or-na/</guid>
      <description>&amp;gt; as.Date(&amp;#34;2014-01-01&amp;#34;) [1] &amp;#34;2014-01-01&amp;#34; &amp;gt; as.Date(&amp;#34;foo&amp;#34;) Error in charToDate(x) : character string is not in a standard unambiguous format &amp;gt; strptime(&amp;#34;2014-01-01&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) [1] &amp;#34;2014-01-01 GMT&amp;#34; &amp;gt; strptime(&amp;#34;foo&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) [1] NA &amp;gt; strptime(&amp;#34;2014-01-01&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% is.na() [1] FALSE &amp;gt; strptime(&amp;#34;foo&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% is.na() [1] TRUE </description>
    </item>
    
    <item>
      <title>R: Applying a function to every row of a data frame</title>
      <link>https://markhneedham.com/blog/2014/12/04/r-applying-a-function-to-every-row-of-a-data-frame/</link>
      <pubDate>Thu, 04 Dec 2014 06:31:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/04/r-applying-a-function-to-every-row-of-a-data-frame/</guid>
      <description>library(dplyr) # https://gist.github.com/mneedham/7e926a213bf76febf5ed venues = read.csv(&amp;#34;/tmp/venues.csv&amp;#34;) venues %&amp;gt;% head() ## venue lat lon ## 1 Skills Matter 51.52482 -0.099109 ## 2 Skinkers 51.50492 -0.083870 ## 3 Theodore Bullfrog 51.50878 -0.123749 ## 4 The Skills Matter eXchange 51.52452 -0.099231 ## 5 The Guardian 51.53373 -0.122340 ## 6 White Bear Yard 51.52227 -0.109804 options(&amp;#34;scipen&amp;#34;=100, &amp;#34;digits&amp;#34;=4) library(geosphere) centre = c(-0.129581, 51.516578) aVenue = venues %&amp;gt;% slice(1) aVenue ## venue lat lon ## 1 Skills Matter 51.</description>
    </item>
    
    <item>
      <title>R: dplyr - Select &#39;random&#39; rows from a data frame</title>
      <link>https://markhneedham.com/blog/2014/11/26/r-dplyr-select-random-rows-from-a-data-frame/</link>
      <pubDate>Wed, 26 Nov 2014 00:01:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/26/r-dplyr-select-random-rows-from-a-data-frame/</guid>
      <description>data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; randomRows = sample(1:length(data[,1]), 10, replace=T) &amp;gt; randomRows [1] 8723 18772 4964 36134 27467 31890 16313 12841 49214 15621 &amp;gt; data %&amp;gt;% slice(randomRows) letter number 1 Z 4 2 F 1 3 Y 6 4 R 6 5 Y 4 6 V 10 7 R 6 8 D 6 9 J 7 10 E 2 pickRandomRows = function(df, numberOfRows = 10) { df %&amp;gt;% slice(runif(numberOfRows,0, length(df[,1]))) } &amp;gt; data %&amp;gt;% pickRandomRows() letter number 1 W 5 2 Y 3 3 E 6 4 Q 8 5 M 9 6 H 9 7 E 10 8 T 2 9 I 5 10 V 4 &amp;gt; data %&amp;gt;% pickRandomRows(7) letter number 1 V 7 2 N 4 3 W 1 4 N 8 5 G 7 6 V 1 7 N 7 &amp;gt; data %&amp;gt;% sample_n(10) letter number 29771 U 1 48666 T 10 30635 A 1 34865 X 7 20140 A 3 41715 T 10 43786 E 10 18284 A 7 21406 S 8 35542 J 8 </description>
    </item>
    
    <item>
      <title>R: ggmap - Overlay shapefile with filled polygon of regions</title>
      <link>https://markhneedham.com/blog/2014/11/17/r-ggmap-overlay-shapefile-with-filled-polygon-of-regions/</link>
      <pubDate>Mon, 17 Nov 2014 00:53:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/17/r-ggmap-overlay-shapefile-with-filled-polygon-of-regions/</guid>
      <description>&amp;gt; library(ggmap) &amp;gt; sfMap = map = get_map(location = &amp;#39;San Francisco&amp;#39;, zoom = 12) &amp;gt; library(rgdal) &amp;gt; library(ggplot2) &amp;gt; sfn = readOGR(&amp;#34;.&amp;#34;,&amp;#34;sfzipcodes&amp;#34;) %&amp;gt;% spTransform(CRS(&amp;#34;+proj=longlat +datum=WGS84&amp;#34;)) &amp;gt; ggplot(data = sfn, aes(x = long, y = lat, group = group)) + geom_path() &amp;gt; class(sfn) [1] &amp;#34;SpatialPolygonsDataFrame&amp;#34; attr(,&amp;#34;package&amp;#34;) [1] &amp;#34;sp&amp;#34; &amp;gt; names(sfn) [1] &amp;#34;OBJECTID&amp;#34; &amp;#34;ZIP_CODE&amp;#34; &amp;#34;ID&amp;#34; &amp;gt; sfn.f = sfn %&amp;gt;% fortify(region = &amp;#39;ZIP_CODE&amp;#39;) SFNeighbourhoods = merge(sfn.f, sfn@data, by.x = &amp;#39;id&amp;#39;, by.y = &amp;#39;ZIP_CODE&amp;#39;) &amp;gt; library(dplyr) &amp;gt; postcodes = SFNeighbourhoods %&amp;gt;% select(id) %&amp;gt;% distinct() &amp;gt; values = data.</description>
    </item>
    
    <item>
      <title>R: Linear models with the lm function, NA values and Collinearity</title>
      <link>https://markhneedham.com/blog/2014/10/18/r-linear-models-with-the-lm-function-na-values-and-collinearity/</link>
      <pubDate>Sat, 18 Oct 2014 06:35:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/18/r-linear-models-with-the-lm-function-na-values-and-collinearity/</guid>
      <description>library(datasets); data(swiss); require(stats); require(graphics) z &amp;lt;- swiss$Agriculture + swiss$Education fit = lm(Fertility ~ . + z, data = swiss) &amp;gt; alias(fit) Model : Fertility ~ Agriculture + Examination + Education + Catholic + Infant.Mortality + z Complete : (Intercept) Agriculture Examination Education Catholic Infant.Mortality z 0 1 0 1 0 0 &amp;gt; require(dplyr) &amp;gt; summary(lm(Fertility ~ . + z, data = swiss))$coefficients Estimate Std. Error t value Pr(&amp;gt;|t|) (Intercept) 66.9151817 10.</description>
    </item>
    
    <item>
      <title>R: A first attempt at linear regression</title>
      <link>https://markhneedham.com/blog/2014/09/30/r-a-first-attempt-at-linear-regression/</link>
      <pubDate>Tue, 30 Sep 2014 22:20:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/30/r-a-first-attempt-at-linear-regression/</guid>
      <description>library(RNeo4j) officeEventsQuery = &amp;#34;MATCH (g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;})-[:HOSTED_EVENT]-&amp;gt;(event)&amp;lt;-[:TO]-({response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(), (event)-[:HELD_AT]-&amp;gt;(venue) WHERE (event.time + event.utc_offset) &amp;lt; timestamp() AND venue.name IN [\&amp;#34;Neo Technology\&amp;#34;, \&amp;#34;OpenCredo\&amp;#34;] RETURN event.time + event.utc_offset AS eventTime,event.announced_at AS announcedAt, event.name, COUNT(*) AS rsvps&amp;#34; events = subset(cypher(graph, officeEventsQuery), !is.na(announcedAt)) events$eventTime &amp;lt;- timestampToDate(events$eventTime) events$day &amp;lt;- format(events$eventTime, &amp;#34;%A&amp;#34;) events$monthYear &amp;lt;- format(events$eventTime, &amp;#34;%m-%Y&amp;#34;) events$month &amp;lt;- format(events$eventTime, &amp;#34;%m&amp;#34;) events$year &amp;lt;- format(events$eventTime, &amp;#34;%Y&amp;#34;) events$announcedAt&amp;lt;- timestampToDate(events$announcedAt) events$timeDiff = as.numeric(events$eventTime - events$announcedAt, units = &amp;#34;days&amp;#34;) &amp;gt; head(events) eventTime announcedAt event.</description>
    </item>
    
    <item>
      <title>R: Deriving a new data frame column based on containing string</title>
      <link>https://markhneedham.com/blog/2014/09/29/r-deriving-a-new-data-frame-column-based-on-containing-string/</link>
      <pubDate>Mon, 29 Sep 2014 21:37:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/29/r-deriving-a-new-data-frame-column-based-on-containing-string/</guid>
      <description>&amp;gt; x = data.frame(name = c(&amp;#34;Java Hackathon&amp;#34;, &amp;#34;Intro to Graphs&amp;#34;, &amp;#34;Hands on Cypher&amp;#34;)) &amp;gt; x name 1 Java Hackathon 2 Intro to Graphs 3 Hands on Cypher &amp;gt; grepl(&amp;#34;Hackathon|Hands on|Hands On&amp;#34;, x$name) [1] TRUE FALSE TRUE x$practical = grepl(&amp;#34;Hackathon|Hands on|Hands On&amp;#34;, x$name) &amp;gt; x name practical 1 Java Hackathon TRUE 2 Intro to Graphs FALSE 3 Hands on Cypher TRUE </description>
    </item>
    
    <item>
      <title>R: Filtering data frames by column type (&#39;x&#39; must be numeric)</title>
      <link>https://markhneedham.com/blog/2014/09/29/r-filtering-data-frames-by-column-type-x-must-be-numeric/</link>
      <pubDate>Mon, 29 Sep 2014 05:46:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/29/r-filtering-data-frames-by-column-type-x-must-be-numeric/</guid>
      <description>&amp;gt; install.packages(&amp;#34;ISLR&amp;#34;) &amp;gt; library(ISLR) &amp;gt; head(Carseats) Sales CompPrice Income Advertising Population Price ShelveLoc Age Education Urban US 1 9.50 138 73 11 276 120 Bad 42 17 Yes Yes 2 11.22 111 48 16 260 83 Good 65 10 Yes Yes 3 10.06 113 35 10 269 80 Medium 59 12 Yes Yes 4 7.40 117 100 4 466 97 Medium 55 14 Yes Yes 5 4.15 141 64 3 340 128 Bad 38 13 Yes No 6 10.</description>
    </item>
    
    <item>
      <title>R: ggplot - Plotting multiple variables on a line chart</title>
      <link>https://markhneedham.com/blog/2014/09/16/r-ggplot-plotting-multiple-variables-on-a-line-chart/</link>
      <pubDate>Tue, 16 Sep 2014 16:59:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/16/r-ggplot-plotting-multiple-variables-on-a-line-chart/</guid>
      <description>&amp;gt; head(byWeek) Source: local data frame [6 x 2] week n 1 2011-06-02 8 2 2011-06-09 4 3 2011-06-30 2 4 2011-07-14 1 5 2011-07-21 1 6 2011-08-18 1 library(zoo) joinsByWeek = data.frame(actual = byWeek$n, week = byWeek$week, rolling = rollmean(byWeek$n, 4, fill = NA, align=c(&amp;#34;right&amp;#34;))) &amp;gt; head(joinsByWeek, 10) actual week rolling 1 8 2011-06-02 NA 2 4 2011-06-09 NA 3 2 2011-06-30 NA 4 1 2011-07-14 3.75 5 1 2011-07-21 2.</description>
    </item>
    
    <item>
      <title>R: Calculating rolling or moving averages</title>
      <link>https://markhneedham.com/blog/2014/09/13/r-calculating-rolling-or-moving-averages/</link>
      <pubDate>Sat, 13 Sep 2014 08:15:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/13/r-calculating-rolling-or-moving-averages/</guid>
      <description>mav &amp;lt;- function(x,n=5){filter(x,rep(1/n,n), sides=2)} &amp;gt; mav(c(4,5,4,6), 3) Time Series: Start = 1 End = 4 Frequency = 1 [1] NA 4.333333 5.000000 NA sides	for convolution filters only. If sides = 1 the filter coefficients are for past values only; if sides = 2 they are centred around lag 0. In this case the length of the filter should be odd, but if it is even, more of the filter is forward in time than backward.</description>
    </item>
    
  </channel>
</rss>