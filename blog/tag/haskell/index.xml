<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>haskell on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/haskell/</link>
    <description>Recent content in haskell on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jan 2013 00:12:25 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Knapsack Problem in Haskell</title>
      <link>https://markhneedham.com/blog/2013/01/09/knapsack-problem-in-haskell/</link>
      <pubDate>Wed, 09 Jan 2013 00:12:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/09/knapsack-problem-in-haskell/</guid>
      <description>ref :: a -&amp;gt; IORef a ref x = unsafePerformIO (newIORef x) knapsackCached1 :: [[Int]] -&amp;gt; Int -&amp;gt; Int -&amp;gt; IORef (Map.Map (Int, Int) Int) -&amp;gt; Int knapsackCached1 rows knapsackWeight index cacheContainer = unsafePerformIO $ do cache &amp;lt;- readIORef cacheContainer if index == 0 || knapsackWeight == 0 then do return 0 else let (value:weight:_) = rows !! index best = knapsackCached1 rows knapsackWeight prevIndex cacheContainer in if weight &amp;gt; knapsackWeight &amp;amp;&amp;amp; lookupPreviousIn cache == Nothing then do let updatedCache = Map.</description>
    </item>
    
    <item>
      <title>Haskell: Reading files</title>
      <link>https://markhneedham.com/blog/2013/01/02/haskell-reading-files/</link>
      <pubDate>Wed, 02 Jan 2013 00:16:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/02/haskell-reading-files/</guid>
      <description>import System.IO main = do withFile &amp;#34;clustering2.txt&amp;#34; ReadMode (\handle -&amp;gt; do contents &amp;lt;- hGetContents handle putStrLn contents) main = do contents &amp;lt;- readFile &amp;#34;clustering2.txt&amp;#34; putStrLn contents &amp;gt; :t readFile readFile :: FilePath -&amp;gt; IO String &amp;gt; contents &amp;lt;- readFile &amp;#34;clustering2.txt&amp;#34; &amp;gt; let (bits, nodes) = process contents &amp;gt; bits 24 &amp;gt; length nodes 19981 &amp;gt; take 10 nodes [379,1669,5749,6927,7420,9030,9188,9667,11878,12169] </description>
    </item>
    
    <item>
      <title>Haskell: Downloading the core library source code</title>
      <link>https://markhneedham.com/blog/2012/12/31/haskell-downloading-the-core-library-source-code/</link>
      <pubDate>Mon, 31 Dec 2012 22:39:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/31/haskell-downloading-the-core-library-source-code/</guid>
      <description>git clone https://github.com/ghc/ghc.git cd ghc ./sync-all get darcs get http://darcs.haskell.org/packages/base/ # gets most of the packages we&amp;#39;d be interested in darcs get http://darcs.haskell.org/packages/array/ # gets the array package </description>
    </item>
    
    <item>
      <title>Haskell: Strictness and the monadic bind</title>
      <link>https://markhneedham.com/blog/2012/12/31/haskell-strictness-and-the-monadic-bind/</link>
      <pubDate>Mon, 31 Dec 2012 22:27:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/31/haskell-strictness-and-the-monadic-bind/</guid>
      <description>union :: IO (IOArray Int Int) -&amp;gt; Int -&amp;gt; Int -&amp;gt; IO (IOArray Int Int) union arrayContainer x y = do actualArray &amp;lt;- arrayContainer ls &amp;lt;- getAssocs actualArray leader1 &amp;lt;- readArray actualArray x leader2 &amp;lt;- readArray actualArray y let newValues = (map (\(index, value) -&amp;gt; (index, leader1)) . filter (\(index, value) -&amp;gt; value == leader2)) ls sequence $ map (\(idx, val) -&amp;gt; writeArray actualArray idx val) newValues return actualArray union :: IO (IOArray Int Int) -&amp;gt; Int -&amp;gt; Int -&amp;gt; IO (IOArray Int Int) union arrayContainer x y = do actualArray &amp;lt;- arrayContainer ls &amp;lt;- getAssocs actualArray leader1 &amp;lt;- readArray actualArray x leader2 &amp;lt;- readArray actualArray y let newValues = (map (\(index, value) -&amp;gt; (index, leader1)) .</description>
    </item>
    
    <item>
      <title>Haskell: An impressively non performant union find</title>
      <link>https://markhneedham.com/blog/2012/12/31/haskell-an-impressively-non-performant-union-find/</link>
      <pubDate>Mon, 31 Dec 2012 20:44:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/31/haskell-an-impressively-non-performant-union-find/</guid>
      <description>To paraphrase from my previous post about how we use the union find data structure:&amp;gt; let uf = emptyEquivalence (0,9) [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)] &amp;gt; components $ equate 0 1 uf [(0,0),(1,0),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9)] &amp;gt; components $ equate 8 9 $ equate 0 1 $ uf [(0,0),(1,0),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,8)] &amp;gt; components $ equate 0 8 $ equate 8 9 $ equate 0 1 $ uf [(0,0),(1,0),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,0),(9,8)] class UnionFind def initialize(n) @leaders = 1.upto(n).inject([]) { |leaders, i| leaders[i] = i; leaders } end def connected?</description>
    </item>
    
    <item>
      <title>Bitwise operations in Ruby and Haskell</title>
      <link>https://markhneedham.com/blog/2012/12/31/bitwise-operations-in-ruby-and-haskell/</link>
      <pubDate>Mon, 31 Dec 2012 13:14:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/31/bitwise-operations-in-ruby-and-haskell/</guid>
      <description>&amp;gt; &amp;#34;10000&amp;#34;.to_i(2) =&amp;gt; 16 &amp;gt; import Data.Char &amp;gt; (foldr (\c s -&amp;gt; s * 2 + c) 0 . reverse . map digitToInt) &amp;#34;10000&amp;#34; 16 &amp;#39;10000&amp;#39; XOR &amp;#39;10000&amp;#39; &amp;gt; 16 ^ 16 =&amp;gt; 0 &amp;gt; [0,1,2,4,16].map { |x| 16 ^ x } =&amp;gt; [16, 17, 18, 20, 0] &amp;gt; bits = 5 &amp;gt; offsets = (0..(bits - 1)).map { |x| 2 ** x } =&amp;gt; [1, 2, 4, 8, 16] &amp;gt; offsets = (0.</description>
    </item>
    
    <item>
      <title>Haskell: Using qualified imports to avoid polluting the namespace</title>
      <link>https://markhneedham.com/blog/2012/12/30/haskell-using-qualified-imports-to-avoid-polluting-the-namespace/</link>
      <pubDate>Sun, 30 Dec 2012 23:16:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/30/haskell-using-qualified-imports-to-avoid-polluting-the-namespace/</guid>
      <description>import System.IO import Data.List.Split import Data.Char import Data.Bits import Control.Monad import Data.Map import Data.Set import Data.List import Data.Maybe clustering.hs:53:43: Ambiguous occurrence `filter&amp;#39; It could refer to either `Data.List.filter&amp;#39;, imported from `Data.List&amp;#39; at clustering.hs:11:1-16 (and originally defined in `GHC.List&amp;#39;) or `Data.Set.filter&amp;#39;, imported from `Data.Set&amp;#39; at clustering.hs:10:1-16 or `Data.Map.filter&amp;#39;, imported from `Data.Map&amp;#39; at clustering.hs:9:1-16 &amp;gt; import qualified Data.Map &amp;gt; Data.Map.assocs $ Data.Map.fromList [(1,2), (3,7)] [(1,2),(3,7)] import System.IO import Data.List.Split import Data.Char import Data.</description>
    </item>
    
    <item>
      <title>Haskell: Pattern matching a list</title>
      <link>https://markhneedham.com/blog/2012/12/30/haskell-pattern-matching-a-list/</link>
      <pubDate>Sun, 30 Dec 2012 22:39:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/30/haskell-pattern-matching-a-list/</guid>
      <description>&amp;gt; import Data.Bits &amp;gt; map (\pair -&amp;gt; (pair !! 0) .|. (pair !! 1)) [[1,2], [3,4]] [3,7] &amp;gt; map (\(x:y:_) -&amp;gt; x .|. y) [[1,2], [3,4]] [3,7] </description>
    </item>
    
    <item>
      <title>Haskell: A cleaner way of initialising a map</title>
      <link>https://markhneedham.com/blog/2012/12/29/haskell-a-cleaner-way-of-initialising-a-map/</link>
      <pubDate>Sat, 29 Dec 2012 20:14:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/29/haskell-a-cleaner-way-of-initialising-a-map/</guid>
      <description>import Data.Map toMap :: [Int] -&amp;gt; Map Int [Int] toMap nodes = fromList $ map asMapEntry $ (groupIgnoringIndex . sortIgnoringIndex) nodesWithIndexes where nodesWithIndexes = (zip [0..] nodes) groupIgnoringIndex = groupBy (\(_,x) (_,y) -&amp;gt; x == y) sortIgnoringIndex = sortBy (\(_,x) (_,y) -&amp;gt; x `compare` y) asMapEntry :: [(Int, Int)] -&amp;gt; (Int, [Int]) asMapEntry nodesWithIndexes = ((snd . head) nodesWithIndexes, Prelude.foldl (\acc (x,_) -&amp;gt; acc ++ [x]) [] nodesWithIndexes) &amp;gt; assocs $ toMap [1,2,5,7,2,4] [(1,[0]),(2,[4,1]),(4,[5]),(5,[2]),(7,[3])] &amp;gt; let emptyMap = empty :: Map Int [Int] &amp;gt; assocs $ foldl (\acc (id,val) -&amp;gt; insertWith (++) val [id] acc) emptyMap nodesWithIndexes [(1,[0]),(2,[4,1]),(4,[5]),(5,[2]),(7,[3])] </description>
    </item>
    
    <item>
      <title>Haskell: Initialising a map</title>
      <link>https://markhneedham.com/blog/2012/12/29/haskell-initialising-a-map/</link>
      <pubDate>Sat, 29 Dec 2012 19:27:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/29/haskell-initialising-a-map/</guid>
      <description>nodes = [1,2,5,7,2,4] @magical_hash = {} nodes.each_with_index do |node, index| @magical_hash[node] ||= [] @magical_hash[node] &amp;lt;&amp;lt; index end =&amp;gt; {1=&amp;gt;[0], 2=&amp;gt;[1, 4], 5=&amp;gt;[2], 7=&amp;gt;[3], 4=&amp;gt;[5]} &amp;gt; let nodesMap = Data.Map.fromList [(1, [0]), (2, [1,4]), (5, [2]), (7, [3]), (4, [5])] &amp;gt; Data.Map.assocs nodesMap [(1,[0]),(2,[1,4]),(4,[5]),(5,[2]),(7,[3])] &amp;gt; zip [0..] [1,2,5,7,2,4] [(0,1),(1,2),(2,5),(3,7),(4,2),(5,4)] groupIgnoringIndex = groupBy (\(_,x) (_,y) -&amp;gt; x == y) sortIgnoringIndex = sortBy (\(_,x) (_,y) -&amp;gt; x `compare` y) &amp;gt; (groupIgnoringIndex . sortIgnoringIndex) (zip [0.</description>
    </item>
    
    <item>
      <title>Haskell: Mixed type lists</title>
      <link>https://markhneedham.com/blog/2012/06/19/haskell-mixed-type-lists/</link>
      <pubDate>Tue, 19 Jun 2012 23:09:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/19/haskell-mixed-type-lists/</guid>
      <description>I&amp;rsquo;ve been continuing to work through the exercises in The Little Schemerand came across a problem which needed me to write a function to take a mixed list of Integers and Strings and filter out the Integers.
As I mentioned in my previous postI&amp;rsquo;ve been doing the exercises in Haskell but I thought I might struggle with that approach here because Haskell collections are homogeneous i.e. all the elements need to be of the same type.</description>
    </item>
    
    <item>
      <title>Haskell: Writing a function that can take Ints or Doubles</title>
      <link>https://markhneedham.com/blog/2012/06/05/haskell-writing-a-function-that-can-take-ints-or-doubles/</link>
      <pubDate>Tue, 05 Jun 2012 00:10:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/05/haskell-writing-a-function-that-can-take-ints-or-doubles/</guid>
      <description>In my continued reading of SICP I wanted to recreate a &amp;lsquo;sum&amp;rsquo; function used to demonstrate a function which could take another function as one of its parameters.
In Scheme the function is defined like this:
(define (sum term a next b) (if (&amp;gt; a b) 0 (+ (term a) (sum term (next a) next b)))) And can be used like this to sum the values between two numbers:
(define (identity x) x) (define (sum-integers a b) (sum identity a inc b)) &amp;gt; (sum-integers 1 10) 55 I translated it into Haskell as the following:</description>
    </item>
    
    <item>
      <title>Haskell: Building a range of numbers from command line arguments</title>
      <link>https://markhneedham.com/blog/2012/06/03/haskell-building-a-range-of-numbers-from-command-line-arguments/</link>
      <pubDate>Sun, 03 Jun 2012 20:13:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/03/haskell-building-a-range-of-numbers-from-command-line-arguments/</guid>
      <description>I&amp;rsquo;m working through some of the SICP problemsin Haskell and for problem 1.22you need to write a function which will indicate the first 3 prime numbers above a starting value.
It is also suggested to only consider odd numbers so to find the prime numbers above 1000 the function call would look like this:
&amp;gt; searchForPrimes [1001,1003..] [1009,1013,1019] I wanted to be able to feed in the range of numbers from the command line so that I&amp;rsquo;d be able to call the function with different values and see how long it took to work it out.</description>
    </item>
    
    <item>
      <title>Haskell: Using type classes to generify Project Euler #31</title>
      <link>https://markhneedham.com/blog/2012/05/30/haskell-using-type-classes-to-generify-project-euler-31/</link>
      <pubDate>Wed, 30 May 2012 12:08:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/30/haskell-using-type-classes-to-generify-project-euler-31/</guid>
      <description>As I mentioned in my previous post I&amp;rsquo;ve been working on Project Euler #31and initially wasn&amp;rsquo;t sure how to write the algorithm.
I came across a post on StackOverflow which explained it in more detailbut unfortunately the example used US coins rather than UK ones like in the Project Euler problem.
To start with I created two versions of the function - one for US coins and one for UK coins:</description>
    </item>
    
    <item>
      <title>Haskell: Java Style Enums</title>
      <link>https://markhneedham.com/blog/2012/05/30/haskell-java-style-enums/</link>
      <pubDate>Wed, 30 May 2012 11:10:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/30/haskell-java-style-enums/</guid>
      <description>I&amp;rsquo;ve been playing around with problem 31 of Project Eulerwhich is defined as follows:
1p, 2p, 5p, 10p, 20p, 50p, £1 (100p) and £2 (200p).
It is possible to make £2 in the following way:
1 £1 + 150p + 220p + 15p + 12p + 31p
How many different ways can £2 be made using any number of coins?
Having coded way too much in Java my first thought was that the coins could be represented as an Enum but I wasn&amp;rsquo;t sure how to do that in Haskell.</description>
    </item>
    
    <item>
      <title>Haskell: Finding the minimum &amp; maximum values of a Foldable in one pass</title>
      <link>https://markhneedham.com/blog/2012/05/28/haskell-finding-the-minimum-maximum-values-of-a-foldable-in-one-pass/</link>
      <pubDate>Mon, 28 May 2012 11:18:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/28/haskell-finding-the-minimum-maximum-values-of-a-foldable-in-one-pass/</guid>
      <description>I recently came across Dan Piponi&amp;rsquo;s blog post &amp;lsquo;Haskell Monoids &amp;amp; their Uses&amp;rsquo; and towards the end of the post he suggests creating monoids to work out the maximum and minimum values of a Foldable value in one pass.
The foldMap function applies a function to each element of our structure and then accumulates the return values of each of these applications.
A list is one example of a type which implements the Foldable type class like so:</description>
    </item>
    
    <item>
      <title>Haskell: Debugging code</title>
      <link>https://markhneedham.com/blog/2012/05/27/haskell-debugging-code/</link>
      <pubDate>Sun, 27 May 2012 22:16:38 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/27/haskell-debugging-code/</guid>
      <description>In my continued attempts to learn QuickCheck, one thing I&amp;rsquo;ve been doing is comparing the results of my brute forceand divide &amp;amp; conquer versionsof the closest pairs algorithm.
I started with this property:
let prop_dc_bf xs = (length xs &amp;gt; 2) ==&amp;gt; (fromJust $ bfClosest xs) == dcClosest xs And then ran it from GHCI, which resulted in the following error:
&amp;gt; quickCheck (prop_dc_bf :: [(Double, Double)] -&amp;gt; Property) *** Failed!</description>
    </item>
    
    <item>
      <title>Haskell: Using monoids when sorting by multiple parameters</title>
      <link>https://markhneedham.com/blog/2012/05/23/haskell-using-monoids-when-sorting-by-multiple-parameters/</link>
      <pubDate>Wed, 23 May 2012 06:44:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/23/haskell-using-monoids-when-sorting-by-multiple-parameters/</guid>
      <description>On the project I&amp;rsquo;ve been working on we had a requirement to sort a collection of rows by 4 different criteria such that if two items matched for the first criteria we should consider the second criteria and so on.
If we wrote that code in Haskell it would read a bit like this:
data Row = Row { shortListed :: Bool, cost :: Float, distance1 :: Int, distance2 :: Int } deriving (Show, Eq) import Data.</description>
    </item>
    
    <item>
      <title>Scala/Haskell: A simple example of type classes</title>
      <link>https://markhneedham.com/blog/2012/05/22/scalahaskell-a-simple-example-of-type-classes/</link>
      <pubDate>Tue, 22 May 2012 10:26:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/22/scalahaskell-a-simple-example-of-type-classes/</guid>
      <description>I never really understood type classes when I was working with Scala but I recently came across a video where Dan Rosen explains them pretty well.
Since the last time I worked in Scala I&amp;rsquo;ve been playing around with Haskell where type classes are much more common - for example if we want to compare two values we need to make sure that their type extends the &amp;lsquo;Eq&amp;rsquo; type class.</description>
    </item>
    
    <item>
      <title>Haskell: My first attempt with QuickCheck and HUnit</title>
      <link>https://markhneedham.com/blog/2012/05/20/haskell-my-first-attempt-with-quickcheck-and-hunit/</link>
      <pubDate>Sun, 20 May 2012 19:09:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/20/haskell-my-first-attempt-with-quickcheck-and-hunit/</guid>
      <description>As I mentioned in a blog post a few daysI&amp;rsquo;ve started learning QuickCheck with the test-frameworkpackage as suggested by David Turner.
I first needed to install test-framework and some dependencies using cabal:
&amp;gt; cabal install test-framework &amp;gt; cabal install test-framework-quickcheck &amp;gt; cabal install test-framework-hunit I thought it&amp;rsquo;d be interesting to try and write some tests around the windowed function that I wrote a few months ago:
Windowed.hsmodule Windowed (windowed) where windowed :: Int -&amp;gt; [a] -&amp;gt; [[a]] windowed size [] = [] windowed size ls@(x:xs) = if length ls &amp;gt;= size then (take size ls) : windowed size xs else windowed size x I wrote my first property like so:</description>
    </item>
    
    <item>
      <title>Haskell: Writing a custom equality operator</title>
      <link>https://markhneedham.com/blog/2012/05/16/haskell-writing-a-custom-equality-operator/</link>
      <pubDate>Wed, 16 May 2012 13:16:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/16/haskell-writing-a-custom-equality-operator/</guid>
      <description>In the comments on my post about generating random numbersto test a function David Turner suggested that this was exactly the use case for which QuickCheckwas intended for so I&amp;rsquo;ve been learning a bit more about that this week.
I started with a simple property to check that the brute force (bf) and divide and conquer (dc) versions of the algorithm returned the same result, assuming that there were enough values in the list to have a closest pair:</description>
    </item>
    
    <item>
      <title>Haskell: Removing if statements</title>
      <link>https://markhneedham.com/blog/2012/05/12/haskell-removing-if-statements/</link>
      <pubDate>Sat, 12 May 2012 15:46:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/12/haskell-removing-if-statements/</guid>
      <description>When I was looking over my solution to the closest pairs algorithmwhich I wrote last week I realised there there were quite a few if statements, something I haven&amp;rsquo;t seen in other Haskell code I&amp;rsquo;ve read.
This is the initial version that I wrote:
dcClosest :: (Ord a, Floating a) =&amp;gt; [Point a] -&amp;gt; (Point a, Point a) dcClosest pairs if length pairs &amp;lt;= 3 then = fromJust $ bfClosest pairs else foldl (\closest (p1:p2:_) -&amp;gt; if distance (p1, p2) &amp;lt; distance closest then (p1, p2) else closest) closestPair (windowed 2 pairsWithinMinimumDelta) where sortedByX = sortBy compare pairs	(leftByX:rightByX:_) = chunk (length sortedByX `div` 2) sortedByX closestPair = if distance closestLeftPair &amp;lt; distance closestRightPair then closestLeftPair else closestRightPair where closestLeftPair = dcClosest leftByX closestRightPair = dcClosest rightByX pairsWithinMinimumDelta = sortBy (compare `on` snd) $ filter withinMinimumDelta sortedByX where withinMinimumDelta (x, _) = abs (xMidPoint - x) &amp;lt;= distance closestPair where (xMidPoint, _) = last leftByX We can remove the first if statement which checks the length of the list and replace it with pattern matching code like so:</description>
    </item>
    
    <item>
      <title>Haskell: Explicit type declarations in GHCI</title>
      <link>https://markhneedham.com/blog/2012/05/10/haskell-explicit-type-declarations-in-ghci/</link>
      <pubDate>Thu, 10 May 2012 07:11:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/10/haskell-explicit-type-declarations-in-ghci/</guid>
      <description>On a few occasions I&amp;rsquo;ve wanted to be able to explicitly define the type of something when trying things out in the Haskell REPL (GHCI) but I didn&amp;rsquo;t actually realise this was possible until a couple of days ago.
For example say we want to use the readfunction to parse an input string into an integer.
We could do this:
&amp;gt; read &amp;#34;1&amp;#34; :: Int 1 But if we just evaluate the function alone and try and assign the result without casting to a type we get an exception:</description>
    </item>
    
    <item>
      <title>Haskell: Closest Pairs Algorithm</title>
      <link>https://markhneedham.com/blog/2012/05/09/haskell-closest-pairs-algorithm/</link>
      <pubDate>Wed, 09 May 2012 00:05:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/09/haskell-closest-pairs-algorithm/</guid>
      <description>As I mentioned in a post a couple of days agoI&amp;rsquo;ve been writing the closest pairs algorithm in Haskell and while the brute force version works for small numbers of pairs it starts to fall apart as the number of pairs increases:
time ./closest_pairs 100 bf ./closest_pairs 100 bf 0.01s user 0.00s system 87% cpu 0.016 total time ./closest_pairs 1000 bf ./closest_pairs 1000 bf 3.59s user 0.01s system 99% cpu 3.</description>
    </item>
    
    <item>
      <title>Haskell: Generating random numbers</title>
      <link>https://markhneedham.com/blog/2012/05/08/haskell-generating-random-numbers/</link>
      <pubDate>Tue, 08 May 2012 22:09:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/08/haskell-generating-random-numbers/</guid>
      <description>As I mentioned in my last postI&amp;rsquo;ve been coding the closest pairs algorithm in Haskell and needed to create some pairs of coordinates to test it against.
I&amp;rsquo;ve tried to work out how to create lists of random numbers in Haskell before and always ended up giving up because it seemed way more difficult than it should be but this time I came across a really good explanation of how to do it by jrockway on Stack Overflow.</description>
    </item>
    
    <item>
      <title>Haskell: Maximum Int value</title>
      <link>https://markhneedham.com/blog/2012/05/07/haskell-maximum-int-value/</link>
      <pubDate>Mon, 07 May 2012 09:18:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/07/haskell-maximum-int-value/</guid>
      <description>One of the algorithms covered in Algo Classwas the closest pairs algorithm- an algorithm used to determine which pair of points on a plane are closest to each other based on their Euclidean distance.
My real interest lies in writing the divide and conquer version of the algorithm but I started with the brute force version so that I&amp;rsquo;d be able to compare my answers.
This is the algorithm:
minDist = infinity for each p in P: for each q in P: if p ≠ q and dist(p, q) &amp;lt; minDist: minDist = dist(p, q) closestPair = (p, q) return closestPair &amp;lsquo;infinity&amp;rsquo; in this case could be the maximum value that an Int could hold which on a 64 bit architecture would be 263so I hardcoded that into my implementation: o</description>
    </item>
    
    <item>
      <title>Haskell: Colour highlighting when writing to the shell</title>
      <link>https://markhneedham.com/blog/2012/04/29/haskell-colour-highlighting-when-writing-to-the-shell/</link>
      <pubDate>Sun, 29 Apr 2012 00:01:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/29/haskell-colour-highlighting-when-writing-to-the-shell/</guid>
      <description>I spent a few hours writing a simple front end on top of the Rabin Karp algorithmso that I could show the line of the first occurrence of a pattern in a piece of text on the shell.
I thought it would be quite cool if I could highlight the appropriate text on the line like how grep doeswhen the &amp;lsquo;&amp;ndash;color=auto&amp;rsquo; flag is supplied.
We can make use of ANSI escape codesto do this.</description>
    </item>
    
    <item>
      <title>Haskell: Int and Integer</title>
      <link>https://markhneedham.com/blog/2012/04/28/haskell-int-and-integer/</link>
      <pubDate>Sat, 28 Apr 2012 17:39:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/28/haskell-int-and-integer/</guid>
      <description>In my last post about the Rabin Karp algorithmI mentioned that I was having some problems when trying to write a hash function which closely matched its English description.
This is my current version of the hash function:
hash = hash&amp;#39; globalR globalQ hash&amp;#39; r q string m = foldl (\acc x -&amp;gt; (r * acc + ord x) `mod` q) 0 $ take m string And my initial attempt to write the alternate version was this:</description>
    </item>
    
    <item>
      <title>Algorithms: Rabin Karp in Haskell</title>
      <link>https://markhneedham.com/blog/2012/04/25/algorithms-rabin-karp-in-haskell/</link>
      <pubDate>Wed, 25 Apr 2012 21:28:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/25/algorithms-rabin-karp-in-haskell/</guid>
      <description>I recently came across a blog post describing the Rabin Karp algorithm- an algorithm that uses hashing to find a pattern string in some text - and thought it would be interesting to try and write a version of it in Haskell.
This algorithm is typically used when we want to search for multiple pattern strings in a text e.g. when detecting plagiarism or a primitive way of detecting code duplication but my initial version only lets your search for one pattern.</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell - Abstracting the common</title>
      <link>https://markhneedham.com/blog/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</link>
      <pubDate>Tue, 17 Apr 2012 07:22:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/17/algorithms-flood-fill-in-haskell-abstracting-the-common/</guid>
      <description>In the comments of my blog post describing the flood fill algorithm in HaskellDavid Turner pointed out that the way I was passing the grid around was quite error prone.
floodFill :: Array (Int, Int) Colour -&amp;gt; (Int, Int) -&amp;gt; Colour -&amp;gt; Colour -&amp;gt; Array (Int, Int) Colour floodFill grid point@(x, y) target replacement = if((not $ inBounds grid point) || grid ! (x,y) /= target) then grid else gridNorth where grid&amp;#39; = replace grid point replacement gridEast = floodFill grid&amp;#39; (x+1, y) target replacement gridWest = floodFill gridEast (x-1, y) target replacement gridSouth = floodFill gridWest (x, y+1) target replacement gridNorth = floodFill gridSouth (x, y-1) target replacement I actually did pass the wrong grid variable around while I was writing it and ended up quite confused as to why it wasn&amp;rsquo;t working as I expected.</description>
    </item>
    
    <item>
      <title>Haskell: A simple parsing example using pattern matching</title>
      <link>https://markhneedham.com/blog/2012/04/15/haskell-a-simple-parsing-example-using-pattern-matching/</link>
      <pubDate>Sun, 15 Apr 2012 14:22:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/15/haskell-a-simple-parsing-example-using-pattern-matching/</guid>
      <description>As part of the second question in the Google Code JamI needed to be able to parse lines of data which looked like this:
3 1 5 15 13 11 where
This seemed like it should be easy to do but my initial search led me to the Parsec chapterin Real World Haskell which seemed a bit over the top for my problem.
All we really need to do is split on a space and then extract the parts of the resulting list.</description>
    </item>
    
    <item>
      <title>Haskell: Reading in multiple lines of arguments</title>
      <link>https://markhneedham.com/blog/2012/04/15/haskell-reading-in-multiple-lines-of-arguments/</link>
      <pubDate>Sun, 15 Apr 2012 13:44:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/15/haskell-reading-in-multiple-lines-of-arguments/</guid>
      <description>I&amp;rsquo;ve mostly avoided doing any I/O in Haskell but as part of the Google Code JamI needed to work out how to read a variable number of lines as specified by the user.
The input looks like this:
4 3 1 5 15 13 11 3 0 8 23 22 21 2 1 1 8 0 6 2 8 29 20 8 18 18 21 The first line indicates how many lines will follow.</description>
    </item>
    
    <item>
      <title>Haskell: Processing program arguments</title>
      <link>https://markhneedham.com/blog/2012/04/08/haskell-processing-program-arguments/</link>
      <pubDate>Sun, 08 Apr 2012 20:11:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/08/haskell-processing-program-arguments/</guid>
      <description>My Prismatic news feedrecently threw up an interesting tutorial titled &amp;lsquo;Haskell the Hard Way&amp;rsquo; which has an excellent and easy to understand section showing how to do IO in Haskell.
About half way down the page there&amp;rsquo;s an exercise to write a program which sums all its arguments which I thought I&amp;rsquo;d have a go at.
We need to use the System.getArgsfunction to get the arguments passed to the program. It has the following signature:</description>
    </item>
    
    <item>
      <title>Algorithms: Flood Fill in Haskell</title>
      <link>https://markhneedham.com/blog/2012/04/07/algorithms-flood-fill-in-haskell/</link>
      <pubDate>Sat, 07 Apr 2012 00:25:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/07/algorithms-flood-fill-in-haskell/</guid>
      <description>Flood fillis an algorithm used to work out which nodes are connected to a certain node in a multi dimensional array. In this case we&amp;rsquo;ll use a two dimensional array.
The idea is that we decide that we want to change the colour of one of the cells in the array and have its immediate neighbours who share its initial colour have their colour changed too i.e. the colour floods its way through the grid.</description>
    </item>
    
    <item>
      <title>Haskell: Print friendly representation of an Array</title>
      <link>https://markhneedham.com/blog/2012/04/03/haskell-print-friendly-representation-of-an-array/</link>
      <pubDate>Tue, 03 Apr 2012 21:52:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/03/haskell-print-friendly-representation-of-an-array/</guid>
      <description>Quite frequently I play around with 2D arrays in Haskell but I&amp;rsquo;ve never quite worked out how to print them in a way that makes it easy to see the contents.
I&amp;rsquo;m using the array from the &amp;lsquo;Data.Array&amp;rsquo; module because it seems to be easier to transform them into a new representation if I want to change a value in one of the cells.
The function to create one therefore looks like this:</description>
    </item>
    
    <item>
      <title>Haskell: Pattern matching data types with named fields</title>
      <link>https://markhneedham.com/blog/2012/03/31/haskell-pattern-matching-data-types-with-named-fields/</link>
      <pubDate>Sat, 31 Mar 2012 22:49:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/31/haskell-pattern-matching-data-types-with-named-fields/</guid>
      <description>One of my favourite things about coding in Haskell is that I often end up pattern matching against data types.
I&amp;rsquo;ve been playing around with modelling cars coming into and out from a car park and changing the state of the car park accordingly.
I started with these data type definitions:
data CarParkState = Available Bool Int Int | AlmostFull Bool Int Int | Full Bool Int deriving (Show) data Action = Entering | Leaving deriving (Show) data Sticker = Handicap | None deriving (Show) which were used in the following function:</description>
    </item>
    
    <item>
      <title>Haskell: Memoization using the power of laziness</title>
      <link>https://markhneedham.com/blog/2012/03/24/haskell-memoization-using-the-power-of-laziness/</link>
      <pubDate>Sat, 24 Mar 2012 12:28:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/24/haskell-memoization-using-the-power-of-laziness/</guid>
      <description>I&amp;rsquo;ve been trying to solve problem 15 of Project Eulerwhich requires you to find the number of routes that can be taken to navigate from the top corner of a grid down to the bottom right corner.
For example there are six routes across a 2x2 grid:
My initial solution looked like this:
routes :: (Int, Int) -&amp;gt; Int -&amp;gt; Int routes origin size = inner origin size where inner origin@(x, y) size | x == size &amp;amp;&amp;amp; y == size = 0 | x == size || y == size = 1 | otherwise = inner (x+1, y) size + inner (x, y+1) size Which can be called like this:</description>
    </item>
    
    <item>
      <title>Haskell: Newbie currying mistake</title>
      <link>https://markhneedham.com/blog/2012/03/20/haskell-newbie-currying-mistake/</link>
      <pubDate>Tue, 20 Mar 2012 23:55:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/20/haskell-newbie-currying-mistake/</guid>
      <description>As I mentioned in my last postI&amp;rsquo;ve spent a bit of this evening writing a merge sort function and one of the mistakes I made a few times was incorrectly passing arguments to the recursive calls of &amp;lsquo;merge&amp;rsquo;.
For example, this is one of the earlier versions of the function:
middle :: [Int] -&amp;gt; Int middle = floor . (\y -&amp;gt; y / 2) . fromIntegral . length	msort :: [Int] -&amp;gt; [Int] msort unsorted = let n = middle unsorted in if n == 0 then unsorted else let (left, right) = splitAt n unsorted in merge (msort left) (msort right) where merge [] right = right merge left [] = left merge left@(x:xs) right@(y:ys) = if x &amp;lt; y then x : merge(xs, right) else y : merge (left, ys) Which doesn&amp;rsquo;t actually compile:</description>
    </item>
    
    <item>
      <title>Haskell: Chaining functions to find the middle value in a collection</title>
      <link>https://markhneedham.com/blog/2012/03/20/haskell-chaining-functions-to-find-the-middle-value-in-a-collection/</link>
      <pubDate>Tue, 20 Mar 2012 23:36:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/20/haskell-chaining-functions-to-find-the-middle-value-in-a-collection/</guid>
      <description>I&amp;rsquo;ve been playing around with writing merge sort in Haskell and eventually ended up with the following function:
msort :: [Int] -&amp;gt; [Int] msort unsorted = let n = floor (fromIntegral(length unsorted) / 2) in if n == 0 then unsorted else let (left, right) = splitAt n unsorted in merge (msort left) (msort right) where merge [] right = right merge left [] = left merge left@(x:xs) right@(y:ys) = if x &amp;lt; y then x : merge xs right else y : merge left ys The 3rd line was annoying me as it has way too many brackets on it and I was fairly sure that it should be possible to just combine the functions like I learnt to do in F# a few years ago.</description>
    </item>
    
    <item>
      <title>Functional Programming: One function at a time</title>
      <link>https://markhneedham.com/blog/2012/03/19/functional-programming-one-function-at-a-time/</link>
      <pubDate>Mon, 19 Mar 2012 23:25:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/19/functional-programming-one-function-at-a-time/</guid>
      <description>As I mentioned in an earlier post I got a bit stuck working out all the diagonals in the 20x20 grid of Project Euler problem 11and my colleague Uday ended up showing me how to do it.
I realised while watching him solve the problem that we&amp;rsquo;d been using quite different approaches to solving the problem and that his way worked way better than mine, at least in this context.</description>
    </item>
    
    <item>
      <title>Functional Programming: Shaping the data to fit a function</title>
      <link>https://markhneedham.com/blog/2012/03/13/functional-programming-shaping-the-data-to-fit-a-function/</link>
      <pubDate>Tue, 13 Mar 2012 22:55:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/13/functional-programming-shaping-the-data-to-fit-a-function/</guid>
      <description>As I mentioned in my last post I&amp;rsquo;ve been working on Project Euler problem 11 and one thing I noticed was that I was shaping the data around a windowedfunction since it seemed to fit the problem quite well.
Problem 11is defined like so:
The product of these numbers is 26 63 78 14 = 1788696.
What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in the 20x20 grid?</description>
    </item>
    
    <item>
      <title>Haskell: Couldn&#39;t match expected type `Int&#39; with actual type `Integer&#39;</title>
      <link>https://markhneedham.com/blog/2012/03/13/haskell-couldnt-match-expected-type-int-with-actual-type-integer/</link>
      <pubDate>Tue, 13 Mar 2012 19:42:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/13/haskell-couldnt-match-expected-type-int-with-actual-type-integer/</guid>
      <description>One of the most frequent compilation error messages that I&amp;rsquo;ve been getting while working through the Project Euler problems in Haskell is the following:
Couldn&amp;#39;t match expected type `Int&amp;#39; with actual type `Integer&amp;#39; In problem 11, for example, I define the grid of numbers like so:
grid = [[08,02,22,97,38,15,00,40,00,75,04,05,07,78,52,12,50,77,91,08], [49,49,99,40,17,81,18,57,60,87,17,40,98,43,69,48,04,56,62,00], [81,49,31,73,55,79,14,29,93,71,40,67,53,88,30,03,49,13,36,65], [52,70,95,23,04,60,11,42,69,24,68,56,01,32,56,71,37,02,36,91], [22,31,16,71,51,67,63,89,41,92,36,54,22,40,40,28,66,33,13,80], [24,47,32,60,99,03,45,02,44,75,33,53,78,36,84,20,35,17,12,50], [32,98,81,28,64,23,67,10,26,38,40,67,59,54,70,66,18,38,64,70], [67,26,20,68,02,62,12,20,95,63,94,39,63,08,40,91,66,49,94,21], [24,55,58,05,66,73,99,26,97,17,78,78,96,83,14,88,34,89,63,72], [21,36,23,09,75,00,76,44,20,45,35,14,00,61,33,97,34,31,33,95], [78,17,53,28,22,75,31,67,15,94,03,80,04,62,16,14,09,53,56,92], [16,39,05,42,96,35,31,47,55,58,88,24,00,17,54,24,36,29,85,57], [86,56,00,48,35,71,89,07,05,44,44,37,44,60,21,58,51,54,17,58], [19,80,81,68,05,94,47,69,28,73,92,13,86,52,17,77,04,89,55,40], [04,52,08,83,97,35,99,16,07,97,57,32,16,26,26,79,33,27,98,66], [88,36,68,87,57,62,20,72,03,46,33,67,46,55,12,32,63,93,53,69], [04,42,16,73,38,25,39,11,24,94,72,18,08,46,29,32,40,62,76,36], [20,69,36,41,72,30,23,88,34,62,99,69,82,67,59,85,74,04,36,16], [20,73,35,29,78,31,90,01,74,31,49,71,48,86,81,16,23,57,05,54], [01,70,54,71,83,51,54,69,16,92,33,48,61,43,52,01,89,19,67,48]] Which has the following type:</description>
    </item>
    
    <item>
      <title>Haskell: Creating a sliding window over a collection</title>
      <link>https://markhneedham.com/blog/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/</link>
      <pubDate>Tue, 28 Feb 2012 00:21:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/02/28/haskell-creating-a-sliding-window-over-a-collection/</guid>
      <description>A couple of years ago when I was playing around with F# I came across the Seq.windowedfunction which allows you to create a sliding window of a specific size over a collection.
Taking an example from the F# documentation page:
let seqNumbers = [ 1.0; 1.5; 2.0; 1.5; 1.0; 1.5 ] :&amp;gt; seq&amp;lt;float&amp;gt; let seqWindows = Seq.windowed 3 seqNumbers We end up with this:
Initial sequence: 1.0 1.5 2.0 1.5 1.</description>
    </item>
    
    <item>
      <title>Haskell: Getting the nth element in a list</title>
      <link>https://markhneedham.com/blog/2012/02/28/haskell-getting-the-nth-element-in-a-list/</link>
      <pubDate>Tue, 28 Feb 2012 00:02:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/02/28/haskell-getting-the-nth-element-in-a-list/</guid>
      <description>I started trying to solve some of the Project Euler problemsas a way to learn a bit of Haskell and problem 7is defined like so:
What is the 10 001st prime number?
I read that the Sieve of Eratosthenesis a useful algorithm for working out all the prime numbers and there&amp;rsquo;s a page on the Literate Programs wiki explaining how to derive them using it.
The most naive implementation of all the primes ends up reading like this:</description>
    </item>
    
    <item>
      <title>Haskell: Viewing the steps of a reduce</title>
      <link>https://markhneedham.com/blog/2012/02/25/haskell-viewing-the-steps-of-a-reduce/</link>
      <pubDate>Sat, 25 Feb 2012 23:40:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/02/25/haskell-viewing-the-steps-of-a-reduce/</guid>
      <description>I&amp;rsquo;ve been playing around with Haskell a bit over the last week and in the bit of code I was working on I wanted to fold over a collection but see the state of the fold after each step.
I remembered Don Syme showing me how to do something similar during the F# Exchange last year while we were writing some code to score a tennis gameby using Seq.scan.
I didn&amp;rsquo;t realise there was also a scan function in Haskell which could be defined in terms of foldlif we wanted to:</description>
    </item>
    
    <item>
      <title>Haskell: parse error on input `=&#39;</title>
      <link>https://markhneedham.com/blog/2010/04/22/haskell-parse-error-on-input/</link>
      <pubDate>Thu, 22 Apr 2010 23:35:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2010/04/22/haskell-parse-error-on-input/</guid>
      <description>I&amp;rsquo;ve been trying to follow the &amp;lsquo;Monads for Java/C++ programmers&amp;rsquo; post in ghci and getting the following type of error when trying out the code snippets:
Prelude&amp;gt; a = 3 &amp;lt;interactive&amp;gt;:1:2: parse error on input `=&amp;#39; I figured there must be something wrong with my installation of the compiler since I was copying and pasting the example across and having this problem. Having reinstalled that, however, I still had the same problem.</description>
    </item>
    
    <item>
      <title>Haskell vs F#: Function composition</title>
      <link>https://markhneedham.com/blog/2009/12/09/haskell-vs-f-function-composition/</link>
      <pubDate>Wed, 09 Dec 2009 22:10:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/12/09/haskell-vs-f-function-composition/</guid>
      <description>I&amp;rsquo;m reading through John Hughes&amp;rsquo; &amp;lsquo;Why functional programming matters&amp;rsquo; paper and one thing I&amp;rsquo;ve come across which is a bit counter intuitive to me is the Haskell function composition operator.
I&amp;rsquo;ve written previously about F#&amp;lsquo;s function composition operatorwhich is defined as follows:
let inline (&amp;gt;&amp;gt;) f g x = g(f x) To write a function which doubled all the values in a list and then returned the odd values we&amp;rsquo;d do this:</description>
    </item>
    
  </channel>
</rss>