<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clojure on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/clojure/</link>
    <description>Recent content in clojure on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 24 Jan 2016 22:01:43 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/clojure/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Clojure: First steps with reducers</title>
      <link>https://markhneedham.com/blog/2016/01/24/clojure-first-steps-with-reducers/</link>
      <pubDate>Sun, 24 Jan 2016 22:01:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/01/24/clojure-first-steps-with-reducers/</guid>
      <description>(defn log2 [n] (/ (Math/log n) (Math/log 2))) (defn score-item [n] (if (= n 0) 0 (log2 n))) (+ (score-item 12) (score-item 13) (score-item 5)) 9.60733031374961 (reduce #(+ %1 (score-item %2)) 0 [12 13 5]) 9.60733031374961 (reduce #(+ %1 (score-item %2)) 0 [12 13 5 6]) 12.192292814470767 (require &amp;#39;[clojure.core.reducers :as r]) (r/reduce #(+ %1 (score-item %2)) 0 [12 13 5 6]) 12.192292814470767 (-&amp;gt;&amp;gt;[12 13 5 6] (map score-item) (filter #(&amp;gt; % 3))) (3.</description>
    </item>
    
    <item>
      <title>Neo4j&#39;s Cypher vs Clojure - Group by and Sorting</title>
      <link>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</link>
      <pubDate>Sun, 29 Jun 2014 02:56:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</guid>
      <description>CREATE (event1:Event {name: &amp;quot;Future Event 1&amp;quot;, timestamp: 1414002772427 }) CREATE (event2:Event {name: &amp;quot;Future Event 2&amp;quot;, timestamp: 1424002772427 }) CREATE (event3:Event {name: &amp;quot;Future Event 3&amp;quot;, timestamp: 1416002772427 }) CREATE (event4:Event {name: &amp;quot;Past Event 1&amp;quot;, timestamp: 1403002772427 }) CREATE (event5:Event {name: &amp;quot;Past Event 2&amp;quot;, timestamp: 1402002772427 }) $ MATCH (e:Event) RETURN e; ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | e | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | Node[15414]{name:&amp;quot;Future Event 1&amp;quot;,timestamp:1414002772427} | ==&amp;gt; | Node[15415]{name:&amp;quot;Future Event 2&amp;quot;,timestamp:1424002772427} | ==&amp;gt; | Node[15416]{name:&amp;quot;Future Event 3&amp;quot;,timestamp:1416002772427} | ==&amp;gt; | Node[15417]{name:&amp;quot;Past Event 1&amp;quot;,timestamp:1403002772427} | ==&amp;gt; | Node[15418]{name:&amp;quot;Past Event 2&amp;quot;,timestamp:1402002772427} | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; 5 rows ==&amp;gt; 13 ms (def sorted-query &amp;#34;MATCH (e:Event) WITH COLLECT(e) AS events WITH [e IN events WHERE e.</description>
    </item>
    
    <item>
      <title>Clojure: Destructuring group-by&#39;s output</title>
      <link>https://markhneedham.com/blog/2014/05/31/clojure-destructuring-group-bys-output/</link>
      <pubDate>Sat, 31 May 2014 00:03:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/clojure-destructuring-group-bys-output/</guid>
      <description>user&amp;gt; (def events [{:name &amp;#34;e1&amp;#34; :timestamp 123} {:name &amp;#34;e2&amp;#34; :timestamp 456} {:name &amp;#34;e3&amp;#34; :timestamp 789}]) user&amp;gt; (group-by #(&amp;gt; (-&amp;gt;&amp;gt; % :timestamp) 123) events) {false [{:name &amp;#34;e1&amp;#34;, :timestamp 123}], true [{:name &amp;#34;e2&amp;#34;, :timestamp 456} {:name &amp;#34;e3&amp;#34;, :timestamp 789}]} user&amp;gt; (let [{upcoming true past false} (group-by #(&amp;gt; (-&amp;gt;&amp;gt; % :timestamp) 123) events)] (println upcoming) (println past)) [{:name e2, :timestamp 456} {:name e3, :timestamp 789}] [{:name e1, :timestamp 123}] nil </description>
    </item>
    
    <item>
      <title>Clojure: Create a directory</title>
      <link>https://markhneedham.com/blog/2014/05/24/clojure-create-a-directory/</link>
      <pubDate>Sat, 24 May 2014 00:12:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/24/clojure-create-a-directory/</guid>
      <description>(.mkdir (java.io.File. &amp;#34;/path/to/dir/to/create&amp;#34;)) (ns neo4j-meetup.core (:require [clj-time.format :as f])) (def format-as-year-month-day (f/formatter &amp;#34;yyyy-MM-dd&amp;#34;)) (defn create-directory-for-today [] (let [date (f/unparse format-as-year-month-day (t/now))] (.mkdir (java.io.File. (str &amp;#34;data/members-&amp;#34; date))))) </description>
    </item>
    
    <item>
      <title>Clojure: Paging meetup data using lazy sequences</title>
      <link>https://markhneedham.com/blog/2014/04/30/clojure-paging-meetup-data-using-lazy-sequences/</link>
      <pubDate>Wed, 30 Apr 2014 00:20:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/30/clojure-paging-meetup-data-using-lazy-sequences/</guid>
      <description>(defn unchunk [s] (when (seq s) (lazy-seq (cons (first s) (unchunk (next s)))))) (defn offsets [] (unchunk (range))) (defn get-all [api-fn] (flatten (take-while seq (map #(api-fn {:perpage 200 :offset % :orderby &amp;#34;name&amp;#34;}) (offsets))))) (:require [clj-http.client :as client]) (defn members [{perpage :perpage offset :offset orderby :orderby}] (-&amp;gt;&amp;gt; (client/get (str &amp;#34;https://api.meetup.com/2/members?page=&amp;#34; perpage &amp;#34;&amp;amp;offset=&amp;#34; offset &amp;#34;&amp;amp;orderby=&amp;#34; orderby &amp;#34;&amp;amp;group_urlname=&amp;#34; MEETUP_NAME &amp;#34;&amp;amp;key=&amp;#34; MEETUP_KEY) {:as :json}) :body :results)) (defn all-members [] (get-all members)) </description>
    </item>
    
    <item>
      <title>Clojure: clj-time - Formatting a date / timestamp with day suffixes e.g. 1st, 2nd, 3rd</title>
      <link>https://markhneedham.com/blog/2014/04/26/clojure-clj-time-formatting-a-date-timestamp-with-day-suffixes-e-g-1st-2nd-3rd/</link>
      <pubDate>Sat, 26 Apr 2014 07:50:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/26/clojure-clj-time-formatting-a-date-timestamp-with-day-suffixes-e-g-1st-2nd-3rd/</guid>
      <description>1309368600000 user&amp;gt; (require &amp;#39;[clj-time.coerce :as c]) user&amp;gt; (c/from-long 1309368600000) #&amp;lt;DateTime 2011-06-29T17:30:00.000Z&amp;gt; 29th June 2011 user&amp;gt; (require &amp;#39;[clj-time.format :as f]) nil user&amp;gt; (f/unparse (f/formatter &amp;#34;d MMMM yyyy&amp;#34;) (c/from-long 1309368600000)) &amp;#34;29 June 2011&amp;#34; (defn day-suffix [day] (let [stripped-day (if (&amp;lt; day 20) day (mod day 10))] (cond (= stripped-day 1) &amp;#34;st&amp;#34; (= stripped-day 2) &amp;#34;nd&amp;#34; (= stripped-day 3) &amp;#34;rd&amp;#34; :else &amp;#34;th&amp;#34;))) user&amp;gt; (def my-time (c/from-long 1309368600000)) #&amp;#39;user/my-time user&amp;gt; (def day (read-string (f/unparse (f/formatter &amp;#34;d&amp;#34;) my-time))) #&amp;#39;user/day user&amp;gt; (str day (day-suffix day) &amp;#34; &amp;#34; (f/unparse (f/formatter &amp;#34;MMMM yyyy&amp;#34;) my-time)) &amp;#34;29th June 2011&amp;#34; </description>
    </item>
    
    <item>
      <title>Clojure: Not so lazy sequences a.k.a chunking behaviour</title>
      <link>https://markhneedham.com/blog/2014/04/06/clojure-not-so-lazy-sequences-a-k-a-chunking-behaviour/</link>
      <pubDate>Sun, 06 Apr 2014 22:07:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/06/clojure-not-so-lazy-sequences-a-k-a-chunking-behaviour/</guid>
      <description>&amp;gt; (take 1 (map (fn [x] (println (str &amp;#34;printing...&amp;#34; x))) (range))) (printing...0 printing...1 printing...2 printing...3 printing...4 printing...5 printing...6 printing...7 printing...8 printing...9 printing...10 printing...11 printing...12 printing...13 printing...14 printing...15 printing...16 printing...17 printing...18 printing...19 printing...20 printing...21 printing...22 printing...23 printing...24 printing...25 printing...26 printing...27 printing...28 printing...29 printing...30 printing...31 nil) (defn unchunk [s] (when (seq s) (lazy-seq (cons (first s) (unchunk (next s)))))) &amp;gt; (take 1 (map (fn [x] (println (str &amp;#34;printing...&amp;#34; x))) (unchunk (range)))) (printing...0 nil) </description>
    </item>
    
    <item>
      <title>Elo Rating System: Ranking Champions League teams using Clojure Part 2</title>
      <link>https://markhneedham.com/blog/2013/09/30/elo-rating-system-ranking-champions-league-teams-using-clojure-part-2/</link>
      <pubDate>Mon, 30 Sep 2013 20:26:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/30/elo-rating-system-ranking-champions-league-teams-using-clojure-part-2/</guid>
      <description>(ns ranking-algorithms.uefa (:require [clj-time.format :as f]) (:require [clojure.data.json :as json])) (defn as-date [date-field] (f/parse (f/formatter &amp;#34;dd MMM YYYY&amp;#34;) date-field )) (defn date-aware-value-reader [key value] (if (= key :date) (as-date value) value)) (defn read-from-file [file] (json/read-str (slurp file) :value-fn date-aware-value-reader :key-fn keyword)) &amp;gt; (def the-matches (read-from-file &amp;#34;data/cl-matches-2013.json&amp;#34;)) #&amp;#39;ranking-algorithms.uefa/the-matches &amp;gt; (count the-matches) 213 (comment &amp;#34;other functions excluded for brevity&amp;#34;) (defn format-for-printing [all-matches idx [team ranking &amp;amp; [rd]]] (let [team-matches (show-matches team all-matches)] (merge {:rank (inc idx) :team team :ranking ranking :rd rd :round (performance team-matches)} (match-record team-matches)))) (defn print-top-teams ([number all-matches] (print-top-teams number all-matches {})) ([number all-matches base-rankings] (clojure.</description>
    </item>
    
    <item>
      <title>Clojure: Writing JSON to a file - &#34;Exception Don&#39;t know how to write JSON of class org.joda.time.DateTime&#34;</title>
      <link>https://markhneedham.com/blog/2013/09/26/clojure-writing-json-to-a-file-exception-dont-know-how-to-write-json-of-class-org-joda-time-datetime/</link>
      <pubDate>Thu, 26 Sep 2013 19:11:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/26/clojure-writing-json-to-a-file-exception-dont-know-how-to-write-json-of-class-org-joda-time-datetime/</guid>
      <description>(ns json-date-example (:require [clj-time.format :as f]) (:require [clojure.data.json :as json])) (defn as-date [date-field] (f/parse (f/formatter &amp;#34;dd MMM YYYY&amp;#34;) date-field )) (def my-date (as-date &amp;#34;18 Mar 2012&amp;#34;)) &amp;gt; (json/write-str {:date my-date)}) java.lang.Exception: Don&amp;#39;t know how to write JSON of class org.joda.time.DateTime at clojure.data.json$write_generic.invoke (json.clj:367) clojure.data.json$eval2818$fn__2819$G__2809__2826.invoke (json.clj:284) clojure.data.json$write_object.invoke (json.clj:333) clojure.data.json$eval2818$fn__2819$G__2809__2826.invoke (json.clj:284) clojure.data.json$write.doInvoke (json.clj:450) clojure.lang.RestFn.invoke (RestFn.java:425) (defn as-date-string [date] (f/unparse (f/formatter &amp;#34;dd MMM YYYY&amp;#34;) date)) (defn date-aware-value-writer [key value] (if (= key :date) (as-date-string value) value)) &amp;gt; (json/write-str {:date my-date} :value-fn date-aware-value-writer) &amp;#34;{\&amp;#34;date\&amp;#34;:\&amp;#34;18 Mar 2012\&amp;#34;}&amp;#34; (defn date-aware-value-reader [key value] (if (= key :date) (as-date value) value)) &amp;gt; (json/read-str &amp;#34;{\&amp;#34;date\&amp;#34;:\&amp;#34;18 Mar 2012\&amp;#34;}&amp;#34; :value-fn date-aware-value-reader :key-fn keyword) {:date #&amp;lt;DateTime 2012-03-18T00:00:00.</description>
    </item>
    
    <item>
      <title>Clojure: Writing JSON to a file/reading JSON from a file</title>
      <link>https://markhneedham.com/blog/2013/09/26/clojure-writing-json-to-a-filereading-json-from-a-file/</link>
      <pubDate>Thu, 26 Sep 2013 07:47:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/26/clojure-writing-json-to-a-filereading-json-from-a-file/</guid>
      <description>&amp;gt; (require &amp;#39;[clojure.data.json :as json]) nil &amp;gt; (json/write-str { :key1 &amp;#34;val1&amp;#34; :key2 &amp;#34;val2&amp;#34; }) &amp;#34;{\&amp;#34;key2\&amp;#34;:\&amp;#34;val2\&amp;#34;,\&amp;#34;key1\&amp;#34;:\&amp;#34;val1\&amp;#34;}&amp;#34; &amp;gt; (use &amp;#39;clojure.java.io) &amp;gt; (with-open [wrtr (writer &amp;#34;/tmp/test.json&amp;#34;)] (.write wrtr (json/write-str {:key1 &amp;#34;val1&amp;#34; :key2 &amp;#34;val2&amp;#34;}))) &amp;gt; (spit &amp;#34;/tmp/test.json&amp;#34; (json/write-str {:key1 &amp;#34;val1&amp;#34; :key2 &amp;#34;val2&amp;#34;})) &amp;gt; (json/read-str (slurp &amp;#34;/tmp/test.json&amp;#34;)) {&amp;#34;key2&amp;#34; &amp;#34;val2&amp;#34;, &amp;#34;key1&amp;#34; &amp;#34;val1&amp;#34;} &amp;gt; (defn string-keys-to-symbols [map] (reduce #(assoc %1 (-&amp;gt; (key %2) keyword) (val %2)) {} map)) &amp;gt; (string-keys-to-symbols (json/read-str (slurp &amp;#34;/tmp/test.json&amp;#34;))) {:key1 &amp;#34;val1&amp;#34;, :key2 &amp;#34;val2&amp;#34;} &amp;gt; (json/read-str (slurp &amp;#34;/tmp/test.</description>
    </item>
    
    <item>
      <title>Clojure: Anonymous functions using short notation and the &#39;ArityException Wrong number of args (0) passed to: PersistentVector&#39;</title>
      <link>https://markhneedham.com/blog/2013/09/23/clojure-anonymous-functions-using-short-notation-and-the-arityexception-wrong-number-of-args-0-passed-to-persistentvector/</link>
      <pubDate>Mon, 23 Sep 2013 21:42:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/23/clojure-anonymous-functions-using-short-notation-and-the-arityexception-wrong-number-of-args-0-passed-to-persistentvector/</guid>
      <description>&amp;gt; ((fn [x] [1 2 x]) 6) [1 2 6] &amp;gt; (#([1 2 %]) 6) clojure.lang.ArityException: Wrong number of args (0) passed to: PersistentVector AFn.java:437 clojure.lang.AFn.throwArity AFn.java:35 clojure.lang.AFn.invoke NO_SOURCE_FILE:1 user/eval575[fn] NO_SOURCE_FILE:1 user/eval575 #() becomes (fn [arg1 arg2] (...)) #(([1 2 %]) 6) becomes ((fn [arg] ([1 2 arg])) 6) &amp;gt; ([1 2 6] 2) 6 &amp;gt; (#(identity [1 2 %]) 6) [1 2 6] &amp;gt; (#(-&amp;gt; [1 2 %]) 6) [1 2 6] </description>
    </item>
    
    <item>
      <title>Clojure/Emacs/nrepl: Stacktrace-less error messages</title>
      <link>https://markhneedham.com/blog/2013/09/22/clojureemacsnrepl-stacktrace-less-error-messages/</link>
      <pubDate>Sun, 22 Sep 2013 23:07:04 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/22/clojureemacsnrepl-stacktrace-less-error-messages/</guid>
      <description>&amp;gt; (update-in {} [:mark] inc) NullPointerException clojure.lang.Numbers.ops (Numbers.java:942) ~/.emacs.d/init.el(setq nrepl-popup-stacktraces nil) (setq nrepl-popup-stacktraces-in-repl t) &amp;gt; (update-in {} [:mark] inc) java.lang.NullPointerException: Numbers.java:942 clojure.lang.Numbers.ops Numbers.java:110 clojure.lang.Numbers.inc core.clj:863 clojure.core/inc AFn.java:161 clojure.lang.AFn.applyToHelper AFn.java:151 clojure.lang.AFn.applyTo core.clj:603 clojure.core/apply core.clj:5472 clojure.core/update-in RestFn.java:445 clojure.lang.RestFn.invoke NO_SOURCE_FILE:1 user/eval9 ... &amp;gt; (inc nil) java.lang.NullPointerException: Numbers.java:942 clojure.lang.Numbers.ops Numbers.java:110 clojure.lang.Numbers.inc NO_SOURCE_FILE:1 user/eval14 ... </description>
    </item>
    
    <item>
      <title>Clojure/Emacs/nrepl: Ctrl X &#43; Ctrl E leads to &#39;FileNotFoundException Could not locate […] on classpath&#39;</title>
      <link>https://markhneedham.com/blog/2013/09/22/clojureemacsnrepl-ctrl-x-ctrl-e-leads-to-filenotfoundexception-could-not-locate-on-classpath/</link>
      <pubDate>Sun, 22 Sep 2013 21:23:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/22/clojureemacsnrepl-ctrl-x-ctrl-e-leads-to-filenotfoundexception-could-not-locate-on-classpath/</guid>
      <description>FileNotFoundException Could not locate ranking_algorithms/ranking__init.class or ranking_algorithms/ranking.clj on classpath: clojure.lang.RT.load (RT.java:432) $ lein repl nREPL server started on port 52265 REPL-y 0.1.0-beta10 Clojure 1.4.0 Exit: Control+D or (exit) or (quit) Commands: (user/help) Docs: (doc function-name-here) (find-doc &amp;#34;part-of-name-here&amp;#34;) Source: (source function-name-here) (user/sourcery function-name-here) Javadoc: (javadoc java-object-or-class-here) Examples from clojuredocs.org: [clojuredocs or cdoc] (user/clojuredocs name-here) (user/clojuredocs &amp;#34;ns-here&amp;#34; &amp;#34;name-here&amp;#34;) </description>
    </item>
    
    <item>
      <title>Clojure: Stripping all the whitespace</title>
      <link>https://markhneedham.com/blog/2013/09/22/clojure-stripping-all-the-whitespace/</link>
      <pubDate>Sun, 22 Sep 2013 18:54:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/22/clojure-stripping-all-the-whitespace/</guid>
      <description>(def word &amp;#34; with a little bit of space we can make it through the night &amp;#34;) &amp;gt; (clojure.string/trim word) &amp;#34;with a little bit of space we can make it through the night&amp;#34; &amp;gt; (clojure.string/join &amp;#34; &amp;#34; (filter #(not (clojure.string/blank? %)) (clojure.string/split word #&amp;#34; &amp;#34;))) &amp;#34;with a little bit of space we can make it through the night&amp;#34; &amp;gt; (-&amp;gt;&amp;gt; (clojure.string/split word #&amp;#34; &amp;#34;) (filter #(not (clojure.string/blank? %))) (clojure.string/join &amp;#34; &amp;#34;)) &amp;#34;with a little bit of space we can make it through the night&amp;#34; (defn split-on-space [word] (clojure.</description>
    </item>
    
    <item>
      <title>Clojure: Converting an array/set into a hash map</title>
      <link>https://markhneedham.com/blog/2013/09/20/clojure-converting-an-arrayset-into-a-hash-map/</link>
      <pubDate>Fri, 20 Sep 2013 21:13:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/20/clojure-converting-an-arrayset-into-a-hash-map/</guid>
      <description>(def teams #{ &amp;#34;Man Utd&amp;#34; &amp;#34;Man City&amp;#34; &amp;#34;Arsenal&amp;#34; &amp;#34;Chelsea&amp;#34;}) Man Utd -&amp;gt; {:points 1200} Man City -&amp;gt; {:points 1200} Arsenal -&amp;gt; {:points 1200} Chelsea -&amp;gt; {:points 1200} &amp;gt; (mapcat (fn [x] [x {:points 1200}]) teams) (&amp;#34;Chelsea&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1200} &amp;#34;Arsenal&amp;#34; {:points 1200} &amp;#34;Man Utd&amp;#34; {:points 1200}) &amp;gt; (array-map &amp;#34;Chelsea&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1200} &amp;#34;Arsenal&amp;#34; {:points 1200} &amp;#34;Man Utd&amp;#34; {:points 1200}) (&amp;#34;Chelsea&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1200} &amp;#34;Arsenal&amp;#34; {:points 1200} &amp;#34;Man Utd&amp;#34; {:points 1200}) &amp;gt; (apply array-map [&amp;#34;Chelsea&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1200} &amp;#34;Arsenal&amp;#34; {:points 1200} &amp;#34;Man Utd&amp;#34; {:points 1200}]) {&amp;#34;Chelsea&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Man Utd&amp;#34; {:points 1200}} &amp;gt; (apply array-map (mapcat (fn [x] [x {:points 1200}]) teams)) {&amp;#34;Man Utd&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Chelsea&amp;#34; {:points 1200}} &amp;gt; (mapcat vector teams (repeat {:points 1200})) (&amp;#34;Chelsea&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1200} &amp;#34;Arsenal&amp;#34; {:points 1200} &amp;#34;Man Utd&amp;#34; {:points 1200}) &amp;gt; (apply array-map (mapcat vector teams (repeat {:points 1200}))) {&amp;#34;Chelsea&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Man Utd&amp;#34; {:points 1200}} &amp;gt; (apply assoc {} (mapcat vector teams (repeat {:points 1200}))) {&amp;#34;Man Utd&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Chelsea&amp;#34; {:points 1200}} &amp;gt; (into {} [[&amp;#34;Chelsea&amp;#34; {:points 1200}] [&amp;#34;Man City&amp;#34; {:points 1200}] [&amp;#34;Arsenal&amp;#34; {:points 1200}] [&amp;#34;Man Utd&amp;#34; {:points 1200}] ]) &amp;gt; (into {} (map vector teams (repeat {:points 1200}))) {&amp;#34;Chelsea&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Man Utd&amp;#34; {:points 1200}} &amp;gt; (zipmap teams (repeat {:points 1200})) {&amp;#34;Man Utd&amp;#34; {:points 1200}, &amp;#34;Arsenal&amp;#34; {:points 1200}, &amp;#34;Man City&amp;#34; {:points 1200}, &amp;#34;Chelsea&amp;#34; {:points 1200}} </description>
    </item>
    
    <item>
      <title>Clojure: Converting a string to a date</title>
      <link>https://markhneedham.com/blog/2013/09/20/clojure-converting-a-string-to-a-date/</link>
      <pubDate>Fri, 20 Sep 2013 07:00:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/20/clojure-converting-a-string-to-a-date/</guid>
      <description>project.clj(defproject ranking-algorithms &amp;#34;0.1.0-SNAPSHOT&amp;#34; :license {:name &amp;#34;Eclipse Public License&amp;#34; :url &amp;#34;http://www.eclipse.org/legal/epl-v10.html&amp;#34;} :dependencies [[org.clojure/clojure &amp;#34;1.4.0&amp;#34;] [clj-time &amp;#34;0.6.0&amp;#34;]]) &amp;gt; (require &amp;#39;(clj-time [format :as f])) (def string-date &amp;#34;18 September 2012&amp;#34;) &amp;gt; (f/show-formatters) ... :hour-minute 06:45 :hour-minute-second 06:45:22 :hour-minute-second-fraction 06:45:22.473 :hour-minute-second-ms 06:45:22.473 :mysql 2013-09-20 06:45:22 :ordinal-date 2013-263 :ordinal-date-time 2013-263T06:45:22.473Z :ordinal-date-time-no-ms 2013-263T06:45:22Z :rfc822 Fri, 20 Sep 2013 06:45:22 +0000 ... &amp;gt; (f/parse (f/formatter &amp;#34;dd MMM YYYY&amp;#34;) string-date) #&amp;lt;DateTime 2012-09-18T00:00:00.000Z&amp;gt; </description>
    </item>
    
    <item>
      <title>Clojure: See every step of a reduce</title>
      <link>https://markhneedham.com/blog/2013/09/19/clojure-see-every-step-of-a-reduce/</link>
      <pubDate>Thu, 19 Sep 2013 23:57:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/19/clojure-see-every-step-of-a-reduce/</guid>
      <description>&amp;gt; (reduce + 0 (range 1 11)) 55 &amp;gt; (reductions + 0 (range 1 11)) (0 1 3 6 10 15 21 28 36 45 55) (def initial-team-rankings { &amp;#34;Man Utd&amp;#34; {:points 1200} &amp;#34;Man City&amp;#34; {:points 1300}}) (defn update-team-rankings [teams year] (reduce (fn [ts [team _]] (update-in ts [team :points] inc)) teams teams)) &amp;gt; (reduce update-team-rankings initial-team-rankings (range 2004 2013)) {&amp;#34;Man City&amp;#34; {:points 1309}, &amp;#34;Man Utd&amp;#34; {:points 1209}} &amp;gt; (nth (reductions update-team-rankings initial-team-rankings (range 2004 2013)) 3) {&amp;#34;Man City&amp;#34; {:points 1303}, &amp;#34;Man Utd&amp;#34; {:points 1203}} (def final-rankings (zipmap (range 2003 2013) (reductions update-team-rankings initial-team-rankings (range 2004 2013)))) &amp;gt; (get final-rankings 2006) {&amp;#34;Man City&amp;#34; {:points 1303}, &amp;#34;Man Utd&amp;#34; {:points 1203}} </description>
    </item>
    
    <item>
      <title>Clojure: Merge two maps but only keep the keys of one of them</title>
      <link>https://markhneedham.com/blog/2013/09/17/clojure-merge-two-maps-but-only-keep-the-keys-of-one-of-them/</link>
      <pubDate>Tue, 17 Sep 2013 01:03:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/17/clojure-merge-two-maps-but-only-keep-the-keys-of-one-of-them/</guid>
      <description>&amp;gt; (merge {&amp;#34;Man. United&amp;#34; 1500 &amp;#34;Man. City&amp;#34; 1400} {&amp;#34;Man. United&amp;#34; 1550 &amp;#34;Arsenal&amp;#34; 1450}) {&amp;#34;Arsenal&amp;#34; 1450, &amp;#34;Man. United&amp;#34; 1550, &amp;#34;Man. City&amp;#34; 1400} (defn merge-rankings [initial-rankings override-rankings] (merge initial-rankings (into {} (filter #(contains? initial-rankings (key %)) override-rankings)))) &amp;gt; (merge-rankings {&amp;#34;Man. United&amp;#34; 1500 &amp;#34;Man. City&amp;#34; 1400} {&amp;#34;Man. United&amp;#34; 1550 &amp;#34;Arsenal&amp;#34; 1450}) {&amp;#34;Man. United&amp;#34; 1550, &amp;#34;Man. City&amp;#34; 1400} (defn merge-rankings [initial-rankings override-rankings] (select-keys (merge initial-rankings override-rankings) (map key initial-rankings))) (defn merge-rankings [initial-rankings override-rankings] (select-keys (merge initial-rankings override-rankings) (keys initial-rankings))) (defn merge-keep-left [left right] (select-keys (merge left right) (keys left))) </description>
    </item>
    
    <item>
      <title>Clojure: Updating keys in a map</title>
      <link>https://markhneedham.com/blog/2013/09/17/clojure-updating-keys-in-a-map/</link>
      <pubDate>Tue, 17 Sep 2013 00:24:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/17/clojure-updating-keys-in-a-map/</guid>
      <description>(def teams { &amp;#34;Man. United&amp;#34; {:points 1500 :rd 350} &amp;#34;Man. City&amp;#34; {:points 1450 :rd 300} }) &amp;gt; (update-in teams [&amp;#34;Man. United&amp;#34; :points] inc) {&amp;#34;Man. United&amp;#34; {:points 1501, :rd 350}, &amp;#34;Man. City&amp;#34; {:points 1450, :rd 300}} &amp;gt; (assoc-in teams [&amp;#34;Man. United&amp;#34; :points] 1) {&amp;#34;Man. United&amp;#34; {:points 1, :rd 350}, &amp;#34;Man. City&amp;#34; {:points 1450, :rd 300}} (-&amp;gt; teams (assoc-in [&amp;#34;Man. United&amp;#34; :points] 1600) (assoc-in [&amp;#34;Man. United&amp;#34; :rd] 200)) {&amp;#34;Man. United&amp;#34; {:points 1600, :rd 200}, &amp;#34;Man.</description>
    </item>
    
    <item>
      <title>Clojure: All things regex</title>
      <link>https://markhneedham.com/blog/2013/09/14/clojure-all-things-regex/</link>
      <pubDate>Sat, 14 Sep 2013 01:24:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/14/clojure-all-things-regex/</guid>
      <description>Real Madrid-Juventus Turijn 2 - 1 53’Nedved 0-1, 66&amp;#39;Xavi Hernández 1-1, 114’Zalayeta 1-2 [a-zA-Z\s]+-[a-zA-Z\s]+ [0-9][\s]?.[\s]?[0-9] (defn recognise-match? [row] (not (clojure.string/blank? (re-matches #&amp;#34;[a-zA-Z\s]+-[a-zA-Z\s]+ [0-9][\s]?.[\s]?[0-9]&amp;#34; row)))) &amp;gt; (recognise-match? &amp;#34;Real Madrid-Juventus Turijn 2 - 1&amp;#34;) true &amp;gt; (recognise-match? &amp;#34;53’Nedved 0-1, 66&amp;#39;Xavi Hernández 1-1, 114’Zalayeta 1-2&amp;#34;) false &amp;gt; (recognise-match? &amp;#34;Real Madrid-Juventus Turijn 2 - 1 abc&amp;#34;) false (defn recognise-match? [row] (not (clojure.string/blank? (re-find #&amp;#34;[a-zA-Z\s]+-[a-zA-Z\s]+ [0-9][\s]?.[\s]?[0-9]&amp;#34; row)))) &amp;gt; (recognise-match? &amp;#34;Real Madrid-Juventus Turijn 2 - 1 abc&amp;#34;) true &amp;gt; (first (re-seq #&amp;#34;([a-zA-Z\s]+)-([a-zA-Z\s]+) ([0-9])[\s]?</description>
    </item>
    
    <item>
      <title>Elo Rating System: Ranking Champions League teams using Clojure</title>
      <link>https://markhneedham.com/blog/2013/08/31/elo-rating-system-ranking-champions-league-teams-using-clojure/</link>
      <pubDate>Sat, 31 Aug 2013 13:01:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/31/elo-rating-system-ranking-champions-league-teams-using-clojure/</guid>
      <description>(defn ranking-after-win [{ ranking :ranking opponent-ranking :opponent-ranking importance :importance}] (+ ranking (* importance (- 1 (expected ranking opponent-ranking) )))) (defn ranking-after-loss [{ ranking :ranking opponent-ranking :opponent-ranking importance :importance}] (+ ranking (* importance (- 0 (expected ranking opponent-ranking) )))) (defn expected [my-ranking opponent-ranking] (/ 1.0 (+ 1 (math/expt 10 (/ (- opponent-ranking my-ranking) 400))))) &amp;gt; (ranking-after-win { :ranking 1200 :opponent-ranking 1500 :importance 32 }) 1227.1686541692377 &amp;gt; (expected 1200 1500) 0.15097955721132328 (defn top-teams [number matches] (let [teams-with-rankings (apply array-map (mapcat (fn [x] [x {:points 1200}]) (extract-teams matches)))] (take number (sort-by (fn [x] (:points (val x))) &amp;gt; (seq (reduce process-match teams-with-rankings matches)))))) (defn process-match [ts match] (let [{:keys [home away home_score away_score]} match] (cond (&amp;gt; home_score away_score) (-&amp;gt; ts (update-in [home :points] #(ranking-after-win {:ranking % :opponent-ranking (:points (get ts away)) :importance 32})) (update-in [away :points] #(ranking-after-loss {:ranking % :opponent-ranking (:points (get ts home)) :importance 32}))) (&amp;gt; away_score home_score) (-&amp;gt; ts (update-in [home :points] #(ranking-after-loss {:ranking % :opponent-ranking (:points (get ts away)) :importance 32})) (update-in [away :points] #(ranking-after-win {:ranking % :opponent-ranking (:points (get ts home)) :importance 32}))) (= home_score away_score) ts))) &amp;gt; (take 5 all-matches) ({:home &amp;#34;Tampere&amp;#34;, :away &amp;#34;Pyunik Erewan&amp;#34;, :home_score 0, :away_score 4} {:home &amp;#34;Pyunik Erewan&amp;#34;, :away &amp;#34;Tampere&amp;#34;, :home_score 2, :away_score 0} {:home &amp;#34;Skonto Riga&amp;#34;, :away &amp;#34;Barry Town&amp;#34;, :home_score 5, :away_score 0} {:home &amp;#34;Barry Town&amp;#34;, :away &amp;#34;Skonto Riga&amp;#34;, :home_score 0, :away_score 1} {:home &amp;#34;Portadown&amp;#34;, :away &amp;#34;Belshina Bobruisk&amp;#34;, :home_score 0, :away_score 0}) &amp;gt; (extract-teams (take 5 all-matches)) #{&amp;#34;Portadown&amp;#34; &amp;#34;Tampere&amp;#34; &amp;#34;Pyunik Erewan&amp;#34; &amp;#34;Barry Town&amp;#34; &amp;#34;Skonto Riga&amp;#34;} &amp;gt; (mapcat (fn [x] [x {:points 1200}]) (extract-teams (take 5 all-matches))) (&amp;#34;Portadown&amp;#34; {:points 1200} &amp;#34;Tampere&amp;#34; {:points 1200} &amp;#34;Pyunik Erewan&amp;#34; {:points 1200} &amp;#34;Barry Town&amp;#34; {:points 1200} &amp;#34;Skonto Riga&amp;#34; {:points 1200}) &amp;gt; (apply array-map (mapcat (fn [x] [x {:points 1200}]) (extract-teams (take 5 all-matches)))) {&amp;#34;Portadown&amp;#34; {:points 1200}, &amp;#34;Tampere&amp;#34; {:points 1200}, &amp;#34;Pyunik Erewan&amp;#34; {:points 1200}, &amp;#34;Barry Town&amp;#34; {:points 1200}, &amp;#34;Skonto Riga&amp;#34; {:points 1200}} &amp;gt; (top-teams 10 all-matches) ([&amp;#34;CF Barcelona&amp;#34; {:points 1343.</description>
    </item>
    
    <item>
      <title>Clojure: Handling state by updating a vector inside an atom</title>
      <link>https://markhneedham.com/blog/2013/08/30/clojure-handling-state-by-updating-a-vector-inside-an-atom/</link>
      <pubDate>Fri, 30 Aug 2013 12:23:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/30/clojure-handling-state-by-updating-a-vector-inside-an-atom/</guid>
      <description>(def m [{:home &amp;#34;Manchester United&amp;#34;, :away &amp;#34;Manchester City&amp;#34;, :home_score 1, :away_score 0} {:home &amp;#34;Manchester United&amp;#34;, :away &amp;#34;Manchester City&amp;#34;, :home_score 2, :away_score 0}]) (def teams [ {:name &amp;#34;Manchester United&amp;#34; :points 1200} {:name &amp;#34;Manchester City&amp;#34; :points 1200} ]) (def t (atom teams)) &amp;gt; (map #(if (= &amp;#34;Manchester United&amp;#34; (:name %)) (assoc % :points 1500) %) teams) [{:name &amp;#34;Manchester United&amp;#34;, :points 1500} {:name &amp;#34;Manchester City&amp;#34;, :points 1200}] &amp;gt; (swap! t (fn [teams] (map #(if (= &amp;#34;Manchester United&amp;#34; (:name %)) (assoc % :points 1500) %) teams))) ({:name &amp;#34;Manchester United&amp;#34;, :points 1500} {:name &amp;#34;Manchester City&amp;#34;, :points 1200}) &amp;gt; @t [{:name &amp;#34;Manchester United&amp;#34;, :points 1500} {:name &amp;#34;Manchester City&amp;#34;, :points 1200}] (defn update-teams [teams team1 new-score1 team2 new-score2] (vec (map #(cond (= team1 (:name %)) (assoc % :points new-score1) (= team2 (:name %)) (assoc % :points new-score2) :else %) teams))) &amp;gt; (map (fn [match] (swap!</description>
    </item>
    
    <item>
      <title>Clojure/Enlive: Screen scraping a HTML file from disk</title>
      <link>https://markhneedham.com/blog/2013/08/26/clojureenlive-screen-scraping-a-html-file-from-disk/</link>
      <pubDate>Mon, 26 Aug 2013 17:58:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/26/clojureenlive-screen-scraping-a-html-file-from-disk/</guid>
      <description>$ pwd /tmp/football $ wget http://www.rsssf.com/ec/ec200203det.html (ns ranking-algorithms.parse (:use [net.cgrand.enlive-html])) (defn fetch-page [file-path] (html-resource (java.io.StringReader. (slurp file-path)))) (defn matches [file] (-&amp;gt;&amp;gt; file fetch-page extract-rows (map extract-content) (filter recognise-match?))) (defn extract-rows [page] (select page [:div.Section1 :p :span])) (defn extract-content [row] (first (get row :content))) (defn recognise-match? [row] (and (string? row) (re-matches #&amp;#34;[a-zA-Z\s]+-[a-zA-Z\s]+ [0-9][\s]?.[\s]?[0-9]&amp;#34; row))) &amp;gt; (matches &amp;#34;/tmp/football/ec200203det.html&amp;#34;) ( ... &amp;#34;Lokomotiv\nMoskou-Borussia Dortmund 1 - 2&amp;#34; &amp;#34;Borussia\nDortmund-AC Milan 0 - 1&amp;#34; &amp;#34;Real\nMadrid-Lokomotiv Moskou 2 - 2&amp;#34; &amp;#34;Real\nMadrid-Borussia Dortmund 2 - 1&amp;#34; &amp;#34;AC Milan-Lokomotiv\nMoskou 1 - 0&amp;#34; &amp;#34;Borussia Dortmund-Real\nMadrid 1 - 1&amp;#34; &amp;#34;Lokomotiv\nMoskou-AC Milan 0 - 1&amp;#34; .</description>
    </item>
    
    <item>
      <title>clojure/Java Interop: The doto macro</title>
      <link>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-the-doto-macro/</link>
      <pubDate>Sun, 17 Mar 2013 20:21:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-the-doto-macro/</guid>
      <description>(doto (new java.util.HashMap) (.put &amp;#34;a&amp;#34; 1) (.put &amp;#34;b&amp;#34; 2)) -&amp;gt; {a=1, b=2} (defn create-stadium-node [db line] (let [stadium-node (.. db createNode)] (.. stadium-node (setProperty &amp;#34;wkt&amp;#34; (format &amp;#34;POINT(%s %s)&amp;#34; (:long line) (:lat line)))) (.. stadium-node (setProperty &amp;#34;name&amp;#34; (:stadium line))) stadium-node)) (defn create-stadium-node [db line] (doto (.. db createNode) (.setProperty &amp;#34;wkt&amp;#34; (format &amp;#34;POINT(%s %s)&amp;#34; (:long line) (:lat line))) (.setProperty &amp;#34;name&amp;#34; (:stadium line)))) # the end of our main function (.. tx success) (.</description>
    </item>
    
    <item>
      <title>clojure/Java Interop - Importing neo4j spatial data</title>
      <link>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-importing-neo4j-spatial-data/</link>
      <pubDate>Sun, 17 Mar 2013 18:56:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-importing-neo4j-spatial-data/</guid>
      <description>package main.java; // imports excluded  public class StadiumsImport { public static void main(String[] args) throws IOException { List&amp;lt;String&amp;gt; lines = readFile(&amp;#34;data/stadiums.csv&amp;#34;); EmbeddedGraphDatabase db = new EmbeddedGraphDatabase(&amp;#34;neo4j-community-1.9.M04/data/graph.db&amp;#34;); Index&amp;lt;Node&amp;gt; stadiumsIndex = createSpatialIndex(db, &amp;#34;stadiumsLocation&amp;#34;); Transaction tx = db.beginTx(); for (String stadium : lines) { String[] columns = stadium.split(&amp;#34;,&amp;#34;); Index&amp;lt;Node&amp;gt; teamsIndex = db.index().forNodes(&amp;#34;teams&amp;#34;); String team = columns[1].replaceAll(&amp;#34;\&amp;#34;&amp;#34;,&amp;#34;&amp;#34;); Node teamNode = teamsIndex.get(&amp;#34;name&amp;#34;, team).getSingle(); if(teamNode != null) { Node stadiumNode = db.createNode(); stadiumNode.setProperty(&amp;#34;wkt&amp;#34;, String.format(&amp;#34;POINT(%s %s)&amp;#34;, columns[4], columns[3])); stadiumNode.</description>
    </item>
    
    <item>
      <title>Clojure: Reading and writing a reasonably sized file</title>
      <link>https://markhneedham.com/blog/2013/01/11/clojure-reading-and-writing-a-reasonably-sized-file/</link>
      <pubDate>Fri, 11 Jan 2013 00:40:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/11/clojure-reading-and-writing-a-reasonably-sized-file/</guid>
      <description>(defn get-pixels [pix] (map #( Integer/parseInt %) pix)) (defn create-tuple [[ head &amp;amp; rem]] {:pixels (get-pixels rem) :label head}) (defn tuples [rows] (map create-tuple rows)) (defn parse-row [row] (map #(clojure.string/split % #&amp;#34;,&amp;#34;) row)) (defn read-raw [path n] (with-open [reader (clojure.java.io/reader path)] (vec (take n (rest (line-seq reader)))))) (def read-train-set-raw (partial read-raw &amp;#34;data/train.csv&amp;#34;)) (def parsed-rows (tuples (parse-row (read-train-set-raw 42000)))) (def dead-to-us-pixels [0 1 2 3 4 5 6 7 8 9 10 11 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 52 53 54 55 56 57 82 83 84 85 111 112 139 140 141 168 196 392 420 421 448 476 532 560 644 645 671 672 673 699 700 701 727 728 729 730 731 754 755 756 757 758 759 760 780 781 782 783]) (defn in?</description>
    </item>
    
    <item>
      <title>Clojure: Thread last (-&gt;&gt;) vs Thread first (-&gt;)</title>
      <link>https://markhneedham.com/blog/2012/11/06/clojure-thread-last-vs-thread-first/</link>
      <pubDate>Tue, 06 Nov 2012 12:42:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/11/06/clojure-thread-last-vs-thread-first/</guid>
      <description>In many of the Clojure examples that I&amp;rsquo;ve come across the thread last (-&amp;raquo;)macro is used to make it easier (for people from a non lispy background!) to see the transformations that the initial data structure is going through.
In one of my recent posts I showed how Jen &amp;amp; I had rewritten Mahout&amp;rsquo;s entropy function in Clojure:
(defn calculate-entropy [counts data-size] (-&amp;gt;&amp;gt; counts (remove #{0}) (map (partial individual-entropy data-size)) (reduce +))) Here we are using the thread last operator to first pass countsas the last argument of the removefunction on the next line, then to pass the result of that to the mapfunction on the next line and so on.</description>
    </item>
    
    <item>
      <title>Emacs/Clojure: Starting out with paredit</title>
      <link>https://markhneedham.com/blog/2012/10/31/emacsclojure-starting-out-with-paredit/</link>
      <pubDate>Wed, 31 Oct 2012 08:41:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/10/31/emacsclojure-starting-out-with-paredit/</guid>
      <description>I&amp;rsquo;ve been complaining recently to Jenand Bruceabout the lack of a beginner&amp;rsquo;s guide to emacs paredit modewhich seems to be the defacto approach for people working with Clojure and both pointed me to the paredit cheat sheet.
While it&amp;rsquo;s very comprehensive, I found that it&amp;rsquo;s a little overwhelming for a complete newbie like myself.
I therefore thought it&amp;rsquo;d be useful to write a bit about a couple of things that I&amp;rsquo;ve picked up from pairing with Jen on little bits of Clojure over the last couple of months.</description>
    </item>
    
    <item>
      <title>Clojure: Mahout&#39;s &#39;entropy&#39; function</title>
      <link>https://markhneedham.com/blog/2012/10/30/clojure-mahouts-entropy-function/</link>
      <pubDate>Tue, 30 Oct 2012 22:46:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/10/30/clojure-mahouts-entropy-function/</guid>
      <description>As I mentioned in a coupleof previous postsJenand I have been playing around with Mahout random forestsand for a few hours last week we spent some time looking through the code to see how it worked.
In particular we came across an entropy function which is used to determine how good a particular &amp;lsquo;split&amp;rsquo; point in a decision tree is going to be.
I quite like the following definition:
Information Theory (developed by Claude Shannon 1948) defines this value of uncertainty as entropy, a probability-based measure used to calculate the amount of uncertainty.</description>
    </item>
    
    <item>
      <title>Clojure: Casting to a Java class...or not!</title>
      <link>https://markhneedham.com/blog/2011/12/31/clojure-casting-to-a-java-class-or-not/</link>
      <pubDate>Sat, 31 Dec 2011 17:47:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/12/31/clojure-casting-to-a-java-class-or-not/</guid>
      <description>I have a bit of Java code for working out the final destination of a URLassuming that there might be one redirect which looks like this:
private String resolveUrl(String url) { try { HttpURLConnection con = (HttpURLConnection) (new URL(url).openConnection()); con.setInstanceFollowRedirects(false); con.connect(); int responseCode = con.getResponseCode(); if (String.valueOf(responseCode).startsWith(&amp;#34;3&amp;#34;)) { return con.getHeaderField(&amp;#34;Location&amp;#34;); } } catch (IOException e) { return url; } return url; } I need to cast to HttpURLConnectionon the first line so that I can make the call to setInstanceFollowRedirectswhich isn&amp;rsquo;t available on URLConnection.</description>
    </item>
    
    <item>
      <title>Leiningen: Using goose via a local Maven repository</title>
      <link>https://markhneedham.com/blog/2011/12/27/leiningen-using-goose-via-a-local-maven-repository/</link>
      <pubDate>Tue, 27 Dec 2011 12:48:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/12/27/leiningen-using-goose-via-a-local-maven-repository/</guid>
      <description>I&amp;rsquo;ve been playing around a little bit with goose- a HTML content/article extractor - originally in Java but later in clojure where I needed to work out how to include goose and all its dependencies via Leiningen.
goose isn&amp;rsquo;t included in a Maven repository so I needed to create a local repository, something which I&amp;rsquo;ve got stuck on in the past.
Luckily Paul Gross has written a cool blog postexplaining how his team got past this problem.</description>
    </item>
    
    <item>
      <title>XP Day: Visualizing what&#39;s happening on our project</title>
      <link>https://markhneedham.com/blog/2011/11/30/xp-day-visualizing-whats-happening-on-our-project/</link>
      <pubDate>Wed, 30 Nov 2011 02:25:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/11/30/xp-day-visualizing-whats-happening-on-our-project/</guid>
      <description>Another presentation that I gave at XP Day was one covering some visualisations Liz, Udayand I have created from various data we have about our project, gathered from Git, Go and Mingle.
These were some of the things that I learned from doing the presentation:
As a result it was necessary to scroll up and down/side to side when demonstrating each visualisationso that people could actually see them.
Either I need to work out how to get the resolution of the projector higher or be able to shrink the images to the right size so they&amp;rsquo;d fit more naturally.</description>
    </item>
    
    <item>
      <title>Clojure: Getting caught out by lazy collections</title>
      <link>https://markhneedham.com/blog/2011/07/31/clojure-getting-caught-out-by-lazy-collections/</link>
      <pubDate>Sun, 31 Jul 2011 21:40:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/07/31/clojure-getting-caught-out-by-lazy-collections/</guid>
      <description>Most of the work that I&amp;rsquo;ve done with Clojure has involved running a bunch of functions directly in the REPL or through Leiningen&amp;rsquo;s runtarget which led to me getting caught out when I created a JAR and tried to run that.
As I mentioned a few weeks agoI&amp;rsquo;ve been rewriting part of our system in Clojure to see how the design would differ and a couple of levels down the Clojure version comprises of applying a map function over a collection of documents.</description>
    </item>
    
    <item>
      <title>Clojure: Creating XML document with namespaces</title>
      <link>https://markhneedham.com/blog/2011/07/20/clojure-creating-xml-document-with-namespaces/</link>
      <pubDate>Wed, 20 Jul 2011 20:28:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/07/20/clojure-creating-xml-document-with-namespaces/</guid>
      <description>As I mentioned in an earlier post we&amp;rsquo;ve been parsing XML documents with the Clojure zip-filter APIand the next thing we needed to do was create a new XML document containing elements which needed to be inside a namespace.
We wanted to end up with a document which looked something like this:
&amp;lt;root&amp;gt; &amp;lt;mynamespace:foo xmlns:mynamespace=&amp;#34;http://www.magicalurlfornamespace.com&amp;#34;&amp;gt; &amp;lt;mynamespace:bar&amp;gt;baz&amp;lt;/mynamespace:bar&amp;gt; &amp;lt;/mynamespace:foo&amp;gt; &amp;lt;/root&amp;gt; We can make use of lazy-xml/emitto output an XML string from some sort of input?</description>
    </item>
    
    <item>
      <title>Clojure: Extracting child elements from an XML document with zip-filter</title>
      <link>https://markhneedham.com/blog/2011/07/16/clojure-extracting-child-elements-from-an-xml-document-with-zip-filter/</link>
      <pubDate>Sat, 16 Jul 2011 22:19:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/07/16/clojure-extracting-child-elements-from-an-xml-document-with-zip-filter/</guid>
      <description>I&amp;rsquo;ve been following Nurullah Akkaya&amp;rsquo;s blog postabout navigating XML documents using the Clojure zip-filterAPI and I came across an interesting problem in a document I&amp;rsquo;m parsing which goes beyond what&amp;rsquo;s covered in his post.
Nurullah provides a neat zip-strfunction which we can use to convert an XML string into a zipper object:
(require &amp;#39;[clojure.zip :as zip] &amp;#39;[clojure.xml :as xml]) (use &amp;#39;[clojure.contrib.zip-filter.xml]) (defn zip-str [s] (zip/xml-zip (xml/parse (java.io.ByteArrayInputStream. (.getBytes s))))) The fragment of the document I&amp;rsquo;m parsing looks like this:</description>
    </item>
    
    <item>
      <title>Clojure: Language as thought shaper</title>
      <link>https://markhneedham.com/blog/2011/07/10/clojure-language-as-thought-shaper/</link>
      <pubDate>Sun, 10 Jul 2011 22:21:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/07/10/clojure-language-as-thought-shaper/</guid>
      <description>I recently read an interesting article by Tom Van Cutsemwhere he describes some of the goals that influence the design of programming languages and one which stood out to me is that of viewing &amp;lsquo;language as a thought shaper&amp;rsquo;:
The goal of a thought shaper language is to change the way a programmer thinks about structuring his or her program.
I&amp;rsquo;ve been rewriting part of the current system that I&amp;rsquo;m working on in Clojure in my spare time to see how the design would differ and it&amp;rsquo;s interesting to see that it&amp;rsquo;s quite different.</description>
    </item>
    
    <item>
      <title>Clojure: Equivalent to Scala&#39;s flatMap/C#&#39;s SelectMany</title>
      <link>https://markhneedham.com/blog/2011/07/03/clojure-equivalent-to-scalas-flatmapcs-selectmany/</link>
      <pubDate>Sun, 03 Jul 2011 22:50:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2011/07/03/clojure-equivalent-to-scalas-flatmapcs-selectmany/</guid>
      <description>I&amp;rsquo;ve been playing around with Clojure a bit over the weekend and one thing I got stuck with was working out how to achieve the functionality provided by Scala&amp;rsquo;s flatMapor C#&amp;lsquo;s SelectManymethods on collections.
I had a collection of zip files and wanted to transform that into a collection of all the file entries in those files.
If we just use mapthen we&amp;rsquo;ll end up with a collection of collections which is more difficult to deal with going forward.</description>
    </item>
    
    <item>
      <title>Clojure: My first attempt at a macro</title>
      <link>https://markhneedham.com/blog/2009/12/12/clojure-my-first-attempt-at-a-macro/</link>
      <pubDate>Sat, 12 Dec 2009 03:53:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/12/12/clojure-my-first-attempt-at-a-macro/</guid>
      <description>I&amp;rsquo;m up to the chapter on using macros in Stuart Halloway&amp;rsquo;s &amp;lsquo;Programming Clojure&amp;rsquo; book and since I&amp;rsquo;ve never used a language which has macros in before I thought it&amp;rsquo;d be cool to write one.
In reality there&amp;rsquo;s no reason to create a macro to do what I want to do but I wanted to keep the example simple so I could try and understand exactly how macros work.
I want to create a macro which takes in one argument and then prints hello and the person&amp;rsquo;s name.</description>
    </item>
    
    <item>
      <title>Clojure: Forgetting the brackets</title>
      <link>https://markhneedham.com/blog/2009/12/12/clojure-forgetting-the-brackets/</link>
      <pubDate>Sat, 12 Dec 2009 03:51:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/12/12/clojure-forgetting-the-brackets/</guid>
      <description>I&amp;rsquo;ve been playing around with macros over the last few days and while writing a simple one forgot to include the brackets to make it evaluate correctly:
(defmacro say-hello [person] println &amp;#34;Hello&amp;#34; person) This macro doesn&amp;rsquo;t even expand like I thought it would:
user=&amp;gt; (macroexpand-1 &amp;#39;(say-hello blah)) blah That seemed a bit strange to me but I eventually realised that I&amp;rsquo;d missed off the brackets around &amp;lsquo;println&amp;rsquo; and the arguments following it which would have resulted in &amp;lsquo;println&amp;rsquo; being evaluated with those arguments.</description>
    </item>
    
    <item>
      <title>Clojure: when-let macro</title>
      <link>https://markhneedham.com/blog/2009/12/09/clojure-when-let-macro/</link>
      <pubDate>Wed, 09 Dec 2009 02:41:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/12/09/clojure-when-let-macro/</guid>
      <description>In my continued playing around with Clojure I came across the &amp;lsquo;when-let&amp;rsquo; macro.
&amp;lsquo;when-let&amp;rsquo; is used when we want to bind an expression to a symbol and only execute the body provided as the second argument to the macro if that symbol evaluates to true.
As I wrote previously, a value of &amp;lsquo;false&amp;rsquo; or &amp;lsquo;nil&amp;rsquo; would result in the second argument not being evaluated.
A simple example of using &amp;lsquo;when-let&amp;rsquo; would be:</description>
    </item>
    
    <item>
      <title>Clojure: Unit testing in the REPL</title>
      <link>https://markhneedham.com/blog/2009/12/06/clojure-unit-testing-in-the-repl/</link>
      <pubDate>Sun, 06 Dec 2009 03:28:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/12/06/clojure-unit-testing-in-the-repl/</guid>
      <description>One thing which I think is great about coding with F# is the quick feedback that we can get by defining and then testing out functions in the REPL.
We can do the same thing in Clojure but it&amp;rsquo;s even better because we can also define and run unit tests which I think is pretty neat.
Nurullah Akkaya has a good post which describes how to use clojure.test, a testing framework written by Stuart Sierraso I&amp;rsquo;ve been using that to define some tests cases for the little RSS feed parser that I&amp;rsquo;m writing.</description>
    </item>
    
    <item>
      <title>Clojure: Parsing an RSS feed</title>
      <link>https://markhneedham.com/blog/2009/11/30/clojure-parsing-an-rss-feed/</link>
      <pubDate>Mon, 30 Nov 2009 18:33:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/30/clojure-parsing-an-rss-feed/</guid>
      <description>I&amp;rsquo;ve been playing around with a little script in Clojure to parse the ThoughtWorks Blogs RSS feedand then create a tweet for each of them which contains a link to the blog post and the person&amp;rsquo;s Twitter ID if they have one.
It&amp;rsquo;s not finished yet but I&amp;rsquo;m finding the way that we parse documents like this in Clojure quite intriguing.
The xml to parse looks roughly like this:
&amp;lt;rss version=&amp;#34;2.</description>
    </item>
    
    <item>
      <title>Clojure: The &#39;apply&#39; function</title>
      <link>https://markhneedham.com/blog/2009/11/25/clojure-the-apply-function/</link>
      <pubDate>Wed, 25 Nov 2009 11:59:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/25/clojure-the-apply-function/</guid>
      <description>In my continued playing around with Clojure I came across the &amp;lsquo;apply&amp;rsquo; function which is used when we want to call another function with a number of arguments but have actually been given a single argument which contains the argument list.
The example that I&amp;rsquo;ve been trying to understand is applying &amp;lsquo;str&amp;rsquo; to a collection of values.
I started off with the following:
(str [1 2 3]) =&amp;gt; &amp;#34;[1 2 3]&amp;#34; This just returns the string representation of the vector that we passed it, but what we actually want is to get an output of &amp;ldquo;123&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Writing a Java function in Clojure</title>
      <link>https://markhneedham.com/blog/2009/11/23/writing-a-java-function-in-clojure/</link>
      <pubDate>Mon, 23 Nov 2009 20:08:20 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/23/writing-a-java-function-in-clojure/</guid>
      <description>A function that we had to write in Java on a project that I worked on recently needed to indicate whether there was a gap in a series of data points or not.
If there were gaps at the beginning or end of the sequence then that was fine but gaps in the middle of the sequence were not.
null, 1, 2, 3 =&amp;gt; no gaps 1, 2, 3, null =&amp;gt; no gaps 1, null, 2, 3 =&amp;gt; gaps The Java version looked a bit like this:</description>
    </item>
    
    <item>
      <title>Clojure: Checking for a nil value in a collection</title>
      <link>https://markhneedham.com/blog/2009/11/21/clojure-checking-for-a-nil-value-in-a-collection/</link>
      <pubDate>Sat, 21 Nov 2009 22:11:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/21/clojure-checking-for-a-nil-value-in-a-collection/</guid>
      <description>Something which I wanted to do recently was write a function that would indicate whether a collection contained a nil value.
I initially incorrectly thought the &amp;lsquo;contains?&amp;rsquo; function was the one that I wanted:
(contains? &amp;#39;(1 nil 2 3) nil) =&amp;gt; false I thought it would work the same as the Java equivalent but that function actually checks whether a key exists in a collection rather than a value. It&amp;rsquo;s more useful when dealing with maps.</description>
    </item>
    
    <item>
      <title>Clojure: A few things I&#39;ve been tripping up on</title>
      <link>https://markhneedham.com/blog/2009/11/20/clojure-a-few-things-ive-been-tripping-up-on/</link>
      <pubDate>Fri, 20 Nov 2009 13:11:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/20/clojure-a-few-things-ive-been-tripping-up-on/</guid>
      <description>In my continued playing with Clojure I&amp;rsquo;m noticing a few things that I keep getting confused about.
As I understand it if an expression is enclosed in parentheses then that means it will be evaluated as a function.
For example I spent quite a while trying to work out why the following code kept throwing a class cast exception:
(if (true) 1 0) If you run that code in the REPL you&amp;rsquo;ll get the following exception because &amp;lsquo;true&amp;rsquo; isn&amp;rsquo;t a function and therefore can&amp;rsquo;t be applied as such:</description>
    </item>
    
    <item>
      <title>Clojure: A first look at recursive functions</title>
      <link>https://markhneedham.com/blog/2009/11/17/clojure-a-first-look-at-recursive-functions/</link>
      <pubDate>Tue, 17 Nov 2009 11:10:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/11/17/clojure-a-first-look-at-recursive-functions/</guid>
      <description>I&amp;rsquo;m working through Stuart Halloway&amp;rsquo;s &amp;lsquo;Programming Clojure&amp;rsquo; book and I just got to the section where it first mentions recursive functions.
It&amp;rsquo;s a simple function to countdown from a given number to zero and then return that sequence.
This was one of the examples from the book:
(defn countdown [result x] (if (zero? x) result (recur (conj result x) (dec x)))) That function could then be called like this:
(countdown [] 5) I wanted to see what the function would look if we didn&amp;rsquo;t have the empty vector as a parameter.</description>
    </item>
    
  </channel>
</rss>