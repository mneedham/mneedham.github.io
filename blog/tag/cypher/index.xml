<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cypher on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/cypher/</link>
    <description>Recent content in cypher on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Sep 2019 00:47:00 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/cypher/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Graphing Brexit: Did the threat work?</title>
      <link>https://markhneedham.com/blog/2019/09/27/graphing-brexit-did-the-threat-work/</link>
      <pubDate>Fri, 27 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/27/graphing-brexit-did-the-threat-work/</guid>
      <description>Following on from the blog post where we compared how MPs and parties voted on Brexit indicative measures, in this post we&amp;#8217;re going to explore how Conservative MPs have voted with respect to a no deal exit from the European Union. In particular we&amp;#8217;d like to know whether the threat to have the party whip removed had an impact on how they voted in the recent motion to request an extension to work out a deal.</description>
    </item>
    
    <item>
      <title>Graphing Brexit: MPs vs Parties</title>
      <link>https://markhneedham.com/blog/2019/09/23/graphing-brexit-mps-vs-parties/</link>
      <pubDate>Mon, 23 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/23/graphing-brexit-mps-vs-parties/</guid>
      <description>In the previous post of the Graphing Brexit series we computed the average vote by party. In this post we&amp;#8217;re going to take those average party scores and compare them against the votes placed by individual MPs. The goal is to determine whether, Brexit wise, MPs are representing the right party!
 It won&amp;#8217;t be perfect since we know that not everyone in a party voted the same way, but it should still give us some fun results.</description>
    </item>
    
    <item>
      <title>Graphing Brexit: Plotting how the parties voted</title>
      <link>https://markhneedham.com/blog/2019/09/20/graphing-brexit-charting-how-the-parties-voted/</link>
      <pubDate>Fri, 20 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/20/graphing-brexit-charting-how-the-parties-voted/</guid>
      <description>Over the last week I&amp;#8217;ve revisited the Brexit Graph that I created in March 2019, this time looking at how the parties voted on average on each of the indicative votes.
 To recap, we have a graph that has the following schema:
   Since the initial post I&amp;#8217;ve slightly changed how the MEMBER_OF relationship works. As several MPs have switched MPs in the intervening months, we&amp;#8217;re now storing a start property to indicate when they started representing a party and an end property to indicate when they stopped representing a party.</description>
    </item>
    
    <item>
      <title>Neo4j: Approximate string matching/similarity</title>
      <link>https://markhneedham.com/blog/2019/09/18/neo4j-string-matching-similarity/</link>
      <pubDate>Wed, 18 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/18/neo4j-string-matching-similarity/</guid>
      <description>I&amp;#8217;ve been playing with the Brexit Graph over the last few days, and wanted to map the MPs that I got from CommonsVotes with data from the TheyWorkForYou API.
 I already had voting records loaded into Neo4j, but to recap, this is how I did that:
 UNWIND [655,656,657,658,659,660,661,662,711, 669, 668, 667, 666, 664] AS division LOAD CSV FROM &#34;https://github.com/mneedham/graphing-brexit/raw/master/data/commonsvotes/Division&#34; + division + &#34;.csv&#34; AS row // Create motion nodes WITH division, collect(row) AS rows MERGE (motion:Motion {division: trim(split(rows[0][0], &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: apoc.load.csv - Neo.ClientError.Statement.SyntaxError: Type mismatch: expected Float, Integer, Number or String but was Any </title>
      <link>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</link>
      <pubDate>Thu, 05 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</guid>
      <description>The Neo4j APOC library&#39;s Load CSV procedure is very useful if you want more control over the import process than the LOAD CSV clause allows. I found myself using it last week to import a CSV file of embeddings, because I wanted to know the line number of the row in the CSV file while importing the data.
 I had a file that looked like this, which I put into the import directory:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions vs OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</link>
      <pubDate>Fri, 23 Aug 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</guid>
      <description>While writing my previous post about Cypher nested path comprehensions, I realised that for this particular problem, the OPTIONAL MATCH clause is a better choice.
 To recap, we have the following graph:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;}) MERGE (club2)-[:IN_LEAGUE]-&amp;gt;(league2)     We started the post with the following query that returns (club)-[:IN_LEAGUE]&amp;#8594;(league)-[:IN_COUNTRY]&amp;#8594;(country) paths:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions</title>
      <link>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</link>
      <pubDate>Thu, 22 Aug 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</guid>
      <description>I&amp;#8217;ve recently been building an application using the GRANDstack, which uses nested Cypher path comprehensions to translate GraphQL queries to Cypher ones. I&amp;#8217;d not done this before, so I was quite curious how this feature worked. We&amp;#8217;ll explore it using the following dataset:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Conditional WHERE clause with APOC</title>
      <link>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</link>
      <pubDate>Wed, 31 Jul 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</guid>
      <description>Sometimes we want to be able to vary our Cypher queries based on the value of a parameter. I came across such a situation today, and thought I&amp;#8217;d share how I solved it using the APOC library.
 Let&amp;#8217;s first setup some sample data:
 UNWIND range(0, 5) AS id CREATE (:Person {name: &#34;person-&#34; + id})   Now, if we want to get all pairs of people, we could write the following query:</description>
    </item>
    
    <item>
      <title>Neo4j: keep/filter keys in a map using APOC</title>
      <link>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</link>
      <pubDate>Sun, 12 May 2019 17:58:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</guid>
      <description>In this post we&amp;#8217;ll learn how to write a Cypher query to create a node in Neo4j containing some of the keys from a map. This post assumes that the APOC library is installed.
 We&amp;#8217;ll start by creating a map that contains data from my twitter profile:
 :param document =&amp;gt; { id: 14707949, name: &#34;Mark Needham&#34;, username: &#34;markhneedham&#34;, bio: &#34;Developer Relations @neo4j&#34;, location: &#34;London, United Kingdom&#34;, url: &#34;http://www.markhneedham.com&#34;, join_date: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Delete all nodes</title>
      <link>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</link>
      <pubDate>Sun, 14 Apr 2019 12:52:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</guid>
      <description>When experimenting with a new database, at some stage we&amp;#8217;ll probably want to delete all our data and start again. I was trying to do this with Neo4j over the weekend and it didn&amp;#8217;t work as I expected, so I thought I&amp;#8217;d write the lessons I learned.
 We&amp;#8217;ll be using Neo4j via the Neo4j Desktop with the default settings. This means that we have a maximum heap size of 1GB.</description>
    </item>
    
    <item>
      <title>Neo4j: Delete/Remove dynamic properties</title>
      <link>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</link>
      <pubDate>Thu, 14 Mar 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</guid>
      <description>Irfan and I were playing with a dataset earlier today, and having run a bunch of graph algorithms, we had a lot of properties that we wanted to clear out.
 The following Cypher query puts Neo4j into the state that we were dealing with.
 CREATE (:Node {name: &#34;Mark&#34;, pagerank: 2.302, louvain: 1, lpa: 4 }) CREATE (:Node {name: &#34;Michael&#34;, degree: 23, triangles: 12, betweeness: 48.70 }) CREATE (:Node {name: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Date ranges</title>
      <link>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</link>
      <pubDate>Sun, 13 Jan 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</guid>
      <description>As part of a dataset I&amp;#8217;ve been working with this week, I wanted to generate a collection of a range of dates using the Cypher query language.
 I&amp;#8217;ve previously used the duration function, which lets you add (or subtract) from a specific date, so I thought I&amp;#8217;d start from there. If we want to find the day after 1st January 2019, we could write the following query:
 neo4j&amp;gt; WITH date(&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Remove consecutive duplicates from a list</title>
      <link>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</link>
      <pubDate>Sat, 12 Jan 2019 04:32:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</guid>
      <description>I was playing with a dataset this week and wanted to share how I removes duplicate consecutive elements from a list using the Cypher query language.
 For simplicity&amp;#8217;s sake, imagine that we have this list:
 neo4j&amp;gt; return [1,2,3,3,4,4,4,5,3] AS values; +-----------------------------+ | values | +-----------------------------+ | [1, 2, 3, 3, 4, 4, 4, 5, 3] | +-----------------------------+   We want to remove the duplicate 3&amp;#8217;s and 4&amp;#8217;s, such that our end result should be:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Grouping Datetimes</title>
      <link>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</link>
      <pubDate>Tue, 10 Jul 2018 04:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</guid>
      <description>In my continued analysis of Strava runs I wanted to try and find my best runs grouped by different time components, which was actually much easier than I was expecting.
 Importing the dataset If you want to try out the examples below you can execute the following LOAD CSV commands to load the data:
 LOAD CSV WITH HEADERS FROM &#34;https://github.com/mneedham/strava/raw/master/runs.csv&#34; AS row MERGE (run:Run {id: toInteger(row.id)}) SET run.distance = toFloat(row.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Syntax Error - Text cannot be parsed to a Duration (aka dealing with empty durations)</title>
      <link>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</link>
      <pubDate>Mon, 09 Jul 2018 18:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</guid>
      <description>As I continued with my travels with Neo4j 3.4&amp;#8217;s temporal data type I came across some fun edge cases when dealing with empty durations while importing data.
 Imagine we&amp;#8217;re trying to create 3 nodes from the following array of input data. Two of the rows have invalid durations!
 UNWIND [ {id: 12345, duration: &#34;PT2M20S&#34;}, {id: 12346, duration: &#34;&#34;}, {id: 12347, duration: null} ] AS row MERGE (run:Run {id: row.</description>
    </item>
    
    <item>
      <title>Neo4j: Querying the Strava Graph using Py2neo</title>
      <link>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</link>
      <pubDate>Fri, 15 Jun 2018 13:45:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</guid>
      <description>Last week Nigel released v4 of Py2neo and given I was just getting ready to write some queries against my Strava activity graph I thought I&amp;#8217;d give it a try.
 If you want to learn how to create your own Strava graph you should read my previous post, but just to recap, this is the graph model that we created:
   Let&amp;#8217;s get to it!
 tl;dr the code in this post is available as a Jupyter notebook so if you want the code and nothing but the code head over there!</description>
    </item>
    
    <item>
      <title>Neo4j: Building a graph of Strava activities</title>
      <link>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</guid>
      <description>In my last post I showed how to import activities from Strava&amp;#8217;s API into Neo4j using only the APOC library, but that was only part of the graph so I thought I&amp;#8217;d share the rest of what I&amp;#8217;ve done.
 The Graph Model In the previous post I showed how to import nodes with Run label, but there are some other pieces of data that I wanted to import as well.</description>
    </item>
    
    <item>
      <title>Neo4j APOC: Importing data from Strava&#39;s paginated JSON API</title>
      <link>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</link>
      <pubDate>Tue, 05 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</guid>
      <description>Over the weekend I&amp;#8217;ve been playing around with loading data from the Strava API into Neo4j and I started with the following Python script which creates a node with a Run label for each of my activities.
 If you want to follow along on your own data you&amp;#8217;ll need to get an API key via the &#39;My API Application&#39; section of the website. Once you&amp;#8217;ve got that put it in the TOKEN environment variable and you should be good to go.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Gotchas when working with Durations</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</link>
      <pubDate>Sun, 03 Jun 2018 20:11:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</guid>
      <description>Continuing with my explorations of Strava data in Neo4j I wanted to share some things I learnt while trying to work out my pace for certain distances.
 Before we get into the pace calculations let&amp;#8217;s first understand how the duration function works. If we run the following query we might expect to get back the same value that we put in&amp;#8230;&amp;#8203;
 RETURN duration({seconds: 413.77}).seconds AS seconds   ╒═════════╕ │&#34;</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Formatting instances of the Duration and Datetime date types</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</link>
      <pubDate>Sun, 03 Jun 2018 04:08:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</guid>
      <description>In my last blog post I showed how to compare instances of Neo4j&amp;#8217;s Duration data type, and in the middle of the post I realised that I needed to use the APOC library to return the value in the format I wanted. This was the solution I ended up with:
 WITH duration({seconds: 100}) AS duration RETURN apoc.text.lpad(toString(duration.minutes), 2, &#34;0&#34;) + &#34;:&#34; + apoc.text.lpad(toString(duration.secondsOfMinute), 2, &#34;0&#34;)   If we run that query this is the output:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Comparing durations</title>
      <link>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</link>
      <pubDate>Sat, 02 Jun 2018 03:24:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</guid>
      <description>Neo4j 3.4 saw the introduction of the temporal date type, which my colleague Adam Cowley covered in his excellent blog post, and in this post I want to share my experience using durations from my Strava runs.
 I&amp;#8217;ll show how to load the whole Strava dataset in another blog post but for now we&amp;#8217;ll just manually create some durations based on the elapsed time in seconds that Strava provides. We can run the following query to convert duration in seconds into the duration type:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Neo.ClientError.Statement.TypeError: Don&#39;t know how to add Double and String</title>
      <link>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</link>
      <pubDate>Wed, 14 Mar 2018 16:53:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</guid>
      <description>RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; ╒══════════╕ │&amp;quot;result&amp;quot; │ ╞══════════╡ │&amp;quot;1.0 Mark&amp;quot;│ └──────────┘ RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; Neo.ClientError.Statement.TypeError: Don&#39;t know how to add `Double(1.000000e+00)` and `String(&amp;quot; Mark&amp;quot;)` CYPHER 3.2 RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; AS result RETURN toString(toFloat(&amp;quot;1.0&amp;quot;)) + &amp;quot; Mark&amp;quot; AS result </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Property values can only be of primitive types or arrays thereof.</title>
      <link>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</link>
      <pubDate>Fri, 01 Dec 2017 22:09:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</guid>
      <description>CREATE (:Person {id: [1, &amp;quot;mark&amp;quot;, 2.0]}) Neo.ClientError.Statement.TypeError Property values can only be of primitive types or arrays thereof. CREATE (:Person {id: [value in [1, &amp;quot;mark&amp;quot;, 2.0] | toString(value)]}) Added 1 label, created 1 node, set 1 property, completed after 4 ms. </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Deleting duplicate nodes</title>
      <link>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</link>
      <pubDate>Fri, 06 Oct 2017 16:13:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</guid>
      <description>UNWIND range(0, 100) AS id CREATE (p1:Person {id: toInteger(rand() * id)}) MERGE (p2:Person {id: toInteger(rand() * id)}) MERGE (p3:Person {id: toInteger(rand() * id)}) MERGE (p4:Person {id: toInteger(rand() * id)}) CREATE (p1)-[:KNOWS]-&amp;gt;(p2) CREATE (p1)-[:KNOWS]-&amp;gt;(p3) CREATE (p1)-[:KNOWS]-&amp;gt;(p4) Added 173 labels, created 173 nodes, set 173 properties, created 5829 relationships, completed after 408 ms. MATCH (p:Person) WITH p.id as id, collect(p) AS nodes WHERE size(nodes) &amp;gt; 1 RETURN [ n in nodes | n.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Create Cypher map with dynamic keys</title>
      <link>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</link>
      <pubDate>Tue, 19 Sep 2017 19:30:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</guid>
      <description>WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN { dynamicKey: dynamicValue } AS map ╒══════════════════╕ │&amp;quot;map&amp;quot; │ ╞══════════════════╡ │{&amp;quot;dynamicKey&amp;quot;:&amp;quot;b&amp;quot;}│ └──────────────────┘ CALL dbms.functions() yield name, description WHERE name STARTS WITH &amp;quot;apoc.map.from&amp;quot; RETURN name, description ╒═════════════════════╤═════════════════════════════════════════════════════╕ │&amp;quot;name&amp;quot; │&amp;quot;description&amp;quot; │ ╞═════════════════════╪═════════════════════════════════════════════════════╡ │&amp;quot;apoc.map.fromLists&amp;quot; │&amp;quot;apoc.map.fromLists([keys],[values])&amp;quot; │ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromNodes&amp;quot; │&amp;quot;apoc.map.fromNodes(label, property)&amp;quot; │ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromPairs&amp;quot; │&amp;quot;apoc.map.fromPairs([[key,value],[key2,value2],...])&amp;quot;│ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromValues&amp;quot;│&amp;quot;apoc.map.fromValues([key1,value1,key2,value2,...])&amp;quot; │ └─────────────────────┴─────────────────────────────────────────────────────┘ WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN apoc.map.fromValues([dynamicKey, dynamicValue]) AS map ╒═════════╕ │&amp;quot;map&amp;quot; │ ╞═════════╡ │{&amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;}│ └─────────┘ WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN apoc.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding of floating point numbers/BigDecimals</title>
      <link>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</link>
      <pubDate>Sun, 13 Aug 2017 07:23:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</guid>
      <description>with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(rawNumeric) * 1000000 AS numeric ╒═════════════════╕ │&amp;quot;numeric&amp;quot; │ ╞═════════════════╡ │8369999.999999999│ └─────────────────┘ $ ls -lh plugins/ total 3664 -rw-r--r--@ 1 markneedham staff 1.8M 9 Aug 09:14 apoc-3.2.0.4-all.jar $ docker run -v $PWD/plugins:/plugins \  -p 7474:7474 \  -p 7687:7687 \  -e NEO4J_AUTH=&amp;#34;none&amp;#34; \  neo4j:3.2.3 with &amp;quot;8.37&amp;quot; as rawNumeric RETURN apoc.number.exact.mul(rawNumeric,&amp;quot;1000000&amp;quot;) AS apocConversion ╒════════════════╕ │&amp;quot;apocConversion&amp;quot;│ ╞════════════════╡ │&amp;quot;8370000.00&amp;quot; │ └────────────────┘ with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(apoc.</description>
    </item>
    
    <item>
      <title>Neo4j: Analysing a CSV file using LOAD CSV and Cypher</title>
      <link>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</link>
      <pubDate>Sun, 19 Feb 2017 22:39:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</guid>
      <description>$ cat ~/Downloads/youtube_stats_pW9boJoUxO0.csv Video IDs:, pW9boJoUxO0, Start time:, Wed Feb 15 08:57:55 2017, End time:, Wed Feb 15 10:03:10 2017 Playbacks, Peak concurrent viewers, Total view time (hours), Average session length (minutes) 348, 112, 97.125, 16.7456896552, Country code, AR, AT, BE, BR, BY, CA, CH, CL, CR, CZ, DE, DK, EC, EE, ES, FI, FR, GB, HU, IE, IL, IN, IT, LB, LU, LV, MY, NL, NO, NZ, PK, PL, QA, RO, RS, RU, SE, TR, US, VN, ZA Playbacks, 2, 2, 1, 14, 1, 10, 2, 1, 1, 1, 27, 1, 1, 1, 3, 1, 25, 54, 1, 4, 6, 8, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 1, 2, 6, 22, 1, 114, 1, 1 Peak concurrent viewers, 2, 1, 1, 4, 1, 5, 1, 1, 0, 0, 11, 1, 1, 1, 2, 1, 6, 25, 1, 3, 3, 2, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1, 1, 3, 7, 0, 44, 1, 0 Total view time (hours), 1.</description>
    </item>
    
    <item>
      <title>Neo4j: Find the midpoint between two lat/longs</title>
      <link>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</link>
      <pubDate>Mon, 31 Oct 2016 19:31:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</guid>
      <description>WITH 51.4931963543 AS lat1, -0.0475185810 AS lon1, 51.47908 AS lat2 , -0.05393950 AS lon2 WITH radians(lat1) AS rlat1, radians(lon1) AS rlon1, radians(lat2) AS rlat2, radians(lon2) AS rlon2, radians(lon2 - lon1) AS dLon WITH rlat1, rlon1, rlat2, rlon2, cos(rlat2) * cos(dLon) AS Bx, cos(rlat2) * sin(dLon) AS By WITH atan2(sin(rlat1) + sin(rlat2), sqrt( (cos(rlat1) + Bx) * (cos(rlat1) + Bx) + By * By )) AS lat3, rlon1 + atan2(By, cos(rlat1) + Bx) AS lon3 RETURN degrees(lat3) AS midLat, degrees(lon3) AS midLon ╒═════════════════╤═════════════════════╕ │midLat │midLon │ ╞═════════════════╪═════════════════════╡ │51.</description>
    </item>
    
    <item>
      <title>Neo4j: Create dynamic relationship type</title>
      <link>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</link>
      <pubDate>Sun, 30 Oct 2016 22:12:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</guid>
      <description>load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row RETURN row ╒═══════════════════════════════════════════════════════╕ │row │ ╞═══════════════════════════════════════════════════════╡ │{node1: Mark, node2: Reshmee, relationship: MARRIED_TO}│ ├───────────────────────────────────────────────────────┤ │{node1: Mark, node2: Alistair, relationship: FRIENDS} │ └───────────────────────────────────────────────────────┘ load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row MERGE (p1:Person {name: row.node1}) MERGE (p2:Person {name: row.node2}) FOREACH(ignoreMe IN CASE WHEN row.relationship = &amp;quot;MARRIED_TO&amp;quot; THEN [1] ELSE [] END | MERGE (p1)-[:MARRIED_TO]-&amp;gt;(p2)) FOREACH(ignoreMe IN CASE WHEN row.relationship = &amp;quot;FRIENDS&amp;quot; THEN [1] ELSE [] END | MERGE (p1)-[:FRIENDS]-&amp;gt;(p2)) load csv with headers from &amp;quot;file:///people.</description>
    </item>
    
    <item>
      <title>Neo4j: Procedure call inside a query does not support passing arguments implicitly (pass explicitly after procedure name instead)</title>
      <link>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</link>
      <pubDate>Sun, 02 Oct 2016 10:13:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</guid>
      <description>CALL db.labels ╒══════════╕ │label │ ╞══════════╡ │Airport │ ├──────────┤ │Flight │ ├──────────┤ │Airline │ ├──────────┤ │Movie │ ├──────────┤ │AirportDay│ ├──────────┤ │Person │ ├──────────┤ │Engineer │ └──────────┘ CALL db.labels YIELD label WITH label WHERE tolower(label) contains &amp;quot;a&amp;quot; RETURN label Procedure call inside a query does not support passing arguments implicitly (pass explicitly after procedure name instead) (line 1, column 9 (offset: 8)) &amp;#34;CALL db.labels&amp;#34; ^ CALL db.labels() YIELD label WITH label WHERE tolower(label) contains &amp;quot;a&amp;quot; RETURN label ╒══════════╕ │label │ ╞══════════╡ │Airport │ ├──────────┤ │Airline │ ├──────────┤ │AirportDay│ └──────────┘ </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Detecting duplicates using relationships</title>
      <link>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</link>
      <pubDate>Wed, 20 Jul 2016 17:32:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</guid>
      <description>MATCH (r:Resource {id: &amp;quot;168640&amp;quot;})-[:REFERENCES]-&amp;gt;(other) WITH r, COLLECT(other) as myReferences UNWIND myReferences AS reference OPTIONAL MATCH path = (other)-[:REFERENCES]-&amp;gt;(reference) WITH other, COUNT(path) AS otherReferences, SIZE(myReferences) AS myReferences WITH other, 1.0 * otherReferences / myReferences AS similarity WHERE similarity &amp;gt; 0.5 RETURN other.id, other.title, similarity ORDER BY similarity DESC LIMIT 10 ╒════════╤═══════════════════════════════════════════╤══════════╕ │other.id│other.title │similarity│ ╞════════╪═══════════════════════════════════════════╪══════════╡ │168640 │Authentication in the Taos operating system│1 │ ├────────┼───────────────────────────────────────────┼──────────┤ │174614 │Authentication in the Taos operating system│1 │ └────────┴───────────────────────────────────────────┴──────────┘ ╒════════╤════════════════════════════════════════════════════════════════╤══════════════════╕ │other.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Removing consecutive duplicates</title>
      <link>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</link>
      <pubDate>Thu, 30 Jul 2015 06:23:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</guid>
      <description>RETURN [1,1,2,3,4,5,6,7,7,8] AS values ==&amp;gt; +-----------------------+ ==&amp;gt; | values | ==&amp;gt; +-----------------------+ ==&amp;gt; | [1,1,2,3,4,5,6,7,7,8] | ==&amp;gt; +-----------------------+ ==&amp;gt; 1 row WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx RETURN idx, idx+1, values[idx], values[idx+1] ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | idx | idx+1 | values[idx] | values[idx+1] | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | 0 | 1 | 1 | 1 | ==&amp;gt; | 1 | 2 | 1 | 2 | ==&amp;gt; | 2 | 3 | 2 | 3 | ==&amp;gt; | 3 | 4 | 3 | 4 | ==&amp;gt; | 4 | 5 | 4 | 5 | ==&amp;gt; | 5 | 6 | 5 | 6 | ==&amp;gt; | 6 | 7 | 6 | 7 | ==&amp;gt; | 7 | 8 | 7 | 7 | ==&amp;gt; | 8 | 9 | 7 | 8 | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; 9 rows WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN a,b ==&amp;gt; +-------+ ==&amp;gt; | a | b | ==&amp;gt; +-------+ ==&amp;gt; | 1 | 2 | ==&amp;gt; | 2 | 3 | ==&amp;gt; | 3 | 4 | ==&amp;gt; | 4 | 5 | ==&amp;gt; | 5 | 6 | ==&amp;gt; | 6 | 7 | ==&amp;gt; | 7 | 8 | ==&amp;gt; +-------+ ==&amp;gt; 7 rows WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +-------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +-------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8] | ==&amp;gt; +-------------------+ ==&amp;gt; 1 row WITH [1,1,1,2,3,4,5,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +-------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +-------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8] | ==&amp;gt; +-------------------+ ==&amp;gt; 1 row WITH [1,1,1,2,3,4,5,5,6,7,7,8,1] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +---------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8,1] | ==&amp;gt; +---------------------+ ==&amp;gt; 1 row </description>
    </item>
    
    <item>
      <title>Neo4j: Finding all shortest paths</title>
      <link>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</link>
      <pubDate>Tue, 19 May 2015 22:45:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</guid>
      <description>MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;()&amp;lt;-[:ACTED_IN]-(p2:Person) MERGE (p1)-[:KNOWS]-(p2) MATCH (p1:Person {name: &amp;quot;Tom Hanks&amp;quot;}), (p2:Person {name: &amp;quot;Tom Cruise&amp;quot;}), path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path MATCH (p1:Person), (p2:Person), path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;() WITH p1, COUNT(*) AS appearances ORDER BY appearances DESC LIMIT 10 WITH p1 AS p1, p1 AS p2 MATCH path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;() WITH p1, COUNT(*) AS appearances ORDER BY appearances DESC LIMIT 10 WITH COLLECT(p1) AS ps UNWIND ps AS p1 UNWIND ps AS p2 MATCH path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 </description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - java.io.InputStreamReader there&#39;s a field starting with a quote and whereas it ends that quote there seems  to be character in that field after that ending quote. That isn&#39;t supported.</title>
      <link>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</link>
      <pubDate>Mon, 04 May 2015 09:56:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</guid>
      <description>LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/neo4j-recommendations/lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv&amp;quot; AS row FIELDTERMINATOR &amp;quot;\t&amp;quot; return COUNT(*) At java.io.InputStreamReader@4d307fda:6484 there&#39;s a field starting with a quote and whereas it ends that quote there seems to be character in that field after that ending quote. That isn&#39;t supported. This is what I read: &#39;weird al&amp;quot;&#39; $ grep &amp;#34;\&amp;#34;weird&amp;#34; lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv | head -n 1 0015371426d2cbef354b2f680340de38d0ebd2f0	7746d775-9550-4360-b8d5-c37bd448ce01	&amp;#34;weird al&amp;#34; yankovic	4099 $ tr &amp;#34;\&amp;#34;&amp;#34; &amp;#34;&amp;#39;&amp;#34; &amp;lt; lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv &amp;gt; lastfm-dataset-360K/clean.tsv LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/neo4j-recommendations/lastfm-dataset-360K/clean.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1.6 - Cypher: FOREACH slowness</title>
      <link>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</link>
      <pubDate>Sun, 28 Dec 2014 04:28:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</guid>
      <description>$ schema Indexes ON :Person(id) ONLINE No constraints WITH range (2,1002) AS friends MERGE (p:Person {id: 1}) FOREACH(f IN friends | MERGE (friend:Person {id: f}) MERGE (friend)-[:FRIENDS]-&amp;gt;p); +-------------------+ | No data returned. | +-------------------+ Nodes created: 1002 Relationships created: 1001 Properties set: 1002 Labels added: 1002 19173 ms EmptyResult | +UpdateGraph(0) | +Eager | +UpdateGraph(1) | +Extract | +Null +----------------+------+---------+-------------+--------------------------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------+------+---------+-------------+--------------------------------------+ | EmptyResult | 0 | 0 | | | | UpdateGraph(0) | 1 | 3015012 | | Foreach | | Eager | 1 | 0 | | | | UpdateGraph(1) | 1 | 5 | p, p | MergeNode; { AUTOINT2}; :Person(id) | | Extract | 1 | 0 | | friends | | Null | ?</description>
    </item>
    
    <item>
      <title>Neo4j&#39;s Cypher vs Clojure - Group by and Sorting</title>
      <link>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</link>
      <pubDate>Sun, 29 Jun 2014 02:56:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</guid>
      <description>CREATE (event1:Event {name: &amp;quot;Future Event 1&amp;quot;, timestamp: 1414002772427 }) CREATE (event2:Event {name: &amp;quot;Future Event 2&amp;quot;, timestamp: 1424002772427 }) CREATE (event3:Event {name: &amp;quot;Future Event 3&amp;quot;, timestamp: 1416002772427 }) CREATE (event4:Event {name: &amp;quot;Past Event 1&amp;quot;, timestamp: 1403002772427 }) CREATE (event5:Event {name: &amp;quot;Past Event 2&amp;quot;, timestamp: 1402002772427 }) $ MATCH (e:Event) RETURN e; ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | e | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | Node[15414]{name:&amp;quot;Future Event 1&amp;quot;,timestamp:1414002772427} | ==&amp;gt; | Node[15415]{name:&amp;quot;Future Event 2&amp;quot;,timestamp:1424002772427} | ==&amp;gt; | Node[15416]{name:&amp;quot;Future Event 3&amp;quot;,timestamp:1416002772427} | ==&amp;gt; | Node[15417]{name:&amp;quot;Past Event 1&amp;quot;,timestamp:1403002772427} | ==&amp;gt; | Node[15418]{name:&amp;quot;Past Event 2&amp;quot;,timestamp:1402002772427} | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; 5 rows ==&amp;gt; 13 ms (def sorted-query &amp;#34;MATCH (e:Event) WITH COLLECT(e) AS events WITH [e IN events WHERE e.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Handling conditionals</title>
      <link>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</link>
      <pubDate>Tue, 17 Jun 2014 23:41:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</guid>
      <description>match_id,player,player_id,time,type &amp;#34;1012&amp;#34;,&amp;#34;Antonin Panenka&amp;#34;,&amp;#34;174835&amp;#34;,21,&amp;#34;penalty&amp;#34; &amp;#34;1012&amp;#34;,&amp;#34;Faisal Al Dakhil&amp;#34;,&amp;#34;2204&amp;#34;,57,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Roger Milla&amp;#34;,&amp;#34;79318&amp;#34;,106,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Roger Milla&amp;#34;,&amp;#34;79318&amp;#34;,108,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Bernardo Redin&amp;#34;,&amp;#34;44555&amp;#34;,115,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Andre Kana-biyik&amp;#34;,&amp;#34;174649&amp;#34;,44,&amp;#34;yellow&amp;#34; LOAD CSV WITH HEADERS FROM &amp;quot;https://raw.githubusercontent.com/mneedham/neo4j-worldcup/master/data/import/events.csv&amp;quot; AS csvLine // removed for conciseness // goals FOREACH(n IN (CASE WHEN csvLine.type IN [&amp;quot;penalty&amp;quot;, &amp;quot;goal&amp;quot;, &amp;quot;owngoal&amp;quot;] THEN [1] else [] END) | FOREACH(t IN CASE WHEN team = home THEN [home] ELSE [away] END | MERGE (stats)-[:SCORED_GOAL]-&amp;gt;(penalty:Goal {time: csvLine.time, type: csvLine.type}) )	) // cards FOREACH(n IN (CASE WHEN csvLine.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - UNWIND vs FOREACH</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</link>
      <pubDate>Sat, 31 May 2014 14:19:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</guid>
      <description>WITH [{name: &amp;quot;Event 1&amp;quot;, timetree: {day: 1, month: 1, year: 2014}}, {name: &amp;quot;Event 2&amp;quot;, timetree: {day: 2, month: 1, year: 2014}}] AS events FOREACH (event IN events | CREATE (e:Event {name: event.name}) MATCH (year:Year {year: event.timetree.year }), (year)-[:HAS_MONTH]-&amp;gt;(month {month: event.timetree.month }), (month)-[:HAS_DAY]-&amp;gt;(day {day: event.timetree.day }) CREATE (e)-[:HAPPENED_ON]-&amp;gt;(day)) Invalid use of MATCH inside FOREACH (line 5, column 3) &amp;quot; MATCH (year:Year {year: event.timetree.year }), &amp;quot; ^ Neo.ClientError.Statement.InvalidSyntax WITH [{name: &amp;quot;Event 1&amp;quot;, timetree: {day: 1, month: 1, year: 2014}}, {name: &amp;quot;Event 2&amp;quot;, timetree: {day: 2, month: 1, year: 2014}}] AS events FOREACH (event IN events | CREATE (e:Event {name: event.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding a float value to decimal places</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</link>
      <pubDate>Sun, 25 May 2014 22:17:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</guid>
      <description>RETURN toFloat(&amp;quot;12.336666&amp;quot;) AS value WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value RETURN round(100 * value) / 100 AS value 12.34 WITH 2 as precision WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value, 10^precision AS factor RETURN round(factor * value)/factor AS value WITH 4 as precision WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value, 10^precision AS factor RETURN round(factor * value)/factor AS value 12.3367 </description>
    </item>
    
    <item>
      <title>Neo4j 2.1:  Passing around node ids vs UNWIND</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</link>
      <pubDate>Sun, 25 May 2014 10:48:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</guid>
      <description>MATCH (g:Group) WITH g ORDER BY g.name LIMIT 5 WITH COLLECT(id(g)) AS groups MATCH (g1) WHERE id(g1) IN groups MATCH (g2) WHERE id(g2) IN groups OPTIONAL MATCH path = (g1)&amp;lt;-[:MEMBER_OF]-()-[:MEMBER_OF]-&amp;gt;(g2) RETURN g1.name, g2.name, CASE WHEN path is null THEN 0 ELSE COUNT(path) END AS overlap MATCH (g:Group) WITH g ORDER BY g.name LIMIT 5 WITH COLLECT(g) AS groups MATCH (g1) WHERE g1 IN groups MATCH (g2) WHERE g2 IN groups OPTIONAL MATCH path = (g1)&amp;lt;-[:MEMBER_OF]-()-[:MEMBER_OF]-&amp;gt;(g2) RETURN g1.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1: Creating adjacency matrices</title>
      <link>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</link>
      <pubDate>Tue, 20 May 2014 23:14:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</guid>
      <description>MATCH (g1:Group), (g2:Group) RETURN g1.name, g2.name LIMIT 10 +-------------------------------------------------------------------------------------+ | g1.name | g2.name | +-------------------------------------------------------------------------------------+ | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;London ElasticSearch User Group&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;Big Data / Data Science / Data Analytics Jobs&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;eXist User Group London&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;Couchbase London&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;Big Data Developers in London&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;HBase London Meetup&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;Marklogic Financial Services Community&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;GridGain London&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;MEAN Stack&amp;#34; | | &amp;#34;London ElasticSearch User Group&amp;#34; | &amp;#34;Hazelcast User Group London (HUGL)&amp;#34; | .</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Finding directors who acted in their own movie</title>
      <link>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</link>
      <pubDate>Fri, 28 Feb 2014 22:57:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</guid>
      <description>MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(d) WHERE a.name = d.name RETURN a MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(d) WHERE a = d RETURN a MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(a) RETURN a </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Set Based Operations</title>
      <link>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</link>
      <pubDate>Thu, 20 Feb 2014 18:22:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</guid>
      <description>public class SetBasedOperations { private static final Label PERSON = DynamicLabel.label( &amp;#34;Person&amp;#34; ); private static final Label OFFICE = DynamicLabel.label( &amp;#34;Office&amp;#34; ); private static final DynamicRelationshipType COLLEAGUES = DynamicRelationshipType.withName( &amp;#34;COLLEAGUES&amp;#34; ); private static final DynamicRelationshipType MEMBER_OF = DynamicRelationshipType.withName( &amp;#34;MEMBER_OF&amp;#34; ); public static void main( String[] args ) throws IOException { Random random = new Random(); String path = &amp;#34;/tmp/set-based-operations&amp;#34;; FileUtils.deleteRecursively( new File( path ) ); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( path ); Transaction tx = db.</description>
    </item>
    
    <item>
      <title>Neo4j: Creating nodes and relationships from a list of maps</title>
      <link>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</link>
      <pubDate>Mon, 17 Feb 2014 14:11:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</guid>
      <description>MERGE (me:User {userId: 1} ) SET me.name = &amp;quot;Mark&amp;quot; FOREACH (f IN [{userId: 2, name: &amp;quot;Michael&amp;quot;}, {userId: 3, name: &amp;quot;Peter&amp;quot;}] | MERGE (u:User {userId: f.userId}) SET u = f MERGE (me)-[:FRIENDS_WITH]-&amp;gt;(u)) MERGE (me:User { userId: {userId} }) SET me.name = {name} FOREACH(f IN {friends} | MERGE (u:User {userId: f.userId }) SET u = f MERGE (me)-[:FRIENDS_WITH]-&amp;gt;(u)) public class ListsOfMapsCypher { public static void main( String[] args ) { ObjectNode request = JsonNodeFactory.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0: Cypher - Index Hints and Neo.ClientError.Schema.NoSuchIndex</title>
      <link>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</link>
      <pubDate>Fri, 31 Jan 2014 07:14:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</guid>
      <description>CREATE INDEX ON :Player(name) MATCH p USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; RETURN p Cannot use index hint in this context. The label and property comparison must be specified on a non-optional node Label: `Player` Property name: `name` Neo.ClientError.Schema.NoSuchIndex MATCH (p:Player) USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; RETURN p MATCH (p:Player) USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; OR p.name = &amp;quot;Robin Van Persie&amp;quot; RETURN p Cannot use index hint in this context.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Getting the hang of MERGE</title>
      <link>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</link>
      <pubDate>Tue, 10 Dec 2013 23:46:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</guid>
      <description>public class Merge { private static Label PERSON = DynamicLabel.label(&amp;#34;Person&amp;#34;); public static void main(String[] args) throws IOException { File dbFile = new File(&amp;#34;/tmp/test-db&amp;#34;); FileUtils.deleteRecursively(dbFile); Faker faker = new Faker(); Random random = new Random(); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase(dbFile.getPath()); Transaction tx = db.beginTx(); for (int i = 0; i &amp;lt; 100000; i++) { Node person = db.createNode(PERSON); person.setProperty(&amp;#34;name&amp;#34;, faker.name()); person.setProperty(&amp;#34;firstName&amp;#34;, faker.firstName()); person.setProperty(&amp;#34;lastName&amp;#34;, faker.lastName()); person.setProperty(&amp;#34;country&amp;#34;, faker.country()); person.setProperty(&amp;#34;age&amp;#34;, random.nextInt(50)); } tx.success(); tx.close(); } } $ MATCH (p:Person) RETURN p LIMIT 5; ==&amp;gt; +------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | p | ==&amp;gt; +------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[1344]{name:&amp;quot;Benton Swaniawski&amp;quot;,firstName:&amp;quot;Rossie&amp;quot;,lastName:&amp;quot;Ankunding&amp;quot;,country:&amp;quot;Guadeloupe&amp;quot;,age:30} | ==&amp;gt; | Node[1345]{name:&amp;quot;Dagmar Bartell&amp;quot;,firstName:&amp;quot;Ashlynn&amp;quot;,lastName:&amp;quot;Watsica&amp;quot;,country:&amp;quot;French Guiana&amp;quot;,age:35} | ==&amp;gt; | Node[1346]{name:&amp;quot;Ms.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Optional relationships with OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</link>
      <pubDate>Sat, 23 Nov 2013 22:54:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</guid>
      <description>CREATE (steve:Person {name: &amp;quot;Steve&amp;quot;}) CREATE (john:Person {name: &amp;quot;John&amp;quot;}) CREATE (david:Person {name: &amp;quot;David&amp;quot;}) CREATE (paul:Person {name: &amp;quot;Paul&amp;quot;}) CREATE (sam:Person {name: &amp;quot;Sam&amp;quot;}) CREATE (londonOffice:Office {name: &amp;quot;London Office&amp;quot;}) CREATE UNIQUE (steve)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (john)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (david)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (paul)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (sam)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(john) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(david) MATCH (person:Person)-[:WORKS_IN]-&amp;gt;(office)&amp;lt;-[:WORKS_IN]-(potentialColleague) WHERE person.name = &amp;quot;Steve&amp;quot; AND office.name = &amp;quot;London Office&amp;quot; WITH person, potentialColleague MATCH (potentialColleague)-[c?:COLLEAGUES_WITH]-(person) WHERE c IS null RETURN potentialColleague ==&amp;gt; +----------------------+ ==&amp;gt; | potentialColleague | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[4]{name:&amp;#34;Paul&amp;#34;} | ==&amp;gt; | Node[5]{name:&amp;#34;Sam&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; SyntaxException: Question mark is no longer used for optional patterns - use OPTIONAL MATCH instead (line 1, column 199) ==&amp;gt; &amp;#34;MATCH (person:Person)-[:WORKS_IN]-&amp;gt;(office)&amp;lt;-[:WORKS_IN]-(potentialColleague) WHERE person.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Working with path expressions</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</link>
      <pubDate>Sat, 23 Nov 2013 10:30:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</guid>
      <description>MATCH (player:Player)-[:played|subbed_on]-&amp;gt;stats WITH stats.goals AS goals, player, stats-[:in]-&amp;gt;()-[:on_tv]-() as onTv RETURN player.name, SUM(CASE WHEN onTv = FALSE THEN goals ELSE 0 END) as nonTvGoals, SUM(CASE WHEN onTv = TRUE THEN goals ELSE 0 END) as tvGoals, SUM(goals) as allGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; | player.name | nonTvGoals | tvGoals | allGoals | ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; | &amp;#34;Robin Van Persie&amp;#34; | 11 | 15 | 26 | ==&amp;gt; | &amp;#34;Gareth Bale&amp;#34; | 8 | 13 | 21 | ==&amp;gt; | &amp;#34;Luis Suárez&amp;#34; | 12 | 11 | 23 | ==&amp;gt; | &amp;#34;Theo Walcott&amp;#34; | 5 | 9 | 14 | ==&amp;gt; | &amp;#34;Demba Ba&amp;#34; | 7 | 8 | 15 | ==&amp;gt; | &amp;#34;Santi Cazorla&amp;#34; | 5 | 7 | 12 | ==&amp;gt; | &amp;#34;Edin Dzeko&amp;#34; | 7 | 7 | 14 | ==&amp;gt; | &amp;#34;Carlos Tevez&amp;#34; | 5 | 6 | 11 | ==&amp;gt; | &amp;#34;Juan Mata&amp;#34; | 6 | 6 | 12 | ==&amp;gt; | &amp;#34;Steven Gerrard&amp;#34; | 3 | 6 | 9 | ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Creating relationships between nodes from adjacent rows in a query</title>
      <link>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</link>
      <pubDate>Fri, 22 Nov 2013 22:45:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</guid>
      <description>CREATE (:Season {name: &amp;quot;2013/2014&amp;quot;, timestamp: 1375315200}) CREATE (:Season {name: &amp;quot;2012/2013&amp;quot;, timestamp: 1343779200}) CREATE (:Season {name: &amp;quot;2011/2012&amp;quot;, timestamp: 1312156800}) CREATE (:Season {name: &amp;quot;2010/2011&amp;quot;, timestamp: 1280620800}) CREATE (:Season {name: &amp;quot;2009/2010&amp;quot;, timestamp: 1249084800}) // return all the matches for 2010/2011, 2011/2012, 2012/2013 MATCH (base:Season)&amp;lt;-[:NEXT*0..2]-(s) WHERE base.name = &amp;quot;2012/2013&amp;quot; MATCH s-[:contains]-&amp;gt;game RETURN game MATCH (s:Season) WITH s ORDER BY s.timestamp RETURN s ==&amp;gt; +------------------------------------------------+ ==&amp;gt; | s | ==&amp;gt; +------------------------------------------------+ ==&amp;gt; | Node[0]{name:&amp;#34;2009/2010&amp;#34;,timestamp:1249084800} | ==&amp;gt; | Node[1]{name:&amp;#34;2010/2011&amp;#34;,timestamp:1280620800} | ==&amp;gt; | Node[2]{name:&amp;#34;2011/2012&amp;#34;,timestamp:1312156800} | ==&amp;gt; | Node[3]{name:&amp;#34;2012/2013&amp;#34;,timestamp:1343779200} | ==&amp;gt; | Node[4]{name:&amp;#34;2013/2014&amp;#34;,timestamp:1375315200} | ==&amp;gt; +------------------------------------------------+ MATCH (s:Season) WITH s ORDER BY s.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting rid of an optional match</title>
      <link>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</link>
      <pubDate>Sun, 13 Oct 2013 21:59:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</guid>
      <description>MATCH (player:Player) WITH player MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT({goals: stats.goals, type: TYPE(t)}) AS games, player RETURN player.name, REDUCE(goals = 0, h IN [g IN games WHERE g.type IS NULL] | goals + h.goals) AS nonTvGoals, REDUCE(goals = 0, h IN [g IN games WHERE g.type &amp;lt;&amp;gt; NULL] | goals + h.goals) AS tvGoals, REDUCE(goals = 0, h in games | goals + h.goals) AS totalGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Converting queries from 1.9 to 2.0 -  &#39;Can&#39;t use optional patterns without explicit START clause&#39;</title>
      <link>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</link>
      <pubDate>Thu, 03 Oct 2013 16:16:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</guid>
      <description>START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT([stats.goals, TYPE(t)]) AS games, player RETURN player.name, REDUCE(goals = 0, g&#39; IN FILTER(g IN games WHERE HEAD(TAIL(g)) IS NULL)| goals + HEAD(g&#39;)) AS nonTvGoals, REDUCE(goals = 0, g&#39; IN FILTER(g IN games WHERE HEAD(TAIL(g)) &amp;lt;&amp;gt; NULL)| goals + HEAD(g&#39;)) AS tvGoals, REDUCE(goals = 0, g&#39; in games | goals + HEAD(g&#39;)) AS totalGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.name | nonTvGoals | tvGoals | totalGoals | ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | &amp;#34;Robin Van Persie&amp;#34; | 11 | 15 | 26 | ==&amp;gt; | &amp;#34;Gareth Bale&amp;#34; | 8 | 13 | 21 | ==&amp;gt; | &amp;#34;Luis Suárez&amp;#34; | 12 | 11 | 23 | ==&amp;gt; | &amp;#34;Theo Walcott&amp;#34; | 5 | 9 | 14 | ==&amp;gt; | &amp;#34;Demba Ba&amp;#34; | 7 | 8 | 15 | ==&amp;gt; | &amp;#34;Edin Dzeko&amp;#34; | 7 | 7 | 14 | ==&amp;gt; | &amp;#34;Santi Cazorla&amp;#34; | 5 | 7 | 12 | ==&amp;gt; | &amp;#34;Juan Mata&amp;#34; | 6 | 6 | 12 | ==&amp;gt; | &amp;#34;Steven Gerrard&amp;#34; | 3 | 6 | 9 | ==&amp;gt; | &amp;#34;Carlos Tevez&amp;#34; | 5 | 6 | 11 | ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; 10 rows START player = node:players(&#39;name:*&#39;) SET player :Player RETURN player CREATE INDEX on :Player(name) MATCH (player:Player)-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Translating 1.9 FILTER queries to use 2.0 list comprehensions</title>
      <link>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</link>
      <pubDate>Mon, 30 Sep 2013 21:34:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</guid>
      <description>START team = node:teams(&#39;name:*&#39;) MATCH team&amp;lt;-[:for]-like_this&amp;lt;-[:started|as_sub]-player-[r?:sent_off_in|booked_in]-&amp;gt;game&amp;lt;-[:in]-like_this WITH team, COLLECT(r) AS cards WITH team, FILTER(x IN cards: TYPE(x) = &amp;quot;sent_off_in&amp;quot;) AS reds, FILTER(x IN cards: TYPE(x) = &amp;quot;booked_in&amp;quot;) AS yellows RETURN team.name, LENGTH(reds) AS redCards, LENGTH(yellows) AS yellowCards ORDER BY (yellowCards*1 + redCards*3) DESC ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; | team.name | redCards | yellowCards | ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; | &amp;#34;Stoke City&amp;#34; | 4 | 81 | ==&amp;gt; | &amp;#34;Newcastle United&amp;#34; | 4 | 74 | ==&amp;gt; | &amp;#34;Aston Villa&amp;#34; | 3 | 74 | ==&amp;gt; | &amp;#34;West Ham United&amp;#34; | 1 | 74 | ==&amp;gt; | &amp;#34;West Bromwich Albion&amp;#34; | 4 | 63 | ==&amp;gt; | &amp;#34;Sunderland&amp;#34; | 3 | 63 | ==&amp;gt; | &amp;#34;Wigan Athletic&amp;#34; | 2 | 66 | ==&amp;gt; | &amp;#34;Manchester City&amp;#34; | 3 | 62 | ==&amp;gt; | &amp;#34;Everton&amp;#34; | 3 | 62 | ==&amp;gt; | &amp;#34;Queens Park Rangers&amp;#34; | 3 | 60 | ==&amp;gt; | &amp;#34;Swansea City&amp;#34; | 2 | 59 | ==&amp;gt; | &amp;#34;Norwich City&amp;#34; | 1 | 60 | ==&amp;gt; | &amp;#34;Chelsea&amp;#34; | 3 | 53 | ==&amp;gt; | &amp;#34;Liverpool&amp;#34; | 2 | 54 | ==&amp;gt; | &amp;#34;Manchester United&amp;#34; | 1 | 57 | ==&amp;gt; | &amp;#34;Tottenham Hotspur&amp;#34; | 2 | 54 | ==&amp;gt; | &amp;#34;Arsenal&amp;#34; | 5 | 44 | ==&amp;gt; | &amp;#34;Fulham&amp;#34; | 3 | 48 | ==&amp;gt; | &amp;#34;Southampton&amp;#34; | 2 | 44 | ==&amp;gt; | &amp;#34;Reading&amp;#34; | 1 | 45 | ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; 20 rows ==&amp;gt; SyntaxException: Invalid input &amp;#39;(&amp;#39;: expected an identifier character, whitespace, NodeLabel, &amp;#39;.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of query parameters</title>
      <link>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</link>
      <pubDate>Sat, 27 Jul 2013 09:30:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</guid>
      <description>require &amp;#39;open-uri&amp;#39; open(&amp;#34;data/people.cyp&amp;#34;, &amp;#39;w&amp;#39;) { |f| (1..500).each do |value| f.puts(&amp;#34;CREATE (p:Person{name: \&amp;#34;#{value}\&amp;#34;})&amp;#34;) end } CREATE (:Person{name: &amp;quot;person1&amp;quot;}) CREATE (:Person{name: &amp;quot;person2&amp;quot;}) CREATE (:Person{name: &amp;quot;person3&amp;quot;}) CREATE (:Person{name: &amp;quot;person4&amp;quot;}) CREATE (:Person{name: &amp;quot;person5&amp;quot;}) ... ==&amp;gt; +-------------------+ ==&amp;gt; | No data returned. | ==&amp;gt; +-------------------+ ==&amp;gt; Nodes created: 500 ==&amp;gt; Properties set: 500 ==&amp;gt; Labels added: 500 ==&amp;gt; 27706 ms require &amp;#39;neography&amp;#39; params = { :name =&amp;gt; &amp;#34;Mark&amp;#34; } Neography::Rest.new.execute_query(&amp;#34;CREATE (:Person {name: {name} })&amp;#34;, params) neo4j-sh (0)$ match p:Person return p; ==&amp;gt; +----------------------+ ==&amp;gt; | p | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[1]{name:&amp;#34;Mark&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; 1 row ==&amp;gt; 175 ms require &amp;#39;neography&amp;#39; params = { :name =&amp;gt; [] } (1.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Aggregating relationships within a path</title>
      <link>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</link>
      <pubDate>Thu, 27 Jun 2013 10:32:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</guid>
      <description>CREATE (email1 { name: &#39;Email 1&#39;, title: &#39;Some stuff&#39; }) CREATE (email2 { name: &#39;Email 2&#39;, title: &amp;quot;Absolutely irrelevant&amp;quot; }) CREATE (email3 { name: &#39;Email 3&#39;, title: &amp;quot;Something else&amp;quot; }) CREATE (person1 { name: &#39;Mark&#39; }) CREATE (person2 { name: &#39;Jim&#39; }) CREATE (person3 { name: &#39;Alistair&#39; }) CREATE (person1)-[:SENT]-&amp;gt;(email1) CREATE (person2)-[:RECEIVED]-&amp;gt;(email1) CREATE (person3)-[:RECEIVED]-&amp;gt;(email1) CREATE (person1)-[:SENT]-&amp;gt;(email2) CREATE (person2)-[:RECEIVED]-&amp;gt;(email2) CREATE (person2)-[:SENT]-&amp;gt;(email3) CREATE (person1)-[:RECEIVED]-&amp;gt;(email3) +-------------------------------------------+ | Person 1 | Person 2 | P1 -&amp;gt; P2 | P2 -&amp;gt; P1 | |-------------------------------------------| | Alistair | Mark | 0 | 1 | | Jim | Mark | 1 | 2 | +-------------------------------------------+ START email = node:node_auto_index(&#39;name:&amp;quot;Email 1&amp;quot; name:&amp;quot;Email 2&amp;quot; name: &amp;quot;Email 3&amp;quot;&#39;) MATCH sender-[:SENT]-&amp;gt;email&amp;lt;-[:RECEIVED]-receiver RETURN sender.</description>
    </item>
    
    <item>
      <title>neo4j: A simple example using the JDBC driver</title>
      <link>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</link>
      <pubDate>Thu, 20 Jun 2013 07:21:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</guid>
      <description>&amp;lt;dependencies&amp;gt; ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.neo4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;neo4j-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;repositories&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;id&amp;gt;neo4j-maven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;neo4j maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://m2.neo4j.org&amp;lt;/url&amp;gt; &amp;lt;/repository&amp;gt; &amp;lt;/repositories&amp;gt; Neo4jConnection connect = new Driver(). connect(&amp;#34;jdbc:neo4j://localhost:7474&amp;#34;, new Properties()); Exception in thread &amp;#34;main&amp;#34; java.lang.NoClassDefFoundError: org/neo4j/cypherdsl/grammar/Execute at org.neo4j.jdbc.Driver.&amp;lt;init&amp;gt;(Driver.java:52) at org.neo4j.jdbc.Driver.&amp;lt;clinit&amp;gt;(Driver.java:43) at com.centrica.bigquery.JDBCTest.main(JDBCTest.java:17) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) Caused by: java.lang.ClassNotFoundException: org.neo4j.cypherdsl.grammar.Execute at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:423) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:356) ... 8 more &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding single hop paths</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</link>
      <pubDate>Sat, 15 Jun 2013 13:04:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</guid>
      <description>CREATE (ranieri {name: &amp;quot;Claudio Ranieri&amp;quot;}) CREATE (mourinho {name: &amp;quot;Jose Mourinho&amp;quot;}) CREATE (grant {name: &amp;quot;Avram Grant&amp;quot;}) CREATE (scolari {name: &amp;quot;Luiz Felipe Scolari&amp;quot;}) CREATE (wilkins {name: &amp;quot;Ray Wilkins&amp;quot;}) CREATE (hiddink {name: &amp;quot;Guus Hiddink&amp;quot;}) CREATE (ancelotti {name: &amp;quot;Carlo Ancelotti&amp;quot;}) CREATE (villasBoas {name: &amp;quot;Andre Villas Boas&amp;quot;}) CREATE (diMatteo {name: &amp;quot;Roberto Di Matteo&amp;quot;}) CREATE (benitez {name: &amp;quot;Rafael Benitez&amp;quot;}) CREATE (ranieri)-[:SUCCEEDED_BY]-&amp;gt;(mourinho) CREATE (mourinho)-[:SUCCEEDED_BY]-&amp;gt;(grant) CREATE (grant)-[:SUCCEEDED_BY]-&amp;gt;(scolari) CREATE (scolari)-[:SUCCEEDED_BY]-&amp;gt;(wilkins) CREATE (wilkins)-[:SUCCEEDED_BY]-&amp;gt;(hiddink) CREATE (hiddink)-[:SUCCEEDED_BY]-&amp;gt;(ancelotti) CREATE (ancelotti)-[:SUCCEEDED_BY]-&amp;gt;(villasBoas) CREATE (villasBoas)-[:SUCCEEDED_BY]-&amp;gt;(diMatteo) CREATE (diMatteo)-[:SUCCEEDED_BY]-&amp;gt;(benitez) CREATE (benitez)-[:SUCCEEDED_BY]-&amp;gt;(mourinho) START m = node:node_auto_index(name=&amp;quot;Claudio Ranieri&amp;quot;) MATCH path = (m)-[rel:SUCCEEDED_BY*]-&amp;gt;(successor) RETURN EXTRACT(n IN NODES(path): n.</description>
    </item>
    
    <item>
      <title>neo4j/cypher/Lucene: Dealing with special characters</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</link>
      <pubDate>Sat, 15 Jun 2013 09:53:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</guid>
      <description>CREATE ({name: &amp;quot;-one&amp;quot;}) CREATE ({name: &amp;quot;-two&amp;quot;}) CREATE ({name: &amp;quot;-three&amp;quot;}) CREATE ({name: &amp;quot;four&amp;quot;}) START p = node:node_auto_index(&amp;quot;name:-*&amp;quot;) RETURN p; ==&amp;gt; RuntimeException: org.apache.lucene.queryParser.ParseException: Cannot parse &amp;#39;name:-*&amp;#39;: Encountered &amp;#34; &amp;#34;-&amp;#34; &amp;#34;- &amp;#34;&amp;#34; at line 1, column 5. ==&amp;gt; Was expecting one of: ==&amp;gt; &amp;lt;BAREOPER&amp;gt; ... ==&amp;gt; &amp;#34;(&amp;#34; ... ==&amp;gt; &amp;#34;*&amp;#34; ... ==&amp;gt; &amp;lt;QUOTED&amp;gt; ... ==&amp;gt; &amp;lt;TERM&amp;gt; ... ==&amp;gt; &amp;lt;PREFIXTERM&amp;gt; ... ==&amp;gt; &amp;lt;WILDTERM&amp;gt; ... ==&amp;gt; &amp;#34;[&amp;#34; ... ==&amp;gt; &amp;#34;{&amp;#34; ... ==&amp;gt; &amp;lt;NUMBER&amp;gt; ... ==&amp;gt; START p = node:node_auto_index(&amp;quot;name:\-*&amp;quot;) RETURN p; ==&amp;gt; SyntaxException: invalid escape sequence ==&amp;gt; ==&amp;gt; Think we should have better error message here?</description>
    </item>
    
    <item>
      <title>neo4j/cypher 2.0: The CASE statement</title>
      <link>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</link>
      <pubDate>Sun, 09 Jun 2013 14:02:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</guid>
      <description>CREATE (year2013 { name: &amp;quot;2013&amp;quot; }) CREATE (january2013 { name: &amp;quot;January&amp;quot; }) CREATE (january012013 { name: &amp;quot;1st&amp;quot; }) CREATE (january022013 { name: &amp;quot;2nd&amp;quot; }) CREATE (january032013 { name: &amp;quot;3rd&amp;quot; }) CREATE (january042013 { name: &amp;quot;4th&amp;quot; }) CREATE (january052013 { name: &amp;quot;5th&amp;quot; }) CREATE (chelsea { name: &amp;quot;Chelsea&amp;quot;, type: &amp;quot;team&amp;quot; }) CREATE (joseMourinho { name: &amp;quot;Jose Mourinho&amp;quot;}) CREATE (mourinhoChelsea { name: &amp;quot;Mourinho tenure at Chelsea&amp;quot; }) CREATE (manUtd { name: &amp;quot;Manchester United&amp;quot;, type: &amp;quot;team&amp;quot; }) CREATE (davidMoyes { name: &amp;quot;David Moyes&amp;quot;}) CREATE (davidMoyesUnited { name: &amp;quot;Moyes tenure at Manchester United&amp;quot; }) CREATE (year2013)-[:`January`]-(january2013) CREATE (january2013)-[:`01`]-(january012013) CREATE (january2013)-[:`02`]-(january022013) CREATE (january2013)-[:`03`]-(january032013) CREATE (january2013)-[:`04`]-(january042013) CREATE (january2013)-[:`05`]-(january052013) CREATE (january012013)-[:NEXT]-(january022013) CREATE (january022013)-[:NEXT]-(january032013) CREATE (january032013)-[:NEXT]-(january042013) CREATE (january042013)-[:NEXT]-(january052013) CREATE (mourinhoChelsea)-[:HIRED_ON {date: &amp;quot;January 1st 2013&amp;quot;}]-&amp;gt;(january012013) CREATE (mourinhoChelsea)-[:MANAGER]-&amp;gt;(joseMourinho) CREATE (mourinhoChelsea)-[:TEAM]-&amp;gt;(chelsea) CREATE (mourinhoChelsea)-[:FIRED_ON]-&amp;gt;(january032013) CREATE (davidMoyesUnited)-[:HIRED_ON {date: &amp;quot;January 2nd 2013&amp;quot;}]-&amp;gt;(january022013) CREATE (davidMoyesUnited)-[:MANAGER]-&amp;gt;(davidMoyes) CREATE (davidMoyesUnited)-[:TEAM]-&amp;gt;(manUtd) START team = node:node_auto_index(&#39;name:&amp;quot;Chelsea&amp;quot; name:&amp;quot;Manchester United&amp;quot;&#39;), date = node:node_auto_index(name=&amp;quot;5th&amp;quot;) MATCH date&amp;lt;-[:NEXT*0.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: 400 response - Paths can&#39;t be created inside of foreach</title>
      <link>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</link>
      <pubDate>Fri, 31 May 2013 00:37:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</guid>
      <description>require &amp;#39;neography&amp;#39; neo = Neography::Rest.new neo.execute_query(&amp;#34;create (me {name: &amp;#39;Mark&amp;#39;})&amp;#34;) query = &amp;#34; START n=node:node_auto_index(name={name})&amp;#34; query &amp;lt;&amp;lt; &amp;#34; FOREACH (friend in {friends} : CREATE f=friend, n-[:FRIEND]-&amp;gt;f)&amp;#34; neo.execute_query(query, {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Mark&amp;#34;, &amp;#34;friends&amp;#34; =&amp;gt; [{ &amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Will&amp;#34;}, {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Paul&amp;#34;}]}) START p = node:node_auto_index(name=&amp;quot;Mark&amp;quot;) MATCH p-[:FRIEND]-f RETURN f ==&amp;gt; +----------------------+ ==&amp;gt; | f | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[2]{name:&amp;#34;Will&amp;#34;} | ==&amp;gt; | Node[3]{name:&amp;#34;Paul&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; 2 rows ==&amp;gt; 37 ms /Users/markhneedham/.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Properties or relationships? It&#39;s easy to switch</title>
      <link>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</link>
      <pubDate>Sat, 25 May 2013 12:21:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</guid>
      <description>CREATE (frenchConnection { name: &amp;quot;French Connection&amp;quot; }) CREATE (dress1 { name: &amp;quot;Halter Dress&amp;quot;, colour: &amp;quot;Blue&amp;quot;})-[:BRAND]-(frenchConnection) CREATE (dress2 { name: &amp;quot;Another Dress&amp;quot;, colour: &amp;quot;Yellow&amp;quot;})-[:BRAND]-(frenchConnection) CREATE (dress3 { name: &amp;quot;Different Dress&amp;quot;, colour: &amp;quot;Blue&amp;quot;})-[:BRAND]-(frenchConnection) RETURN dress1, dress2, dress3 ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | dress1 | dress2 | dress3 | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[2]{name:&amp;#34;Halter Dress&amp;#34;,colour:&amp;#34;Blue&amp;#34;} | Node[3]{name:&amp;#34;Another Dress&amp;#34;,colour:&amp;#34;Yellow&amp;#34;} | Node[4]{name:&amp;#34;Different Dress&amp;#34;,colour:&amp;#34;Blue&amp;#34;} | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; 1 row ==&amp;gt; Nodes created: 4 ==&amp;gt; Relationships created: 3 ==&amp;gt; Properties set: 7 ==&amp;gt; 179 ms START brand = node:node_auto_index(name=&amp;quot;French Connection&amp;quot;) MATCH brand&amp;lt;-[:BRAND]-product WHERE product.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Keep longest path when finding taxonomy</title>
      <link>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</link>
      <pubDate>Sun, 19 May 2013 22:15:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</guid>
      <description>CREATE (cat { name: &amp;quot;Cat&amp;quot; }) CREATE (subcat1 { name: &amp;quot;SubCat1&amp;quot; }) CREATE (subcat2 { name: &amp;quot;SubCat2&amp;quot; }) CREATE (subsubcat1 { name: &amp;quot;SubSubCat1&amp;quot; }) CREATE (product1 { name: &amp;quot;Product1&amp;quot; }) CREATE (cat)-[:CHILD]-subcat1-[:CHILD]-subsubcat1 CREATE (product1)-[:HAS_CATEGORY]-(subsubcat1) START product=node:node_auto_index(name=&amp;quot;Product1&amp;quot;) MATCH product-[:HAS_CATEGORY]-category, taxonomy=category&amp;lt;-[:CHILD*1..]-parent RETURN product, EXTRACT(n IN NODES(taxonomy): n.name) ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; | product | EXTRACT(n IN NODES(taxonomy): n.name) | ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; | Node[888]{name:&amp;#34;Product1&amp;#34;} | [&amp;#34;SubSubCat1&amp;#34;,&amp;#34;SubCat1&amp;#34;] | ==&amp;gt; | Node[888]{name:&amp;#34;Product1&amp;#34;} | [&amp;#34;SubSubCat1&amp;#34;,&amp;#34;SubCat1&amp;#34;,&amp;#34;Cat&amp;#34;] | ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; 2 rows START product=node:node_auto_index(name=&amp;quot;Product1&amp;quot;) MATCH product-[:HAS_CATEGORY]-category, taxonomy=category&amp;lt;-[:CHILD*1.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Returning a row with zero count when no relationship exists</title>
      <link>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</link>
      <pubDate>Tue, 30 Apr 2013 07:02:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</guid>
      <description>START game = node:matches(&#39;match_id:*&#39;) MATCH game&amp;lt;-[:sent_off_in]-player-[:played]-&amp;gt;likeThis-[:in]-&amp;gt;game, likeThis-[:for]-&amp;gt;team RETURN team.name, COUNT(game) AS redCards ORDER BY redCards LIMIT 5 +------------------------------+ | team.name | redCards | +------------------------------+ | &amp;#34;Sunderland&amp;#34; | 1 | | &amp;#34;West Ham United&amp;#34; | 1 | | &amp;#34;Norwich City&amp;#34; | 1 | | &amp;#34;Reading&amp;#34; | 1 | | &amp;#34;Liverpool&amp;#34; | 2 | +------------------------------+ 5 rows START game = node:matches(&#39;match_id:*&#39;) MATCH game&amp;lt;-[?:sent_off_in]-player-[:played]-&amp;gt;likeThis-[:in]-&amp;gt;game, likeThis-[:for]-&amp;gt;team RETURN team.name, COUNT(game) AS redCards ORDER BY redCards ASC LIMIT 5 +-----------------------------+ | team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Redundant relationships</title>
      <link>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</link>
      <pubDate>Tue, 16 Apr 2013 21:41:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:started|as_sub]-playedLike-[:in]-game-[r?:scored_in]-player WITH player, COUNT(DISTINCT game) AS games, COLLECT(r) AS allGoals RETURN player.name, games, LENGTH(allGoals) AS goals ORDER BY goals DESC LIMIT 5 +------------------------------------+ | player.name | games | goals | +------------------------------------+ | &amp;#34;Luis Suárez&amp;#34; | 30 | 22 | | &amp;#34;Robin Van Persie&amp;#34; | 30 | 19 | | &amp;#34;Gareth Bale&amp;#34; | 27 | 17 | | &amp;#34;Michu&amp;#34; | 29 | 16 | | &amp;#34;Demba Ba&amp;#34; | 28 | 15 | +------------------------------------+ 5 rows 1 ms START player = node:players(&#39;name:*&#39;) MATCH player-[:played]-playedLike-[:in]-game-[r?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CypherTypeException: Failed merging Number with Relationship</title>
      <link>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</link>
      <pubDate>Sun, 24 Mar 2013 13:00:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</guid>
      <description>game-[:on_tv]-channel START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?:on_tv]-channel RETURN player.name, COLLECT([stats.goals, t]) AS games LIMIT 10 CypherTypeException: Failed merging Number with Relationship START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?:on_tv]-channel RETURN player.name, COLLECT([stats.goals, TYPE(t)]) AS games LIMIT 10 +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | player.name | games | +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Djibril Cissé&amp;#34; | [[0,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;]] | | &amp;#34;Markus Rosenberg&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Gabriel Agbonlahor&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Shaun Derry&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Marouane Fellaini&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[2,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[2,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Jermaine Jenas&amp;#34; | [[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;]] | | &amp;#34;Sean Morrison&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Claudio Yacob&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Michael Owen&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Tony Hibbert&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 10 rows START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: WITH, COLLECT &amp; EXTRACT</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</link>
      <pubDate>Wed, 20 Mar 2013 02:54:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</guid>
      <description>START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[h:home_team|away_team]-game-[:on_day]-day RETURN DISTINCT day.name, COLLECT(TRIM(REPLACE(REPLACE(game.name, &amp;quot;Manchester United&amp;quot;, &amp;quot;&amp;quot;), &amp;quot;vs&amp;quot;, &amp;quot;&amp;quot;))) +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | day.name | opponents | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Sunday&amp;#34; | [&amp;#34;Liverpool&amp;#34;,&amp;#34;Everton&amp;#34;,&amp;#34;Southampton&amp;#34;,&amp;#34;Liverpool&amp;#34;,&amp;#34;Newcastle United&amp;#34;,&amp;#34;Chelsea&amp;#34;,&amp;#34;Manchester City&amp;#34;,&amp;#34;Swansea City&amp;#34;,&amp;#34;Tottenham Hotspur&amp;#34;] | | &amp;#34;Wednesday&amp;#34; | [&amp;#34;Southampton&amp;#34;,&amp;#34;West Ham United&amp;#34;,&amp;#34;Newcastle United&amp;#34;] | | &amp;#34;Monday&amp;#34; | [&amp;#34;Everton&amp;#34;] | | &amp;#34;Saturday&amp;#34; | [&amp;#34;Reading&amp;#34;,&amp;#34;Fulham&amp;#34;,&amp;#34;Wigan Athletic&amp;#34;,&amp;#34;Tottenham Hotspur&amp;#34;,&amp;#34;Stoke City&amp;#34;,&amp;#34;Arsenal&amp;#34;,&amp;#34;Queens Park Rangers&amp;#34;,&amp;#34;Sunderland&amp;#34;,&amp;#34;West Bromwich Albion&amp;#34;,&amp;#34;Norwich City&amp;#34;,&amp;#34;Reading&amp;#34;,&amp;#34;Aston Villa&amp;#34;,&amp;#34;Norwich City&amp;#34;,&amp;#34;Fulham&amp;#34;,&amp;#34;Queens Park Rangers&amp;#34;] | | &amp;#34;Tuesday&amp;#34; | [&amp;#34;Wigan Athletic&amp;#34;] | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 5 rows START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[h:home_team|away_team]-game-[:on_day]-day WITH day.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of the WITH statement</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</link>
      <pubDate>Wed, 20 Mar 2013 00:25:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</guid>
      <description>START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player, game-[:on_day]-day RETURN day.name, game.name +---------------------------------------------------+ | day.name | game.name | +---------------------------------------------------+ | &amp;#34;Saturday&amp;#34; | &amp;#34;Liverpool vs Southampton&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;Southampton vs Liverpool&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;Liverpool vs Reading&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;West Bromwich Albion vs Liverpool&amp;#34; | ... +---------------------------------------------------+ 29 rows START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player, game-[:on_day]-day RETURN day.name, COUNT(game.name) +--------------------------------+ | day.name | COUNT(game.name) | +--------------------------------+ | &amp;#34;Sunday&amp;#34; | 13 | | &amp;#34;Wednesday&amp;#34; | 4 | | &amp;#34;Monday&amp;#34; | 1 | | &amp;#34;Saturday&amp;#34; | 11 | +--------------------------------+ 4 rows START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player-[r?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY WITH LIMIT query</title>
      <link>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</link>
      <pubDate>Mon, 18 Mar 2013 23:19:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</guid>
      <description>START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[:home_team|away_team]-game-[:scored_in]-player-[:played]-stats-[:for]-team, stats-[:in]-game RETURN DISTINCT player.name, stats.goals, game.name +--------------------------------------------------------------------------------+ | player.name | stats.goals | game.name | +--------------------------------------------------------------------------------+ | &amp;#34;Javier Hernández&amp;#34; | 1 | &amp;#34;Manchester United vs Wigan Athletic&amp;#34; | | &amp;#34;Robin Van Persie&amp;#34; | 1 | &amp;#34;Manchester United vs Sunderland&amp;#34; | | &amp;#34;Danny Welbeck&amp;#34; | 1 | &amp;#34;Manchester United vs Stoke City&amp;#34; | | &amp;#34;Rafael&amp;#34; | 1 | &amp;#34;Queens Park Rangers vs Manchester United&amp;#34; | | &amp;#34;Wayne Rooney&amp;#34; | 1 | &amp;#34;Manchester United vs Norwich City&amp;#34; | | &amp;#34;Shinji Kagawa&amp;#34; | 1 | &amp;#34;Manchester United vs Fulham&amp;#34; | | &amp;#34;Shinji Kagawa&amp;#34; | 3 | &amp;#34;Manchester United vs Norwich City&amp;#34; | .</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding football stadiums near a city using spatial</title>
      <link>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</link>
      <pubDate>Sun, 10 Mar 2013 22:13:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</guid>
      <description>$ git clone git://github.com/neo4j/spatial.git spatial $ cd spatial $ mvn clean package -Dmaven.test.skip=true install $ unzip target/neo4j-spatial-0.11-SNAPSHOT-server-plugin.zip -d /path/to/neo4j-community-1.9.M04/plugins/ $ /path/to/neo4j-community-1.9.M04/bin/neo4j restart $ curl -L http://localhost:7474/db/data { &amp;#34;extensions&amp;#34; : { ... &amp;#34;SpatialPlugin&amp;#34; : { &amp;#34;addEditableLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addEditableLayer&amp;#34;, &amp;#34;addCQLDynamicLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addCQLDynamicLayer&amp;#34;, &amp;#34;findGeometriesWithinDistance&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/findGeometriesWithinDistance&amp;#34;, &amp;#34;updateGeometryFromWKT&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/updateGeometryFromWKT&amp;#34;, &amp;#34;addGeometryWKTToLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addGeometryWKTToLayer&amp;#34;, &amp;#34;getLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/getLayer&amp;#34;, &amp;#34;addSimplePointLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addSimplePointLayer&amp;#34;, &amp;#34;findGeometriesInBBox&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/findGeometriesInBBox&amp;#34;, &amp;#34;addNodeToLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addNodeToLayer&amp;#34; }, … }, ... &amp;#34;neo4j_version&amp;#34; : &amp;#34;1.9.M04&amp;#34; Name,Team,Capacity,Latitude,Longitude &amp;#34;Adams Park&amp;#34;,&amp;#34;Wycombe Wanderers&amp;#34;,10284,51.</description>
    </item>
    
    <item>
      <title>neo4j: Make properties relationships</title>
      <link>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</link>
      <pubDate>Wed, 06 Mar 2013 00:59:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</guid>
      <description>MATCH-[:in_month]-&amp;gt;MONTH START player = node:players(&#39;name:&amp;quot;Gareth Bale&amp;quot;&#39;), month=node:months(&#39;name:September&#39;) MATCH player-[:played_in]-game WHERE game-[:in_month]-month RETURN game.name, game.home_goals + &amp;quot;-&amp;quot; +game.away_goals AS score, game.date +----------------------------------------------------------------------------------+ | game.name | score | game.date | +----------------------------------------------------------------------------------+ | &amp;#34;Reading vs Tottenham Hotspur&amp;#34; | &amp;#34;1-3&amp;#34; | &amp;#34;2012-09-16 16:00:00 +0100&amp;#34; | | &amp;#34;Tottenham Hotspur vs Norwich City&amp;#34; | &amp;#34;1-1&amp;#34; | &amp;#34;2012-09-01 15:00:00 +0100&amp;#34; | | &amp;#34;Tottenham Hotspur vs Queens Park Rangers&amp;#34; | &amp;#34;2-1&amp;#34; | &amp;#34;2012-09-23 16:00:00 +0100&amp;#34; | | &amp;#34;Manchester United vs Tottenham Hotspur&amp;#34; | &amp;#34;2-3&amp;#34; | &amp;#34;2012-09-29 17:30:00 +0100&amp;#34; | +----------------------------------------------------------------------------------+ START month=node:months(&#39;name:December&#39;) MATCH month-[:in_month]-game WHERE ABS(game.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Combining COUNT and COLLECT in one query</title>
      <link>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</link>
      <pubDate>Sun, 24 Feb 2013 19:19:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:missed_penalty_in]-game, player-[:played|subbed_on]-stats-[:in]-game, stats-[:for]-team, game-[:home_team]-home, game-[:away_team]-away RETURN player.name, team.name, home.name, away.name +-------------------------------------------------------------------------------------------------+ | player.name | team.name | home.name | away.name | +-------------------------------------------------------------------------------------------------+ | &amp;#34;Papiss Demba Cisse&amp;#34; | &amp;#34;Newcastle United&amp;#34; | &amp;#34;Newcastle United&amp;#34; | &amp;#34;Norwich City&amp;#34; | | &amp;#34;Wayne Rooney&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Arsenal&amp;#34; | | &amp;#34;Mikel Arteta&amp;#34; | &amp;#34;Arsenal&amp;#34; | &amp;#34;Arsenal&amp;#34; | &amp;#34;Fulham&amp;#34; | | &amp;#34;David Silva&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Southampton&amp;#34; | | &amp;#34;Frank Lampard&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Chelsea&amp;#34; | | &amp;#34;Adel Taarabt&amp;#34; | &amp;#34;Queens Park Rangers&amp;#34; | &amp;#34;Queens Park Rangers&amp;#34; | &amp;#34;Norwich City&amp;#34; | | &amp;#34;Javier Hernández&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Wigan Athletic&amp;#34; | | &amp;#34;Robin Van Persie&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Southampton&amp;#34; | &amp;#34;Manchester United&amp;#34; | | &amp;#34;Jonathan Walters&amp;#34; | &amp;#34;Stoke City&amp;#34; | &amp;#34;Fulham&amp;#34; | &amp;#34;Stoke City&amp;#34; | | &amp;#34;Shane Long&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | &amp;#34;Liverpool&amp;#34; | | &amp;#34;Steven Gerrard&amp;#34; | &amp;#34;Liverpool&amp;#34; | &amp;#34;Liverpool&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | | &amp;#34;Lucas Piazon&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Aston Villa&amp;#34; | +-------------------------------------------------------------------------------------------------+ 12 rows START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:missed_penalty_in]-game, player-[:played|subbed_on]-stats-[:in]-game, stats-[:for]-team RETURN DISTINCT team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Using a WHERE clause to filter paths</title>
      <link>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</link>
      <pubDate>Tue, 19 Feb 2013 00:03:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</guid>
      <description>START team = node:teams(&amp;#39;name:&amp;#34;Arsenal&amp;#34;&amp;#39;) MATCH team-[:home_team|away_team]-game-[:played_in]-player RETURN player.name, COUNT(player.name) as games ORDER BY games desc ------------------------------+ | player.name | games | +------------------------------+ | &amp;#34;Cazorla&amp;#34; | 25 | | &amp;#34;Arteta&amp;#34; | 22 | | &amp;#34;Mertesacker&amp;#34; | 22 | | &amp;#34;Vermaelen&amp;#34; | 22 | | &amp;#34;Podolski&amp;#34; | 21 | | &amp;#34;Gibbs&amp;#34; | 18 | | &amp;#34;Szczesny&amp;#34; | 17 | … | &amp;#34;Tiote&amp;#34; | 1 | | &amp;#34;Diame&amp;#34; | 1 | | &amp;#34;Ridgewell&amp;#34; | 1 | | &amp;#34;Lampard&amp;#34; | 1 | | &amp;#34;Bramble&amp;#34; | 1 | | &amp;#34;Simpson&amp;#34; | 1 | +------------------------------+ 258 rows START team = node:teams(&amp;#39;name:&amp;#34;Arsenal&amp;#34;&amp;#39;) MATCH team-[:home_team|away_team]-game-[:played_in]-player, player-[:played]-()-[:for]-team RETURN player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY functionality</title>
      <link>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</link>
      <pubDate>Sun, 17 Feb 2013 21:05:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month RETURN player.name, month.name +----------------------------+ | player.name | month.name | +----------------------------+ | &amp;#34;Jenkinson&amp;#34; | &amp;#34;February&amp;#34; | | &amp;#34;Chico&amp;#34; | &amp;#34;September&amp;#34; | | &amp;#34;Odemwingie&amp;#34; | &amp;#34;September&amp;#34; | | &amp;#34;Agger&amp;#34; | &amp;#34;August&amp;#34; | | &amp;#34;Cole&amp;#34; | &amp;#34;December&amp;#34; | | &amp;#34;Whitehead&amp;#34; | &amp;#34;August&amp;#34; | ... +----------------------------+ START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month RETURN COUNT(player.name) AS numberOfReds, month.name ORDER BY numberOfReds DESC +----------------------------+ | numberOfReds | month.name | +----------------------------+ | 7 | &amp;#34;October&amp;#34; | | 6 | &amp;#34;December&amp;#34; | | 4 | &amp;#34;September&amp;#34; | | 4 | &amp;#34;November&amp;#34; | | 3 | &amp;#34;August&amp;#34; | | 2 | &amp;#34;January&amp;#34; | | 2 | &amp;#34;February&amp;#34; | +----------------------------+ START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month, game-[:in_match]-stats-[:stats]-player, stats-[:played_for]-team RETURN player.</description>
    </item>
    
    <item>
      <title>Data Science: Don&#39;t filter data prematurely</title>
      <link>https://markhneedham.com/blog/2013/02/17/data-science-dont-filter-data-prematurely/</link>
      <pubDate>Sun, 17 Feb 2013 20:02:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/17/data-science-dont-filter-data-prematurely/</guid>
      <description></description>
    </item>
    
    <item>
      <title>neo4j: Handling SUM&#39;s scientific notation</title>
      <link>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</link>
      <pubDate>Sun, 30 Sep 2012 19:47:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</guid>
      <description>In some of the recent work I&amp;rsquo;ve been doing with neo4j the queries I&amp;rsquo;ve written have been summing up the values from multiple nodes and after a certain number is reached the value returned used scientific notation.
For example in a cypher query like this:
START category = node:categories(&amp;#39;category_id:1&amp;#39;) MATCH p = category-[:has_child*1..5]-&amp;gt;subCategory-[:has_product]-&amp;gt;product-[:sold]-&amp;gt;sales RETURN EXTRACT(n in NODES(p) : n.category_id?),subCategory.category_id, SUM(sales.sales) I might get a result set like this:
+------------------------------------------------------------------------------------------------+ | EXTRACT(n in NODES(p) : n.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CREATE UNIQUE - &#34;SyntaxException: string matching regex `$&#39; expected but `p&#39; found&#34;</title>
      <link>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</link>
      <pubDate>Sun, 09 Sep 2012 22:29:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</guid>
      <description>I&amp;rsquo;ve been playing around with the mutating cypher syntax of neo4j which allows you to make changes to the graph as well as query it, a feature introduced into cypher in May in release 1.8 M01.
I was trying to make use of the &amp;lsquo;CREATE UNIQUE&amp;rsquo; syntax which allows you to create nodes/relationships if they&amp;rsquo;re missing but won&amp;rsquo;t do anything if they already exists.
I had something like the following:</description>
    </item>
    
    <item>
      <title>neo4j: Multiple starting nodes by index lookup</title>
      <link>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</link>
      <pubDate>Sat, 28 Jul 2012 23:32:28 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</guid>
      <description>I spent a bit of time this evening extracting some data from the ThoughtWorks graph for our marketing team who were interested in anything related to our three European offices in London, Manchester and Hamburg.
The most interesting things we can explore relate to the relationship between people and the offices.
The model around people and offices looks like this:
I added a &amp;lsquo;current_home_office&amp;rsquo; relationship to make it easier to quickly get to the nodes of people who are currently working in a specific office.</description>
    </item>
    
    <item>
      <title>neo4j: Graph Global vs Graph Local queries</title>
      <link>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</link>
      <pubDate>Mon, 23 Jul 2012 22:23:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</guid>
      <description>A few weeks ago I did a presentation at the ThoughtWorks EU away day on the graph I&amp;rsquo;ve been developing using neo4j and I wanted to show who the most connected people in each of our European offices were.
I started with the following cypher query:
START n = node(*) MATCH n-[r:colleagues*1..2]-&amp;gt;c, n-[r2:member_of]-&amp;gt;office WHERE n.type? = &amp;#39;person&amp;#39; AND (NOT(HAS(r2.end_date))) AND office.name = &amp;#39;London - UK South&amp;#39; AND (NOT(HAS(c.thoughtquitter))) RETURN n.name, count(distinct(c)) AS connections, office.</description>
    </item>
    
    <item>
      <title>neo4j: Embracing the sub graph</title>
      <link>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</link>
      <pubDate>Sat, 21 Jul 2012 22:46:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</guid>
      <description>In May I wrote a blog post explaining how I&amp;rsquo;d been designing a neo4j graph by thinking about what questions I wanted to answer about the data.
In the comments Josh Adell gave me the following advice:
Keep your data model rich! Don&amp;rsquo;t be afraid to have as many relationships as you need. The power of graph databases comes from finding surprising results when you have strongly interconnected data.
At the time I didn&amp;rsquo;t really understand the advice but I&amp;rsquo;ve since updated my graph so that it includes &amp;lsquo;colleagues&amp;rsquo; relationships which can be derived by looking at the projects that people had worked together on.</description>
    </item>
    
    <item>
      <title>neo4j: Shortest Path with and without cypher</title>
      <link>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</link>
      <pubDate>Thu, 19 Jul 2012 19:57:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</guid>
      <description>I was looking back at some code I wrote a few months ago to query a neo4j database to find the shortest path between two people via the colleagues relationships that exist.
The initial code, written using neography, looked like this:
neo = Neography::Rest.new start_node = neo.get_node(start_node_id) destination_node = neo.get_node(destination_node_id) neo.get_paths(start_node, destination_node, { &amp;#34;type&amp;#34; =&amp;gt; &amp;#34;colleagues&amp;#34; }, depth = 3, algorithm = &amp;#34;shortestPath&amp;#34;) The neography code eventually makes a POST request to /node/{start_id}/pathsand provides a JSON payload containing the other information about the query.</description>
    </item>
    
    <item>
      <title>neo4j: Handling optional relationships</title>
      <link>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</link>
      <pubDate>Sun, 24 Jun 2012 23:32:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</guid>
      <description>On my ThoughtWorks neo4j there are now two different types of relationships between people nodes - they can either be colleagues or one can be the sponsor of the other.
The graph looks like this:
I wanted to get a list of all the sponsor pairs but also have some indicator of whether the two people have worked together.
I started off by getting all of the sponsor pairs:
START n = node(*) MATCH n-[r:sponsor_of]-&amp;gt;n2 RETURN n.</description>
    </item>
    
    <item>
      <title>Visualising a neo4j graph using gephi</title>
      <link>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</link>
      <pubDate>Thu, 21 Jun 2012 05:02:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</guid>
      <description>At ThoughtWorks we don&amp;rsquo;t have line managers but people can choose to have a sponsor - typically someone who has worked in the company for longer/has more experience in the industry than them - who can help them navigate the organisation better.
From hearing people talk about sponsors over the last 6 years it seemed like quite a few people sponsored the majority and there were probably a few people who didn&amp;rsquo;t have a sponsor.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the most connected node on the graph</title>
      <link>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</link>
      <pubDate>Sat, 16 Jun 2012 10:41:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</guid>
      <description>As I mentioned in another post about a month agoI&amp;rsquo;ve been playing around with a neo4j graph in which I have the following relationship between nodes:
One thing I wanted to do was work out which node is the most connected on the graph, which would tell me who&amp;rsquo;s worked with the most people.
I started off with the following cypher query:
query = &amp;#34; START n = node(*)&amp;#34; query &amp;lt;&amp;lt; &amp;#34; MATCH n-[r:colleagues]-&amp;gt;c&amp;#34; query &amp;lt;&amp;lt; &amp;#34; WHERE n.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the shortest path between two nodes while applying predicates</title>
      <link>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</link>
      <pubDate>Sat, 12 May 2012 14:55:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</guid>
      <description>As I mentioned in a blog post about a week agoI decided to restructure the ThoughtWorks graph I&amp;rsquo;ve modelled in neo4j so that I could explicitly model projects and clients.
As a result I had to update a traversal I&amp;rsquo;d written for finding the shortest path between two people in the graph.
The original traversal query I had was really simple because I had a direct connection between the people nodes:</description>
    </item>
    
    <item>
      <title>neo4J: Searching for nodes by name</title>
      <link>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</link>
      <pubDate>Fri, 20 Apr 2012 07:10:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</guid>
      <description>As I mentioned in a post a few days ago I&amp;rsquo;ve been graphing connections between ThoughtWorks people using neo4j and wanted to build auto complete functionality so I can search for the names of people in the graph.
The solution I came up was to create a Lucene index with an entry for each node and a common property on each document in the index so that I&amp;rsquo;d be able to get all the index entries easily.</description>
    </item>
    
  </channel>
</rss>