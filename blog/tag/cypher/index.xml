<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cypher on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/cypher/</link>
    <description>Recent content in Cypher on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 05 Sep 2019 00:47:00 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/cypher/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Neo4j: apoc.load.csv - Neo.ClientError.Statement.SyntaxError: Type mismatch: expected Float, Integer, Number or String but was Any </title>
      <link>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</link>
      <pubDate>Thu, 05 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</guid>
      <description>The Neo4j APOC library&#39;s Load CSV procedure is very useful if you want more control over the import process than the LOAD CSV clause allows. I found myself using it last week to import a CSV file of embeddings, because I wanted to know the line number of the row in the CSV file while importing the data.
 I had a file that looked like this, which I put into the import directory:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions vs OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</link>
      <pubDate>Fri, 23 Aug 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</guid>
      <description>While writing my previous post about Cypher nested path comprehensions, I realised that for this particular problem, the OPTIONAL MATCH clause is a better choice.
 To recap, we have the following graph:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;}) MERGE (club2)-[:IN_LEAGUE]-&amp;gt;(league2)     We started the post with the following query that returns (club)-[:IN_LEAGUE]&amp;#8594;(league)-[:IN_COUNTRY]&amp;#8594;(country) paths:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions</title>
      <link>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</link>
      <pubDate>Thu, 22 Aug 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</guid>
      <description>I&amp;#8217;ve recently been building an application using the GRANDstack, which uses nested Cypher path comprehensions to translate GraphQL queries to Cypher ones. I&amp;#8217;d not done this before, so I was quite curious how this feature worked. We&amp;#8217;ll explore it using the following dataset:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Conditional WHERE clause with APOC</title>
      <link>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</link>
      <pubDate>Wed, 31 Jul 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</guid>
      <description>Sometimes we want to be able to vary our Cypher queries based on the value of a parameter. I came across such a situation today, and thought I&amp;#8217;d share how I solved it using the APOC library.
 Let&amp;#8217;s first setup some sample data:
 UNWIND range(0, 5) AS id CREATE (:Person {name: &#34;person-&#34; + id})   Now, if we want to get all pairs of people, we could write the following query:</description>
    </item>
    
    <item>
      <title>Neo4j: keep/filter keys in a map using APOC</title>
      <link>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</link>
      <pubDate>Sun, 12 May 2019 17:58:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</guid>
      <description>In this post we&amp;#8217;ll learn how to write a Cypher query to create a node in Neo4j containing some of the keys from a map. This post assumes that the APOC library is installed.
 We&amp;#8217;ll start by creating a map that contains data from my twitter profile:
 :param document =&amp;gt; { id: 14707949, name: &#34;Mark Needham&#34;, username: &#34;markhneedham&#34;, bio: &#34;Developer Relations @neo4j&#34;, location: &#34;London, United Kingdom&#34;, url: &#34;http://www.markhneedham.com&#34;, join_date: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Delete all nodes</title>
      <link>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</link>
      <pubDate>Sun, 14 Apr 2019 12:52:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</guid>
      <description>When experimenting with a new database, at some stage we&amp;#8217;ll probably want to delete all our data and start again. I was trying to do this with Neo4j over the weekend and it didn&amp;#8217;t work as I expected, so I thought I&amp;#8217;d write the lessons I learned.
 We&amp;#8217;ll be using Neo4j via the Neo4j Desktop with the default settings. This means that we have a maximum heap size of 1GB.</description>
    </item>
    
    <item>
      <title>Neo4j: Delete/Remove dynamic properties</title>
      <link>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</link>
      <pubDate>Thu, 14 Mar 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</guid>
      <description>Irfan and I were playing with a dataset earlier today, and having run a bunch of graph algorithms, we had a lot of properties that we wanted to clear out.
 The following Cypher query puts Neo4j into the state that we were dealing with.
 CREATE (:Node {name: &#34;Mark&#34;, pagerank: 2.302, louvain: 1, lpa: 4 }) CREATE (:Node {name: &#34;Michael&#34;, degree: 23, triangles: 12, betweeness: 48.70 }) CREATE (:Node {name: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Date ranges</title>
      <link>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</link>
      <pubDate>Sun, 13 Jan 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</guid>
      <description>As part of a dataset I&amp;#8217;ve been working with this week, I wanted to generate a collection of a range of dates using the Cypher query language.
 I&amp;#8217;ve previously used the duration function, which lets you add (or subtract) from a specific date, so I thought I&amp;#8217;d start from there. If we want to find the day after 1st January 2019, we could write the following query:
 neo4j&amp;gt; WITH date(&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Remove consecutive duplicates from a list</title>
      <link>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</link>
      <pubDate>Sat, 12 Jan 2019 04:32:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</guid>
      <description>I was playing with a dataset this week and wanted to share how I removes duplicate consecutive elements from a list using the Cypher query language.
 For simplicity&amp;#8217;s sake, imagine that we have this list:
 neo4j&amp;gt; return [1,2,3,3,4,4,4,5,3] AS values; +-----------------------------+ | values | +-----------------------------+ | [1, 2, 3, 3, 4, 4, 4, 5, 3] | +-----------------------------+   We want to remove the duplicate 3&amp;#8217;s and 4&amp;#8217;s, such that our end result should be:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Grouping Datetimes</title>
      <link>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</link>
      <pubDate>Tue, 10 Jul 2018 04:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</guid>
      <description>In my continued analysis of Strava runs I wanted to try and find my best runs grouped by different time components, which was actually much easier than I was expecting.
 Importing the dataset If you want to try out the examples below you can execute the following LOAD CSV commands to load the data:
 LOAD CSV WITH HEADERS FROM &#34;https://github.com/mneedham/strava/raw/master/runs.csv&#34; AS row MERGE (run:Run {id: toInteger(row.id)}) SET run.distance = toFloat(row.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Syntax Error - Text cannot be parsed to a Duration (aka dealing with empty durations)</title>
      <link>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</link>
      <pubDate>Mon, 09 Jul 2018 18:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</guid>
      <description>As I continued with my travels with Neo4j 3.4&amp;#8217;s temporal data type I came across some fun edge cases when dealing with empty durations while importing data.
 Imagine we&amp;#8217;re trying to create 3 nodes from the following array of input data. Two of the rows have invalid durations!
 UNWIND [ {id: 12345, duration: &#34;PT2M20S&#34;}, {id: 12346, duration: &#34;&#34;}, {id: 12347, duration: null} ] AS row MERGE (run:Run {id: row.</description>
    </item>
    
    <item>
      <title>Neo4j: Querying the Strava Graph using Py2neo</title>
      <link>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</link>
      <pubDate>Fri, 15 Jun 2018 13:45:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</guid>
      <description>Last week Nigel released v4 of Py2neo and given I was just getting ready to write some queries against my Strava activity graph I thought I&amp;#8217;d give it a try.
 If you want to learn how to create your own Strava graph you should read my previous post, but just to recap, this is the graph model that we created:
   Let&amp;#8217;s get to it!
 tl;dr the code in this post is available as a Jupyter notebook so if you want the code and nothing but the code head over there!</description>
    </item>
    
    <item>
      <title>Neo4j: Building a graph of Strava activities</title>
      <link>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</guid>
      <description>In my last post I showed how to import activities from Strava&amp;#8217;s API into Neo4j using only the APOC library, but that was only part of the graph so I thought I&amp;#8217;d share the rest of what I&amp;#8217;ve done.
 The Graph Model In the previous post I showed how to import nodes with Run label, but there are some other pieces of data that I wanted to import as well.</description>
    </item>
    
    <item>
      <title>Neo4j APOC: Importing data from Strava&#39;s paginated JSON API</title>
      <link>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</link>
      <pubDate>Tue, 05 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</guid>
      <description>Over the weekend I&amp;#8217;ve been playing around with loading data from the Strava API into Neo4j and I started with the following Python script which creates a node with a Run label for each of my activities.
 If you want to follow along on your own data you&amp;#8217;ll need to get an API key via the &#39;My API Application&#39; section of the website. Once you&amp;#8217;ve got that put it in the TOKEN environment variable and you should be good to go.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Gotchas when working with Durations</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</link>
      <pubDate>Sun, 03 Jun 2018 20:11:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</guid>
      <description>Continuing with my explorations of Strava data in Neo4j I wanted to share some things I learnt while trying to work out my pace for certain distances.
 Before we get into the pace calculations let&amp;#8217;s first understand how the duration function works. If we run the following query we might expect to get back the same value that we put in&amp;#8230;&amp;#8203;
 RETURN duration({seconds: 413.77}).seconds AS seconds   ╒═════════╕ │&#34;</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Formatting instances of the Duration and Datetime date types</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</link>
      <pubDate>Sun, 03 Jun 2018 04:08:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</guid>
      <description>In my last blog post I showed how to compare instances of Neo4j&amp;#8217;s Duration data type, and in the middle of the post I realised that I needed to use the APOC library to return the value in the format I wanted. This was the solution I ended up with:
 WITH duration({seconds: 100}) AS duration RETURN apoc.text.lpad(toString(duration.minutes), 2, &#34;0&#34;) + &#34;:&#34; + apoc.text.lpad(toString(duration.secondsOfMinute), 2, &#34;0&#34;)   If we run that query this is the output:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Comparing durations</title>
      <link>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</link>
      <pubDate>Sat, 02 Jun 2018 03:24:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</guid>
      <description>Neo4j 3.4 saw the introduction of the temporal date type, which my colleague Adam Cowley covered in his excellent blog post, and in this post I want to share my experience using durations from my Strava runs.
 I&amp;#8217;ll show how to load the whole Strava dataset in another blog post but for now we&amp;#8217;ll just manually create some durations based on the elapsed time in seconds that Strava provides. We can run the following query to convert duration in seconds into the duration type:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Neo.ClientError.Statement.TypeError: Don&#39;t know how to add Double and String</title>
      <link>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</link>
      <pubDate>Wed, 14 Mar 2018 16:53:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</guid>
      <description>I recently upgraded a Neo4j backed application from Neo4j 3.2 to Neo4j 3.3 and came across an interesting change in behaviour around type coercion which led to my application throwing a bunch of errors.  In Neo4j 3.2 and earlier if you added a String to a Double it would coerce the Double to a String and concatenate the values. The following would therefore be valid Cypher: RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; ╒══════════╕ │&amp;quot;result&amp;quot; │ ╞══════════╡ │&amp;quot;1.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Property values can only be of primitive types or arrays thereof.</title>
      <link>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</link>
      <pubDate>Fri, 01 Dec 2017 22:09:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</guid>
      <description>I ran into an interesting Cypher error message earlier this week while trying to create an array property on a node which I thought I&#39;d share.  This was the Cypher query I wrote: CREATE (:Person {id: [1, &amp;quot;mark&amp;quot;, 2.0]})  which results in this error:
Neo.ClientError.Statement.TypeError Property values can only be of primitive types or arrays thereof.   We actually are storing an array of primitives but we have a mix of different types which isn&#39;t allowed.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Deleting duplicate nodes</title>
      <link>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</link>
      <pubDate>Fri, 06 Oct 2017 16:13:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</guid>
      <description>I had a problem on a graph I was working on recently where I&#39;d managed to create duplicate nodes because I hadn&#39;t applied any unique constraints.  I wanted to remove the duplicates, and came across Jimmy Ruts&#39; excellent post which shows some ways to do this.  Let&#39;s first create a graph with some duplicate nodes to play with: UNWIND range(0, 100) AS id CREATE (p1:Person {id: toInteger(rand() * id)}) MERGE (p2:Person {id: toInteger(rand() * id)}) MERGE (p3:Person {id: toInteger(rand() * id)}) MERGE (p4:Person {id: toInteger(rand() * id)}) CREATE (p1)-[:KNOWS]-&amp;gt;(p2) CREATE (p1)-[:KNOWS]-&amp;gt;(p3) CREATE (p1)-[:KNOWS]-&amp;gt;(p4) Added 173 labels, created 173 nodes, set 173 properties, created 5829 relationships, completed after 408 ms.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Create Cypher map with dynamic keys</title>
      <link>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</link>
      <pubDate>Tue, 19 Sep 2017 19:30:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</guid>
      <description>I was recently trying to create a map in a Cypher query but wanted to have dynamic keys in that map. I started off with this query: WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN { dynamicKey: dynamicValue } AS map ╒══════════════════╕ │&amp;quot;map&amp;quot; │ ╞══════════════════╡ │{&amp;quot;dynamicKey&amp;quot;:&amp;quot;b&amp;quot;}│ └──────────────────┘   Not quite what we want! We want dynamicKey to be evaluated rather than treated as a literal. As usual, APOC comes to the rescue!</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding of floating point numbers/BigDecimals</title>
      <link>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</link>
      <pubDate>Sun, 13 Aug 2017 07:23:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</guid>
      <description>I was doing some data cleaning a few days ago and wanting to multiply a value by 1 million. My Cypher code to do this looked like this: with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(rawNumeric) * 1000000 AS numeric ╒═════════════════╕ │&amp;quot;numeric&amp;quot; │ ╞═════════════════╡ │8369999.999999999│ └─────────────────┘   Unfortunately that suffers from the classic rounding error when working with floating point numbers. I couldn&#39;t figure out a way to solve it using pure Cypher, but there tends to be an APOC function to solve every problem and this was no exception.</description>
    </item>
    
    <item>
      <title>Neo4j: Analysing a CSV file using LOAD CSV and Cypher</title>
      <link>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</link>
      <pubDate>Sun, 19 Feb 2017 22:39:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</guid>
      <description>Last week we ran our first online meetup for several years and I wanted to wanted to analyse the stats that YouTube lets you download for an event.  The file I downloaded looked like this: $ cat ~/Downloads/youtube_stats_pW9boJoUxO0.csv Video IDs:, pW9boJoUxO0, Start time:, Wed Feb 15 08:57:55 2017, End time:, Wed Feb 15 10:03:10 2017 Playbacks, Peak concurrent viewers, Total view time (hours), Average session length (minutes) 348, 112, 97.</description>
    </item>
    
    <item>
      <title>Neo4j: Find the midpoint between two lat/longs</title>
      <link>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</link>
      <pubDate>Mon, 31 Oct 2016 19:31:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</guid>
      <description>Over the last couple of weekends I&#39;ve been playing around with some transport data and I wanted to run the A* algorithm to find the quickest route between two stations.
The A* algorithm takes an estimateEvaluator as one of its parameters and the evaluator looks at lat/longs of nodes to work out whether a path is worth following or not. I therefore needed to add lat/longs for each station and I found it surprisingly hard to find this location date for all the points in the dataset.</description>
    </item>
    
    <item>
      <title>Neo4j: Create dynamic relationship type</title>
      <link>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</link>
      <pubDate>Sun, 30 Oct 2016 22:12:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</guid>
      <description>One of the things I&#39;ve often found frustrating when importing data using Cypher, Neo4j&#39;s query language, is that it&#39;s quite difficult to create dynamic relationship types. Say we have a CSV file structured like this:
load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row RETURN row  ╒═══════════════════════════════════════════════════════╕ │row │ ╞═══════════════════════════════════════════════════════╡ │{node1: Mark, node2: Reshmee, relationship: MARRIED_TO}│ ├───────────────────────────────────────────────────────┤ │{node1: Mark, node2: Alistair, relationship: FRIENDS} │ └───────────────────────────────────────────────────────┘  We want to create nodes with the relationship type specified in the file.</description>
    </item>
    
    <item>
      <title>Neo4j: Procedure call inside a query does not support passing arguments implicitly (pass explicitly after procedure name instead)</title>
      <link>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</link>
      <pubDate>Sun, 02 Oct 2016 10:13:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</guid>
      <description>A couple of days I was trying to write a Cypher query to filter the labels in my database. I started with the following procedure call to get the list of all the labels:
CALL db.labels  ╒══════════╕ │label │ ╞══════════╡ │Airport │ ├──────────┤ │Flight │ ├──────────┤ │Airline │ ├──────────┤ │Movie │ ├──────────┤ │AirportDay│ ├──────────┤ │Person │ ├──────────┤ │Engineer │ └──────────┘  I was only interested in labels that contained the letter &#39;a&#39; so I tweaked the query to filter the output of the procedure: CALL db.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Detecting duplicates using relationships</title>
      <link>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</link>
      <pubDate>Wed, 20 Jul 2016 17:32:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</guid>
      <description>I&#39;ve been building a graph of computer science papers on and off for a couple of months and now that I&#39;ve got a few thousand loaded in I realised that there are quite a few duplicates.  They&#39;re not duplicates in the sense that there are multiple entries with the same identifier but rather have different identifiers but seem to be the same paper!  e.g. there are a couple of papers titled &#39;Authentication in the Taos operating system&#39;:  http://dl.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Removing consecutive duplicates</title>
      <link>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</link>
      <pubDate>Thu, 30 Jul 2015 06:23:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</guid>
      <description>When writing Cypher queries I sometimes find myself wanting to remove consecutive duplicates in collections that I&#39;ve joined together. e.g we might start with the following query where 1 and 7 appear consecutively:
RETURN [1,1,2,3,4,5,6,7,7,8] AS values ==&amp;gt; +-----------------------+ ==&amp;gt; | values | ==&amp;gt; +-----------------------+ ==&amp;gt; | [1,1,2,3,4,5,6,7,7,8] | ==&amp;gt; +-----------------------+ ==&amp;gt; 1 row   We want to end up with [1,2,3,4,5,6,7,8]. We can start by exploding our array and putting consecutive elements next to each other: WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx RETURN idx, idx+1, values[idx], values[idx+1] ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | idx | idx+1 | values[idx] | values[idx+1] | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | 0 | 1 | 1 | 1 | ==&amp;gt; | 1 | 2 | 1 | 2 | ==&amp;gt; | 2 | 3 | 2 | 3 | ==&amp;gt; | 3 | 4 | 3 | 4 | ==&amp;gt; | 4 | 5 | 4 | 5 | ==&amp;gt; | 5 | 6 | 5 | 6 | ==&amp;gt; | 6 | 7 | 6 | 7 | ==&amp;gt; | 7 | 8 | 7 | 7 | ==&amp;gt; | 8 | 9 | 7 | 8 | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; 9 rows  Next we can filter out rows which have the same values since that means they have consecutive duplicates:</description>
    </item>
    
    <item>
      <title>Neo4j: Finding all shortest paths</title>
      <link>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</link>
      <pubDate>Tue, 19 May 2015 22:45:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</guid>
      <description>One of the Cypher language features we show in Neo4j training courses is the shortest path function which allows you to find the shortest path in terms of number of relationships between two nodes.  Using the movie graph, which you can import via the &#39;:play movies&#39; command in the browser, we&#39;ll first create a &#39;KNOWS&#39; relationship between any people that have appeared in the same movie: MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;()&amp;lt;-[:ACTED_IN]-(p2:Person) MERGE (p1)-[:KNOWS]-(p2)  Now that we&#39;ve got that relationship we can easily find the shortest path between two people, say Tom Cruise and Tom Hanks:</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - java.io.InputStreamReader there&#39;s a field starting with a quote and whereas it ends that quote there seems  to be character in that field after that ending quote. That isn&#39;t supported.</title>
      <link>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</link>
      <pubDate>Mon, 04 May 2015 09:56:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</guid>
      <description>I recently came across the last.fm dataset via Ben Frederickson&#39;s blog and thought it&#39;d be an interesting one to load into Neo4j and explore.  I started with a simple query to parse the CSV file and count the number of rows: LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/neo4j-recommendations/lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv&amp;quot; AS row FIELDTERMINATOR &amp;quot;\t&amp;quot; return COUNT(*) At java.io.InputStreamReader@4d307fda:6484 there&#39;s a field starting with a quote and whereas it ends that quote there seems to be character in that field after that ending quote.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1.6 - Cypher: FOREACH slowness</title>
      <link>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</link>
      <pubDate>Sun, 28 Dec 2014 04:28:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</guid>
      <description>A common problem that people have when using Neo4j for social network applications is updating a person with their newly imported friends.  We&#39;ll have an array of friends that we want to connect to a single Person node. Assuming the following schema...
$ schema Indexes ON :Person(id) ONLINE No constraints  ...a simplified version would look like this: WITH range (2,1002) AS friends MERGE (p:Person {id: 1}) FOREACH(f IN friends | MERGE (friend:Person {id: f}) MERGE (friend)-[:FRIENDS]-&amp;gt;p);   If we execute that on an empty database we&#39;ll see something like this: +-------------------+ | No data returned.</description>
    </item>
    
    <item>
      <title>Neo4j&#39;s Cypher vs Clojure - Group by and Sorting</title>
      <link>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</link>
      <pubDate>Sun, 29 Jun 2014 02:56:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</guid>
      <description>One of the points that I emphasised during my talk on building Neo4j backed applications using Clojure last week is understanding when to use Cypher to solve a problem and when to use the programming language.
A good example of this is in the meetup application I&#39;ve been working on. I have a collection of events and want to display past events in descending order and future events in ascending order.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Handling conditionals</title>
      <link>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</link>
      <pubDate>Tue, 17 Jun 2014 23:41:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</guid>
      <description>While building up the Neo4j World Cup Graph I&#39;ve been making use of the LOAD CSV function and I frequently found myself needing to do different things depending on the value in one of the columns.
For example I have one CSV file which contains the different events that can happen in a football match:
match_id,player,player_id,time,type &amp;quot;1012&amp;quot;,&amp;quot;Antonin Panenka&amp;quot;,&amp;quot;174835&amp;quot;,21,&amp;quot;penalty&amp;quot; &amp;quot;1012&amp;quot;,&amp;quot;Faisal Al Dakhil&amp;quot;,&amp;quot;2204&amp;quot;,57,&amp;quot;goal&amp;quot; &amp;quot;102&amp;quot;,&amp;quot;Roger Milla&amp;quot;,&amp;quot;79318&amp;quot;,106,&amp;quot;goal&amp;quot; &amp;quot;102&amp;quot;,&amp;quot;Roger Milla&amp;quot;,&amp;quot;79318&amp;quot;,108,&amp;quot;goal&amp;quot; &amp;quot;102&amp;quot;,&amp;quot;Bernardo Redin&amp;quot;,&amp;quot;44555&amp;quot;,115,&amp;quot;goal&amp;quot; &amp;quot;102&amp;quot;,&amp;quot;Andre Kana-biyik&amp;quot;,&amp;quot;174649&amp;quot;,44,&amp;quot;yellow&amp;quot;  If the type is &#39;penalty&#39;, &#39;owngoal&#39; or &#39;goal&#39; then I want to create a SCORED_GOAL relationship whereas if it&#39;s &#39;yellow&#39;, &#39;yellowred&#39; or &#39;red&#39; then I want to create a RECEIVED_CARD relationship instead.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - UNWIND vs FOREACH</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</link>
      <pubDate>Sat, 31 May 2014 14:19:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</guid>
      <description>I&#39;ve written a couple of posts about the new UNWIND clause in Neo4j&#39;s cypher query language but I forgot about my favourite use of UNWIND, which is to get rid of some uses of FOREACH from our queries.
Let&#39;s say we&#39;ve created a timetree up front and now have a series of events coming in that we want to create in the database and attach to the appropriate part of the timetree.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding a float value to decimal places</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</link>
      <pubDate>Sun, 25 May 2014 22:17:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</guid>
      <description>About 6 months ago Jacqui Read created a github issue explaining how she wanted to round a float value to a number of decimal places but was unable to do so due to the round function not taking the appropriate parameter.
I found myself wanting to do the same thing last week where I initially had the following value:
RETURN toFloat(&amp;quot;12.336666&amp;quot;) AS value  I wanted to round that to 2 decimal places and Wes suggested multiplying the value before using ROUND and then dividing afterwards to achieve that.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1:  Passing around node ids vs UNWIND</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</link>
      <pubDate>Sun, 25 May 2014 10:48:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</guid>
      <description>When Neo4j 2.1 is released we&#39;ll have the UNWIND clause which makes working with collections of things easier.
In my blog post about creating adjacency matrices we wanted to show how many people were members of the first 5 meetup groups ordered alphabetically and then check how many were members of each of the other groups.
Without the UNWIND clause we&#39;d have to do this:
MATCH (g:Group) WITH g ORDER BY g.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1: Creating adjacency matrices</title>
      <link>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</link>
      <pubDate>Tue, 20 May 2014 23:14:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</guid>
      <description>About 9 months ago I wrote a blog post showing how to export an adjacency matrix from a Neo4j 1.9 database using the cypher query language and I thought it deserves an update to use 2.0 syntax.
I&#39;ve been spending some of my free time working on an application that runs on top of meetup.com&#39;s API and one of the queries I wanted to write was to find the common members between 2 meetup groups.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Finding directors who acted in their own movie</title>
      <link>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</link>
      <pubDate>Fri, 28 Feb 2014 22:57:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</guid>
      <description>I&#39;ve been doing quite a few Intro to Neo4j sessions recently and since it contains a lot of problems for the attendees to work on I get to see how first time users of Cypher actually use it.
A couple of hours in we want to write a query to find directors who acted in their own film based on the following model.
  A common answer is the following:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Set Based Operations</title>
      <link>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</link>
      <pubDate>Thu, 20 Feb 2014 18:22:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</guid>
      <description>I was recently reminded of a Neo4j cypher query that I wrote a couple of years ago to find the colleagues that I hadn&#39;t worked with in the ThoughtWorks London office.
The model looked like this:
  And I created the following fake data set of the aforementioned model:
public class SetBasedOperations { private static final Label PERSON = DynamicLabel.label( &amp;quot;Person&amp;quot; ); private static final Label OFFICE = DynamicLabel.label( &amp;quot;Office&amp;quot; ); private static final DynamicRelationshipType COLLEAGUES = DynamicRelationshipType.</description>
    </item>
    
    <item>
      <title>Neo4j: Creating nodes and relationships from a list of maps</title>
      <link>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</link>
      <pubDate>Mon, 17 Feb 2014 14:11:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</guid>
      <description>Last week Alistair and I were porting some Neo4j cypher queries from 1.8 to 2.0 and one of the queries we had to change was an interesting one that created a bunch of relationships from a list/array of maps.
In the query we had a user &#39;Mark&#39; and wanted to create &#39;FRIENDS_WITH&#39; relationships to Peter and Michael.
  The application passed in a list of maps representing Peter and Michael as a parameter but if we remove the parameters the query looked like this:</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0: Cypher - Index Hints and Neo.ClientError.Schema.NoSuchIndex</title>
      <link>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</link>
      <pubDate>Fri, 31 Jan 2014 07:14:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</guid>
      <description>One of the features added into the more recent versions of Neo4j&#39;s cypher query language is the ability to tell Cypher which index you&#39;d like to use in your queries.
We&#39;ll use the football dataset, so let&#39;s start by creating an index on the &#39;name&#39; property of nodes labelled &#39;Player&#39;:
CREATE INDEX ON :Player(name)  Let&#39;s say we want to write a query to find &#39;Wayne Rooney&#39; while explicitly using this index.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Getting the hang of MERGE</title>
      <link>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</link>
      <pubDate>Tue, 10 Dec 2013 23:46:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</guid>
      <description>I&#39;ve been trying to get the hang of cypher&#39;s MERGE function and started out by writing a small file to import some people with random properties using the java-faker library.
public class Merge { private static Label PERSON = DynamicLabel.label(&amp;quot;Person&amp;quot;); public static void main(String[] args) throws IOException { File dbFile = new File(&amp;quot;/tmp/test-db&amp;quot;); FileUtils.deleteRecursively(dbFile); Faker faker = new Faker(); Random random = new Random(); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase(dbFile.getPath()); Transaction tx = db.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Optional relationships with OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</link>
      <pubDate>Sat, 23 Nov 2013 22:54:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</guid>
      <description>One of the breaking changes in Neo4j 2.0.0-RC1 compared to previous versions is that the -[?]- syntax for matching optional relationships has been retired and replaced with the OPTIONAL MATCH construct.
An example where we might want to match an optional relationship could be if we want to find colleagues that we haven&#39;t worked with given the following model:
 Suppose we have the following data set:
CREATE (steve:Person {name: &amp;quot;Steve&amp;quot;}) CREATE (john:Person {name: &amp;quot;John&amp;quot;}) CREATE (david:Person {name: &amp;quot;David&amp;quot;}) CREATE (paul:Person {name: &amp;quot;Paul&amp;quot;}) CREATE (sam:Person {name: &amp;quot;Sam&amp;quot;}) CREATE (londonOffice:Office {name: &amp;quot;London Office&amp;quot;}) CREATE UNIQUE (steve)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (john)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (david)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (paul)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (sam)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(john) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(david)  We might write the following query to find people from the same office as Steve but that he hasn&#39;t worked with:</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Working with path expressions</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</link>
      <pubDate>Sat, 23 Nov 2013 10:30:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</guid>
      <description>We recently released Neo4j 2.0.0-RC1 and since there were some breaking changes from Neo4j 2.0.0-M06 I decided to check if I needed to update any of my football graph queries.
On query which no longer worked as I expected was the following one which calculated the top goal scorers for televised games:
MATCH (player:Player)-[:played|subbed_on]-&amp;gt;stats WITH stats.goals AS goals, player, stats-[:in]-&amp;gt;()-[:on_tv]-() as onTv RETURN player.name, SUM(CASE WHEN onTv = FALSE THEN goals ELSE 0 END) as nonTvGoals, SUM(CASE WHEN onTv = TRUE THEN goals ELSE 0 END) as tvGoals, SUM(goals) as allGoals ORDER BY tvGoals DESC LIMIT 10  This is what that section of the graph looks like visually:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Creating relationships between nodes from adjacent rows in a query</title>
      <link>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</link>
      <pubDate>Fri, 22 Nov 2013 22:45:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</guid>
      <description>I want to introduce the concept of a season into my graph so I can have import matches for multiple years and then vary the time period which queries take into account.
I started by creating season nodes like this:
CREATE (:Season {name: &amp;quot;2013/2014&amp;quot;, timestamp: 1375315200}) CREATE (:Season {name: &amp;quot;2012/2013&amp;quot;, timestamp: 1343779200}) CREATE (:Season {name: &amp;quot;2011/2012&amp;quot;, timestamp: 1312156800}) CREATE (:Season {name: &amp;quot;2010/2011&amp;quot;, timestamp: 1280620800}) CREATE (:Season {name: &amp;quot;2009/2010&amp;quot;, timestamp: 1249084800})  I wanted to add a &#39;NEXT&#39; relationship between the seasons so that I could have an in graph season index which would allow me to write queries like the following:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting rid of an optional match</title>
      <link>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</link>
      <pubDate>Sun, 13 Oct 2013 21:59:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</guid>
      <description>I was looking back over some of the queries I wrote for my football data set and I came across one I&#39;d written to work out how many goals players scored in matches that were televised.
The data model looks like this:
 My initial query to work out the top 10 scorers in televised games was as follows:
MATCH (player:Player) WITH player MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT({goals: stats.goals, type: TYPE(t)}) AS games, player RETURN player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Converting queries from 1.9 to 2.0 -  &#39;Can&#39;t use optional patterns without explicit START clause&#39;</title>
      <link>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</link>
      <pubDate>Thu, 03 Oct 2013 16:16:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</guid>
      <description>I&#39;ve been playing around with the most recent Neo4j 2.0 milestone release - 2.0.0-M05 - and one of the first things I did was translate the queries from my football data set which were written against Neo4j 1.9.
The following query calculates the number of goals scored by players in matches that were shown on television, not on television and in total.
START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT([stats.goals, TYPE(t)]) AS games, player RETURN player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Translating 1.9 FILTER queries to use 2.0 list comprehensions</title>
      <link>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</link>
      <pubDate>Mon, 30 Sep 2013 21:34:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</guid>
      <description>I was looking back over some cypher queries I&#39;d written earlier in the year against my football data set to find some examples of where list comprehensions could be useful and I came across this query which is used to work out which teams were the most badly behaved in terms of accumulating red and yellow cards:
START team = node:teams(&#39;name:*&#39;) MATCH team&amp;lt;-[:for]-like_this&amp;lt;-[:started|as_sub]-player-[r?:sent_off_in|booked_in]-&amp;gt;game&amp;lt;-[:in]-like_this WITH team, COLLECT(r) AS cards WITH team, FILTER(x IN cards: TYPE(x) = &amp;quot;sent_off_in&amp;quot;) AS reds, FILTER(x IN cards: TYPE(x) = &amp;quot;booked_in&amp;quot;) AS yellows RETURN team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of query parameters</title>
      <link>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</link>
      <pubDate>Sat, 27 Jul 2013 09:30:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</guid>
      <description>For as long as I&#39;ve been using neo4j&#39;s cypher query language Michael has been telling me to use parameters in my queries but the performance of the queries was always acceptable so I didn&#39;t feel the need.
However, recently I was playing around with a data set and I created ~500 nodes using code similar to this:
require &#39;open-uri&#39; open(&amp;quot;data/people.cyp&amp;quot;, &#39;w&#39;) { |f| (1..500).each do |value| f.puts(&amp;quot;CREATE (p:Person{name: \&amp;quot;#{value}\&amp;quot;})&amp;quot;) end }  That creates a file of cypher statements that look like this:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Aggregating relationships within a path</title>
      <link>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</link>
      <pubDate>Thu, 27 Jun 2013 10:32:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</guid>
      <description>I recently came across an interesting use case of paths in a graph where we wanted to calculate the frequency of communication between two people by showing how frequently each emailed the other.
The model looked like this:
 which we can create with the following cypher statements:
CREATE (email1 { name: &#39;Email 1&#39;, title: &#39;Some stuff&#39; }) CREATE (email2 { name: &#39;Email 2&#39;, title: &amp;quot;Absolutely irrelevant&amp;quot; }) CREATE (email3 { name: &#39;Email 3&#39;, title: &amp;quot;Something else&amp;quot; }) CREATE (person1 { name: &#39;Mark&#39; }) CREATE (person2 { name: &#39;Jim&#39; }) CREATE (person3 { name: &#39;Alistair&#39; }) CREATE (person1)-[:SENT]-&amp;gt;(email1) CREATE (person2)-[:RECEIVED]-&amp;gt;(email1) CREATE (person3)-[:RECEIVED]-&amp;gt;(email1) CREATE (person1)-[:SENT]-&amp;gt;(email2) CREATE (person2)-[:RECEIVED]-&amp;gt;(email2) CREATE (person2)-[:SENT]-&amp;gt;(email3) CREATE (person1)-[:RECEIVED]-&amp;gt;(email3)  We want to return a list containing pairs of people and how many times they emailed each other, so in this case we want to return a table showing the following:</description>
    </item>
    
    <item>
      <title>neo4j: A simple example using the JDBC driver</title>
      <link>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</link>
      <pubDate>Thu, 20 Jun 2013 07:21:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</guid>
      <description>Michael recently pointed me to the neo4j JDBC driver which he and Rickard have written so I thought I&#39;d try and port the code from my previous post to use that instead of the console.
To start with I added the following dependencies to my POM file:
&amp;lt;dependencies&amp;gt; ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.neo4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;neo4j-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;repositories&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;id&amp;gt;neo4j-maven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;neo4j maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://m2.neo4j.org&amp;lt;/url&amp;gt; &amp;lt;/repository&amp;gt; &amp;lt;/repositories&amp;gt;  I then tried to create a connection to a local neo4j server instance that I had running on port 7474:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding single hop paths</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</link>
      <pubDate>Sat, 15 Jun 2013 13:04:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</guid>
      <description>The neo4j docs have a few examples explaining how to to write cypher queries dealing with path ranges but an interesting variation that I came across recently is where we want to find the individual hops in a path.
I thought the managers that Chelsea have had since Roman Abramovich took over would serve as a useful data set to show how this works.
So we create all the managers and a &#39;SUCCEEDED_BY&#39; relationship between them as follows:</description>
    </item>
    
    <item>
      <title>neo4j/cypher/Lucene: Dealing with special characters</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</link>
      <pubDate>Sat, 15 Jun 2013 09:53:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</guid>
      <description>neo4j uses Lucene to handle indexing of nodes and relationships in the graph but something that can be a bit confusing at first is how to handle special characters in Lucene queries.
For example let&#39;s say we set up a database with the following data:
CREATE ({name: &amp;quot;-one&amp;quot;}) CREATE ({name: &amp;quot;-two&amp;quot;}) CREATE ({name: &amp;quot;-three&amp;quot;}) CREATE ({name: &amp;quot;four&amp;quot;})  And for whatever reason we only wanted to return the nodes that begin with a hyphen.</description>
    </item>
    
    <item>
      <title>neo4j/cypher 2.0: The CASE statement</title>
      <link>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</link>
      <pubDate>Sun, 09 Jun 2013 14:02:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</guid>
      <description>I&#39;ve been playing around with how you might model Premier League managers tenures at different clubs in neo4j and eventually decided on the following model:
 The date modelling is based on an approach I first came across in a shutl presentation and is described in more detail in the docs. I created a dummy data set with some made up appointments and dismissals and then tried to write a query to show me who was the manager for a team on a specific date.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: 400 response - Paths can&#39;t be created inside of foreach</title>
      <link>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</link>
      <pubDate>Fri, 31 May 2013 00:37:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</guid>
      <description>In the neo4j 1.9 milestone releases if we wanted to create multiple relationships from a node we could use the following cypher syntax:
require &#39;neography&#39; neo = Neography::Rest.new neo.execute_query(&amp;quot;create (me {name: &#39;Mark&#39;})&amp;quot;) query = &amp;quot; START n=node:node_auto_index(name={name})&amp;quot; query &amp;lt;&amp;lt; &amp;quot; FOREACH (friend in {friends} : CREATE f=friend, n-[:FRIEND]-&amp;gt;f)&amp;quot; neo.execute_query(query, {&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Mark&amp;quot;, &amp;quot;friends&amp;quot; =&amp;gt; [{ &amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Will&amp;quot;}, {&amp;quot;name&amp;quot; =&amp;gt; &amp;quot;Paul&amp;quot;}]})  To check that the &#39;FRIEND&#39; relationships have been created we&#39;d write the following query:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Properties or relationships? It&#39;s easy to switch</title>
      <link>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</link>
      <pubDate>Sat, 25 May 2013 12:21:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</guid>
      <description>I&#39;ve written previously about how I&#39;ve converted properties on nodes into relationships and over the past week there was an interesting discussion on the neo4j mailing list about where each is appropriate.
Jim gives quite a neat summary of the difference between the two on the thread:
 Properties are the data that an entity like a node [or relationship] holds. Relationships simply form the semantic glue (type, direction, cardinality) between nodes.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Keep longest path when finding taxonomy</title>
      <link>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</link>
      <pubDate>Sun, 19 May 2013 22:15:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</guid>
      <description>I&#39;ve been playing around with modelling a product taxonomy and one thing that I wanted to do was find out the full path where a product sits under the tree.
I created a simple data set to show the problem:
CREATE (cat { name: &amp;quot;Cat&amp;quot; }) CREATE (subcat1 { name: &amp;quot;SubCat1&amp;quot; }) CREATE (subcat2 { name: &amp;quot;SubCat2&amp;quot; }) CREATE (subsubcat1 { name: &amp;quot;SubSubCat1&amp;quot; }) CREATE (product1 { name: &amp;quot;Product1&amp;quot; }) CREATE (cat)-[:CHILD]-subcat1-[:CHILD]-subsubcat1 CREATE (product1)-[:HAS_CATEGORY]-(subsubcat1)  I wanted to write a query which would return &#39;product1&#39; and the tree &#39;Cat - SubCat1 - SubSubCat1&#39; and initially wrote the following query:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Returning a row with zero count when no relationship exists</title>
      <link>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</link>
      <pubDate>Tue, 30 Apr 2013 07:02:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</guid>
      <description>I&#39;ve been trying to see if I can match some of the football stats that OptaJoe posts on twitter and one that I was looking at yesterday was around the number of red cards different teams have received.
 1 - Sunderland have picked up their first PL red card of the season. The only team without one now are Man Utd. Angels.  To refresh this is the sub graph that we&#39;ll need to look at to work it out:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Redundant relationships</title>
      <link>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</link>
      <pubDate>Tue, 16 Apr 2013 21:41:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</guid>
      <description>Last week I was writing a query to find the top scorers in the Premier League so far this season alongside the number of games they&#39;ve played in which initially read like this:
START player = node:players(&#39;name:*&#39;) MATCH player-[:started|as_sub]-playedLike-[:in]-game-[r?:scored_in]-player WITH player, COUNT(DISTINCT game) AS games, COLLECT(r) AS allGoals RETURN player.name, games, LENGTH(allGoals) AS goals ORDER BY goals DESC LIMIT 5  +------------------------------------+ | player.name | games | goals | +------------------------------------+ | &amp;quot;Luis Suárez&amp;quot; | 30 | 22 | | &amp;quot;Robin Van Persie&amp;quot; | 30 | 19 | | &amp;quot;Gareth Bale&amp;quot; | 27 | 17 | | &amp;quot;Michu&amp;quot; | 29 | 16 | | &amp;quot;Demba Ba&amp;quot; | 28 | 15 | +------------------------------------+ 5 rows 1 ms  I modelled whether a player started a game or came on as a substitute with separate relationship types &#39;started&#39; and &#39;as_sub&#39; but in this query we&#39;re not interested in that, we just want to know whether they played.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CypherTypeException: Failed merging Number with Relationship</title>
      <link>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</link>
      <pubDate>Sun, 24 Mar 2013 13:00:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</guid>
      <description>The latest thing that I added to my football graph was the matches that are shown on TV as I have the belief that players who score on televised games get more attention than players who score in other games.
I thought it&#39;d be interesting to work out who the top scorers are on each of these game types.
I added the following relationship type to allow me to do this:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: WITH, COLLECT &amp; EXTRACT</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</link>
      <pubDate>Wed, 20 Mar 2013 02:54:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</guid>
      <description>As I mentioned in my last post I&#39;m trying to get the hang of the WITH statement in neo4j&#39;s cypher query language and I found another application when trying to work out which opponents teams played on certain days.
I started out with a query which grouped the data set by day and showed the opponents that were played on that day:
START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[h:home_team|away_team]-game-[:on_day]-day RETURN DISTINCT day.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of the WITH statement</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</link>
      <pubDate>Wed, 20 Mar 2013 00:25:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</guid>
      <description>I wrote a post a few weeks ago showing an example of a cypher query which made use of the WITH statement but I still don&#39;t completely understand how it works so I thought I&#39;d write some more queries that use it.
I wanted to find out whether Luis Suárez has a better scoring record depending on which day a match is played on.
We start out by finding all the matches that he&#39;s played in and which days those matches were on:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY WITH LIMIT query</title>
      <link>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</link>
      <pubDate>Mon, 18 Mar 2013 23:19:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</guid>
      <description>A few weeks ago I wrote a blog post where I described how we could construct a SQL GROUP BY style query in cypher and last week I wanted to write a similar query but with what I think would be a LIMIT clause in SQL.
I wanted to find the maximum number of goals that players had scored in a match for a specific team and started off with the following query to find all the matches that players had scored in:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding football stadiums near a city using spatial</title>
      <link>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</link>
      <pubDate>Sun, 10 Mar 2013 22:13:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</guid>
      <description>One of the things that I wanted to add to my football graph was something location related so I could try out neo4j spatial and I thought the easiest way to do that was to model the location of football stadiums.
To start with I needed to add spatial as an unmanaged extension to my neo4j plugins folder which involved doing the following:
$ git clone git://github.com/neo4j/spatial.git spatial $ cd spatial $ mvn clean package -Dmaven.</description>
    </item>
    
    <item>
      <title>neo4j: Make properties relationships</title>
      <link>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</link>
      <pubDate>Wed, 06 Mar 2013 00:59:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</guid>
      <description>I spent some of the weekend working my way through Jim, Ian &amp; Emil&#39;s book &#39;Graph Databases&#39; and one of the things that they emphasise is that graphs allow us to make relationships first class citizens in our model.
Looking back on a couple of the graphs that I modelled last year I realise that I didn&#39;t quite get this and although the graphs I modelled had some relationships a lot of the time I was defining things as properties on nodes.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Combining COUNT and COLLECT in one query</title>
      <link>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</link>
      <pubDate>Sun, 24 Feb 2013 19:19:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</guid>
      <description>In my continued playing around with football data I wanted to write a cypher query against neo4j which would show me which teams had missed the most penalties this season and who missed them.
I started off with a query that returned all the penalties that have been missed this season and the games those misses happened in:
START player = node:players(&#39;name:*&#39;) MATCH player-[:missed_penalty_in]-game, player-[:played|subbed_on]-stats-[:in]-game, stats-[:for]-team, game-[:home_team]-home, game-[:away_team]-away RETURN player.name, team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Using a WHERE clause to filter paths</title>
      <link>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</link>
      <pubDate>Tue, 19 Feb 2013 00:03:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</guid>
      <description>One of the cypher queries that I wanted to write recently was one to find all the players that have started matches for Arsenal this season and the number of matches that they&#39;ve played in.
The data model that I&#39;m querying looks like this:
 I started off with the following query which traverses from Arsenal to all the games that they&#39;ve taken part in and finds all the players who&#39;ve played in those games:</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY functionality</title>
      <link>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</link>
      <pubDate>Sun, 17 Feb 2013 21:05:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</guid>
      <description>As I mentioned in a previous post I&#39;ve been playing around with some football related data over the last few days and one query I ran (using cypher) was to find all the players who&#39;ve been sent off this season in the Premiership.
The model in the graph around sending offs looks like this:
 My initial query looked like this:
START player = node:players(&#39;name:*&#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month RETURN player.name, month.name  First we get the names of all the players which are stored in an index and then we follow relationships to the games they were sent off in and then find which months those games were played in.</description>
    </item>
    
    <item>
      <title>Data Science: Don&#39;t filter data prematurely</title>
      <link>https://markhneedham.com/blog/2013/02/17/data-science-dont-filter-data-prematurely/</link>
      <pubDate>Sun, 17 Feb 2013 20:02:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/17/data-science-dont-filter-data-prematurely/</guid>
      <description>Last year I wrote a post describing how I&#39;d gone about getting data for my ThoughtWorks graph and one mistake about my approach in retrospect is that I filtered the data too early.
My workflow looked like this:
 Scrape internal application using web driver and save useful data to JSON files Parse JSON files and load nodes/relationships into neo4j  The problem with the first step is that I was trying to determine up front what data was useful and as a result I ended up running the scrapping application multiple times when I realised I didn&#39;t have all the data I wanted.</description>
    </item>
    
    <item>
      <title>neo4j: Handling SUM&#39;s scientific notation</title>
      <link>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</link>
      <pubDate>Sun, 30 Sep 2012 19:47:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</guid>
      <description>In some of the recent work I&amp;rsquo;ve been doing with neo4j the queries I&amp;rsquo;ve written have been summing up the values from multiple nodes and after a certain number is reached the value returned used scientific notation.
For example in a cypher query like this:
START category = node:categories(&#39;category_id:1&#39;) MATCH p = category-[:has_child*1..5]-&amp;gt;subCategory-[:has_product]-&amp;gt;product-[:sold]-&amp;gt;sales RETURN EXTRACT(n in NODES(p) : n.category_id?),subCategory.category_id, SUM(sales.sales)  I might get a result set like this:
+------------------------------------------------------------------------------------------------+ | EXTRACT(n in NODES(p) : n.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CREATE UNIQUE - &#34;SyntaxException: string matching regex `$&#39; expected but `p&#39; found&#34;</title>
      <link>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</link>
      <pubDate>Sun, 09 Sep 2012 22:29:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</guid>
      <description>I&amp;rsquo;ve been playing around with the mutating cypher syntax of neo4j which allows you to make changes to the graph as well as query it, a feature introduced into cypher in May in release 1.8 M01.
I was trying to make use of the &amp;lsquo;CREATE UNIQUE&amp;rsquo; syntax which allows you to create nodes/relationships if they&amp;rsquo;re missing but won&amp;rsquo;t do anything if they already exists.
I had something like the following:</description>
    </item>
    
    <item>
      <title>neo4j: Multiple starting nodes by index lookup</title>
      <link>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</link>
      <pubDate>Sat, 28 Jul 2012 23:32:28 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</guid>
      <description>I spent a bit of time this evening extracting some data from the ThoughtWorks graph for our marketing team who were interested in anything related to our three European offices in London, Manchester and Hamburg.
The most interesting things we can explore relate to the relationship between people and the offices.
The model around people and offices looks like this:
  I added a &amp;lsquo;current_home_office&amp;rsquo; relationship to make it easier to quickly get to the nodes of people who are currently working in a specific office.</description>
    </item>
    
    <item>
      <title>neo4j: Graph Global vs Graph Local queries</title>
      <link>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</link>
      <pubDate>Mon, 23 Jul 2012 22:23:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</guid>
      <description>A few weeks ago I did a presentation at the ThoughtWorks EU away day on the graph I&amp;rsquo;ve been developing using neo4j and I wanted to show who the most connected people in each of our European offices were.
I started with the following cypher query:
START n = node(*) MATCH n-[r:colleagues*1..2]-&amp;gt;c, n-[r2:member_of]-&amp;gt;office WHERE n.type? = &#39;person&#39; AND (NOT(HAS(r2.end_date))) AND office.name = &#39;London - UK South&#39; AND (NOT(HAS(c.thoughtquitter))) RETURN n.name, count(distinct(c)) AS connections, office.</description>
    </item>
    
    <item>
      <title>neo4j: Embracing the sub graph</title>
      <link>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</link>
      <pubDate>Sat, 21 Jul 2012 22:46:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</guid>
      <description>In May I wrote a blog post explaining how I&amp;rsquo;d been designing a neo4j graph by thinking about what questions I wanted to answer about the data.
In the comments Josh Adell gave me the following advice:
 The neat things about graphs is that multiple subgraphs can live in the same data-space. ...
Keep your data model rich! Don&#39;t be afraid to have as many relationships as you need. The power of graph databases comes from finding surprising results when you have strongly interconnected data.</description>
    </item>
    
    <item>
      <title>neo4j: Shortest Path with and without cypher</title>
      <link>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</link>
      <pubDate>Thu, 19 Jul 2012 19:57:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</guid>
      <description>I was looking back at some code I wrote a few months ago to query a neo4j database to find the shortest path between two people via the colleagues relationships that exist.

The initial code, written using neography, looked like this:
neo = Neography::Rest.new start_node = neo.get_node(start_node_id) destination_node = neo.get_node(destination_node_id) neo.get_paths(start_node, destination_node, { &amp;quot;type&amp;quot; =&amp;gt; &amp;quot;colleagues&amp;quot; }, depth = 3, algorithm = &amp;quot;shortestPath&amp;quot;)  The neography code eventually makes a POST request to /node/{start_id}/paths and provides a JSON payload containing the other information about the query.</description>
    </item>
    
    <item>
      <title>neo4j: Handling optional relationships</title>
      <link>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</link>
      <pubDate>Sun, 24 Jun 2012 23:32:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</guid>
      <description>On my ThoughtWorks neo4j there are now two different types of relationships between people nodes - they can either be colleagues or one can be the sponsor of the other.
The graph looks like this:
I wanted to get a list of all the sponsor pairs but also have some indicator of whether the two people have worked together.
I started off by getting all of the sponsor pairs:
START n = node(*) MATCH n-[r:sponsor_of]-&amp;gt;n2 RETURN n.</description>
    </item>
    
    <item>
      <title>Visualising a neo4j graph using gephi</title>
      <link>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</link>
      <pubDate>Thu, 21 Jun 2012 05:02:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</guid>
      <description>At ThoughtWorks we don&amp;rsquo;t have line managers but people can choose to have a sponsor - typically someone who has worked in the company for longer/has more experience in the industry than them - who can help them navigate the organisation better.
From hearing people talk about sponsors over the last 6 years it seemed like quite a few people sponsored the majority and there were probably a few people who didn&amp;rsquo;t have a sponsor.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the most connected node on the graph</title>
      <link>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</link>
      <pubDate>Sat, 16 Jun 2012 10:41:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</guid>
      <description>As I mentioned in another post about a month ago I&amp;rsquo;ve been playing around with a neo4j graph in which I have the following relationship between nodes:
One thing I wanted to do was work out which node is the most connected on the graph, which would tell me who&amp;rsquo;s worked with the most people.
I started off with the following cypher query:
query = &amp;quot; START n = node(*)&amp;quot; query &amp;lt;&amp;lt; &amp;quot; MATCH n-[r:colleagues]-&amp;gt;c&amp;quot; query &amp;lt;&amp;lt; &amp;quot; WHERE n.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the shortest path between two nodes while applying predicates</title>
      <link>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</link>
      <pubDate>Sat, 12 May 2012 14:55:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</guid>
      <description>As I mentioned in a blog post about a week ago I decided to restructure the ThoughtWorks graph I&amp;rsquo;ve modelled in neo4j so that I could explicitly model projects and clients.
As a result I had to update a traversal I&amp;rsquo;d written for finding the shortest path between two people in the graph.
The original traversal query I had was really simple because I had a direct connection between the people nodes:</description>
    </item>
    
    <item>
      <title>neo4J: Searching for nodes by name</title>
      <link>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</link>
      <pubDate>Fri, 20 Apr 2012 07:10:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</guid>
      <description>As I mentioned in a post a few days ago I&amp;rsquo;ve been graphing connections between ThoughtWorks people using neo4j and wanted to build auto complete functionality so I can search for the names of people in the graph.
The solution I came up was to create a Lucene index with an entry for each node and a common property on each document in the index so that I&amp;rsquo;d be able to get all the index entries easily.</description>
    </item>
    
  </channel>
</rss>