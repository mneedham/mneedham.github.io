<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>strava on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/strava/</link>
    <description>Recent content in strava on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 10 Jul 2018 04:21:00 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/strava/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Neo4j 3.4: Grouping Datetimes</title>
      <link>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</link>
      <pubDate>Tue, 10 Jul 2018 04:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</guid>
      <description>In my continued analysis of Strava runs I wanted to try and find my best runs grouped by different time components, which was actually much easier than I was expecting.
 Importing the dataset If you want to try out the examples below you can execute the following LOAD CSV commands to load the data:
 LOAD CSV WITH HEADERS FROM &#34;https://github.com/mneedham/strava/raw/master/runs.csv&#34; AS row MERGE (run:Run {id: toInteger(row.id)}) SET run.distance = toFloat(row.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Syntax Error - Text cannot be parsed to a Duration (aka dealing with empty durations)</title>
      <link>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</link>
      <pubDate>Mon, 09 Jul 2018 18:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</guid>
      <description>As I continued with my travels with Neo4j 3.4&amp;#8217;s temporal data type I came across some fun edge cases when dealing with empty durations while importing data.
 Imagine we&amp;#8217;re trying to create 3 nodes from the following array of input data. Two of the rows have invalid durations!
 UNWIND [ {id: 12345, duration: &#34;PT2M20S&#34;}, {id: 12346, duration: &#34;&#34;}, {id: 12347, duration: null} ] AS row MERGE (run:Run {id: row.</description>
    </item>
    
    <item>
      <title>Neo4j: Querying the Strava Graph using Py2neo</title>
      <link>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</link>
      <pubDate>Fri, 15 Jun 2018 13:45:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</guid>
      <description>Last week Nigel released v4 of Py2neo and given I was just getting ready to write some queries against my Strava activity graph I thought I&amp;#8217;d give it a try.
 If you want to learn how to create your own Strava graph you should read my previous post, but just to recap, this is the graph model that we created:
   Let&amp;#8217;s get to it!
 tl;dr the code in this post is available as a Jupyter notebook so if you want the code and nothing but the code head over there!</description>
    </item>
    
    <item>
      <title>Neo4j: Building a graph of Strava activities</title>
      <link>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</guid>
      <description>In my last post I showed how to import activities from Strava&amp;#8217;s API into Neo4j using only the APOC library, but that was only part of the graph so I thought I&amp;#8217;d share the rest of what I&amp;#8217;ve done.
 The Graph Model In the previous post I showed how to import nodes with Run label, but there are some other pieces of data that I wanted to import as well.</description>
    </item>
    
    <item>
      <title>Neo4j APOC: Importing data from Strava&#39;s paginated JSON API</title>
      <link>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</link>
      <pubDate>Tue, 05 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</guid>
      <description>Over the weekend I&amp;#8217;ve been playing around with loading data from the Strava API into Neo4j and I started with the following Python script which creates a node with a Run label for each of my activities.
 If you want to follow along on your own data you&amp;#8217;ll need to get an API key via the &#39;My API Application&#39; section of the website. Once you&amp;#8217;ve got that put it in the TOKEN environment variable and you should be good to go.</description>
    </item>
    
    <item>
      <title>Strava: Calculating the similarity of two runs</title>
      <link>https://markhneedham.com/blog/2018/01/18/strava-calculating-similarity-two-runs/</link>
      <pubDate>Thu, 18 Jan 2018 23:35:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/01/18/strava-calculating-similarity-two-runs/</guid>
      <description>import polyline polyline.decode(&amp;#39;u{~vFvyys@fS]&amp;#39;) [(40.63179, -8.65708), (40.62855, -8.65693)] The sequences are &amp;ldquo;warped&amp;rdquo; non-linearly in the time dimension to determine a measure of their similarity independent of certain non-linear variations in the time dimension.
import os import polyline import requests from fastdtw import fastdtw token = os.environ[&amp;#34;TOKEN&amp;#34;] headers = {&amp;#39;Authorization&amp;#39;: &amp;#34;Bearer {0}&amp;#34;.format(token)} def find_points(activity_id): r = requests.get(&amp;#34;https://www.strava.com/api/v3/activities/{0}&amp;#34;.format(activity_id), headers=headers) response = r.json() line = response[&amp;#34;map&amp;#34;][&amp;#34;polyline&amp;#34;] return polyline.decode(line) from scipy.spatial.distance import euclidean activity1_id = 1361109741 activity2_id = 1346460542 distance, path = fastdtw(find_points(activity1_id), find_points(activity2_id), dist=euclidean) &amp;gt;&amp;gt;&amp;gt; print(distance) 2.</description>
    </item>
    
    <item>
      <title>Loading and analysing Strava runs using PostgreSQL JSON data type</title>
      <link>https://markhneedham.com/blog/2017/05/01/loading-and-analysing-strava-runs-using-postgresql-json-data-type/</link>
      <pubDate>Mon, 01 May 2017 19:11:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/05/01/loading-and-analysing-strava-runs-using-postgresql-json-data-type/</guid>
      <description>create database strava; \connect strava; CREATE TABLE runs ( id INTEGER NOT NULL, data jsonb ); ALTER TABLE runs ADD PRIMARY KEY(id); import requests import os import json import psycopg2 token = os.environ[&amp;#34;TOKEN&amp;#34;] headers = {&amp;#39;Authorization&amp;#39;: &amp;#34;Bearer {0}&amp;#34;.format(token)} with psycopg2.connect(&amp;#34;dbname=strava user=markneedham&amp;#34;) as conn: with conn.cursor() as cur: page = 1 while True: r = requests.get(&amp;#34;https://www.strava.com/api/v3/athlete/activities?page={0}&amp;#34;.format(page), headers = headers) response = r.json() if len(response) == 0: break else: for activity in response: r = requests.</description>
    </item>
    
    <item>
      <title>Leaflet: Mapping Strava runs/polylines on Open Street Map</title>
      <link>https://markhneedham.com/blog/2017/04/29/leaflet-strava-polylines-osm/</link>
      <pubDate>Sat, 29 Apr 2017 15:36:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/04/29/leaflet-strava-polylines-osm/</guid>
      <description>&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Mapping my runs&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script src=&amp;#34;http://cdn.leafletjs.com/leaflet-0.7/leaflet.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script type=&amp;#34;text/javascript&amp;#34; src=&amp;#34;https://rawgit.com/jieter/Leaflet.encoded/master/Polyline.encoded.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;link rel=&amp;#34;stylesheet&amp;#34; href=&amp;#34;http://cdn.leafletjs.com/leaflet-0.7/leaflet.css&amp;#34; /&amp;gt; &amp;lt;div id=&amp;#34;map&amp;#34; style=&amp;#34;width: 100%; height: 100%&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; var map = L.map(&amp;#39;map&amp;#39;).setView([55.609818, 13.003286], 13); L.tileLayer( &amp;#39;http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png&amp;#39;, { maxZoom: 18, }).addTo(map); var encodedRoutes = [ &amp;#34;{zkrIm`inANPD?BDXGPKLATHNRBRFtAR~AFjAHl@D|ALtATj@HHJBL?`@EZ?NQ\\Y^MZURGJKR]RMXYh@QdAWf@[~@aAFGb@?j@YJKBU@m@FKZ[NSPKTCRJD?`@Wf@Wb@g@HCp@Qh@]z@SRMRE^EHJZnDHbBGPHb@NfBTxBN|DVbCBdA^lBFl@Lz@HbBDl@Lr@Bb@ApCAp@Ez@g@bEMl@g@`B_AvAq@l@ QF]Rs@Nq@CmAVKCK?_@Nw@h@UJIHOZa@xA]~@UfASn@U`@_@~@[d@Sn@s@rAs@dAGN?NVhAB\\Ox@@b@S|A?Tl@jBZpAt@vBJhATfGJn@b@fARp@H^Hx@ARGNSTIFWHe@AGBOTAP@^\\zBMpACjEWlEIrCKl@i@nAk@}@}@yBOWSg@kAgBUk@Mu@[mC?QLIEUAuAS_E?uCKyCA{BH{DDgF`AaEr@uAb@oA~@{AE}AKw@ g@qAU[_@w@[gAYm@]qAEa@FOXg@JGJ@j@o@bAy@NW?Qe@oCCc@SaBEOIIEQGaAe@kC_@{De@cE?KD[H[P]NcAJ_@DGd@Gh@UHI@Ua@}Bg@yBa@uDSo@i@UIICQUkCi@sCKe@]aAa@oBG{@G[CMOIKMQe@IIM@KB]Tg@Nw@^QL]NMPMn@@\\Lb@P~@XT&amp;#34;, &amp;#34;u}krIq_inA_@y@My@Yu@OqAUsA]mAQc@CS@o@FSHSp@e@n@Wl@]ZCFEBK?OC_@Qw@?m@CSK[]]EMBeAA_@m@qEAg@UoCAaAMs@IkBMoACq@SwAGOYa@IYIyA_@kEMkC]{DEaAScC@yEHkGA_ALsCBiA@mCD{CCuAZcANOH@HDZl@Z`@RFh@\\TDT@ZVJBPMVGLM\\Mz@c@NCPMXERO|@a@^Ut@s@p@KJAJ Bd@EHEXi@f@a@\\g@b@[HUD_B@uADg@DQLCLD~@l@`@J^TF?JANQ\\UbAyABEZIFG`@o@RAJEl@_@ZENDDIA[Ki@BURQZaARODKVs@LSdAiAz@G`BU^A^GT@PRp@zARXRn@`BlDHt@ZlAFh@^`BX|@HHHEf@i@FAHHp@bBd@v@DRAVMl@i@v@SROXm@tBILOTOLs@NON_@t@KX]h@Un@k@\\c@h@Ud@]ZGNKp@Sj@KJo@ b@W`@UPOX]XWd@UF]b@WPOAIBSf@QVi@j@_@V[b@Uj@YtAEFCCELARBn@`@lBjAzD^vB^hB?LENURkAv@[Ze@Xg@Py@p@QHONMA[HGAWE_@Em@Hg@AMCG@QHq@Cm@M[Jy@?UJIA{@Ae@KI@GFKNIX[QGAcAT[JK?OVMFK@IAIUKAYJI?QKUCGFIZCXDtAHl@@p@LjBCZS^ERAn@Fj@Br@Hn@HzAHh@RfD?j@TnCTlA NjANb@\\z@TtARr@P`AFnAGfBG`@CFE?&amp;#34; ] for (let encoded of encodedRoutes) { var coordinates = L.Polyline.fromEncoded(encoded).getLatLngs(); L.polyline( coordinates, { color: &amp;#39;blue&amp;#39;, weight: 2, opacity: .7, lineJoin: &amp;#39;round&amp;#39; } ).addTo(map); } &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; $ python -m http.</description>
    </item>
    
  </channel>
</rss>