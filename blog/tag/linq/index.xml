<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linq on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/linq/</link>
    <description>Recent content in linq on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 20 Feb 2010 12:17:16 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/linq/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C#: A lack of covariance with generics example</title>
      <link>https://markhneedham.com/blog/2010/02/20/c-a-lack-of-covariance-with-generics-example/</link>
      <pubDate>Sat, 20 Feb 2010 12:17:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2010/02/20/c-a-lack-of-covariance-with-generics-example/</guid>
      <description>One of the things I find most confusing when reading about programming languages is the idea of covariance and contravarianceand while I&amp;rsquo;ve previously read that covariance is not possible when using generics in C# I recently came across an example where I saw that this was true.
I came across this problem while looking at how to refactor some code which has been written in an imperative style:
public interface IFoo { string Bar { get; set; } } public class Foo : IFoo { public string Bar { get; set; } } private IEnumerable&amp;lt;IFoo&amp;gt; GetMeFoos() { var someStrings = new[] { &amp;#34;mike&amp;#34;, &amp;#34;mark&amp;#34; }; var someFoos = new List&amp;lt;IFoo&amp;gt;(); foreach (var s in someStrings) { someFoos.</description>
    </item>
    
    <item>
      <title>Getting a strongly typed collection using LINQ to Xml</title>
      <link>https://markhneedham.com/blog/2008/08/30/getting-a-strongly-typed-collection-using-linq-to-xml/</link>
      <pubDate>Sat, 30 Aug 2008 03:03:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2008/08/30/getting-a-strongly-typed-collection-using-linq-to-xml/</guid>
      <description>I mentioned earlierthat I have been playing around with LINQ to Xml for parsing a Visual Studio csproj file.
While having namespace issues I decided to try and parse a simpler Xml file to try and work out what I was doing wrong.
Given this fragment of Xml:
&amp;lt;Node&amp;gt; &amp;lt;InnerNode&amp;gt;mark&amp;lt;/InnerNode&amp;gt; &amp;lt;InnerNode&amp;gt;needham&amp;lt;/InnerNode&amp;gt; &amp;lt;/Node&amp;gt; I wanted to get a collection(IEnumerable) of InnerNode values.
Unfortunately my over enthusiasm to use anonymous typesmeant that I caused myself more problems than I needed to.</description>
    </item>
    
    <item>
      <title>Querying Xml with LINQ - Don&#39;t forget the namespace</title>
      <link>https://markhneedham.com/blog/2008/08/28/querying-xml-with-linq-dont-forget-the-namespace/</link>
      <pubDate>Thu, 28 Aug 2008 10:15:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2008/08/28/querying-xml-with-linq-dont-forget-the-namespace/</guid>
      <description>I&amp;rsquo;ve been working with a colleague on parsing a Visual Studio project file using LINQto effectively create a DOM of the file.
The first thing we tried to do was get a list of all the references from the file. It seemed like a fairly easy problem to solve but for some reason nothing was getting returned:
XDocument projectFile = XDocument.Load(projectFilePath.Path); var references = from itemGroupElement in projectFile.Descendants(&amp;#34;ItemGroup&amp;#34;).First().Elements() select itemGroupElement.Attribute(&amp;#34;Include&amp;#34;).Value; We are selecting all the occurrences of &amp;lsquo;ItemGroup&amp;rsquo;, taking the first occurrence, getting all the elements inside it (i.</description>
    </item>
    
  </channel>
</rss>