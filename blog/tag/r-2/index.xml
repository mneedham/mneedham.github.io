<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>r-2 on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/r-2/</link>
    <description>Recent content in r-2 on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 09 Jul 2016 06:36:51 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/r-2/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>R: Sentiment analysis of morning pages</title>
      <link>https://markhneedham.com/blog/2016/07/09/r-sentiment-analysis-of-morning-pages/</link>
      <pubDate>Sat, 09 Jul 2016 06:36:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/07/09/r-sentiment-analysis-of-morning-pages/</guid>
      <description>There is no wrong way to do Morning Pages – they are not high art.
They are not even “writing.” They are about anything and everything that crosses your mind– and they are for your eyes only.
Morning Pages provoke, clarify, comfort, cajole, prioritize and synchronize the day at hand. Do not over-think Morning Pages: just put three pages of anything on the page…and then do three more pages tomorrow.</description>
    </item>
    
    <item>
      <title>R: substr - Getting a vector of positions</title>
      <link>https://markhneedham.com/blog/2016/04/18/r-substr-getting-a-vector-of-positions/</link>
      <pubDate>Mon, 18 Apr 2016 19:49:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/04/18/r-substr-getting-a-vector-of-positions/</guid>
      <description>&amp;gt; substr(&amp;#34;mark loves graphs&amp;#34;, 0, 4) [1] &amp;#34;mark&amp;#34; &amp;gt; substr(&amp;#34;mark loves graphs&amp;#34;, c(0, 6), c(4, 10)) [1] &amp;#34;mark&amp;#34; &amp;gt; substring(&amp;#34;mark loves graphs&amp;#34;, c(0, 6, 12), c(4, 10, 17)) [1] &amp;#34;mark&amp;#34; &amp;#34;loves&amp;#34; &amp;#34;graphs&amp;#34; </description>
    </item>
    
    <item>
      <title>R: tm - Unique words/terms per document</title>
      <link>https://markhneedham.com/blog/2016/04/11/r-tm-unique-wordsterms-per-document/</link>
      <pubDate>Mon, 11 Apr 2016 05:40:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/04/11/r-tm-unique-wordsterms-per-document/</guid>
      <description>library(tm) text = c(&amp;#34;I am Mark I am Mark&amp;#34;, &amp;#34;Neo4j is cool Neo4j is cool&amp;#34;) corpus = VCorpus(VectorSource(text)) tdm = as.matrix(TermDocumentMatrix(corpus, control = list(wordLengths = c(1, Inf)))) &amp;gt; tdm Docs Terms 1 2 am 2 0 cool 0 2 i 2 0 is 0 2 mark 2 0 neo4j 0 2 &amp;gt; rowSums(tdm) am cool i is mark neo4j 2 2 2 2 2 2 uniqueWords = function(d) { return(paste(unique(strsplit(d, &amp;#34; &amp;#34;)[[1]]), collapse = &amp;#39; &amp;#39;)) } corpus = tm_map(corpus, content_transformer(uniqueWords)) tdm = as.</description>
    </item>
    
    <item>
      <title>R: Error in approxfun(x.values.1, y.values.1, method = &#34;constant&#34;, f = 1, :  zero non-NA points</title>
      <link>https://markhneedham.com/blog/2015/12/27/r-error-in-approxfunx-values-1-y-values-1-method-constant-f-1-zero-non-na-points/</link>
      <pubDate>Sun, 27 Dec 2015 12:24:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/12/27/r-error-in-approxfunx-values-1-y-values-1-method-constant-f-1-zero-non-na-points/</guid>
      <description>Source: local data frame [2 x 2] attended n (dbl) (int) 1 0 1541 2 1 53 attended = as.factor((df %&amp;gt;% dplyr::select(attended))$attended) upSampledDf = upSample(df %&amp;gt;% dplyr::select(-attended), attended) upSampledDf$attended = as.numeric(as.character(upSampledDf$Class)) p &amp;lt;- predict(model, newdata=test, type=&amp;#34;response&amp;#34;) pr &amp;lt;- prediction(p, test$attended) prf &amp;lt;- performance(pr, measure = &amp;#34;tpr&amp;#34;, x.measure = &amp;#34;fpr&amp;#34;) Error in approxfun(x.values.1, y.values.1, method = &amp;#34;constant&amp;#34;, f = 1, : zero non-NA points &amp;gt; test %&amp;gt;% count(attended) Source: local data frame [1 x 2] attended n (dbl) (int) 1 1 582 </description>
    </item>
    
    <item>
      <title>R: data.table - Finding the maximum row</title>
      <link>https://markhneedham.com/blog/2015/10/02/r-data-table-finding-the-maximum-row/</link>
      <pubDate>Fri, 02 Oct 2015 18:42:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/10/02/r-data-table-finding-the-maximum-row/</guid>
      <description>&amp;gt; blogDT = data.table(name = c(&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;), price = c(10000, 12500, 18000, 245000, 512000, 1000000), date = c(&amp;#34;Day 1&amp;#34;, &amp;#34;Day 7&amp;#34;, &amp;#34;Day 10&amp;#34;, &amp;#34;Day 3&amp;#34;, &amp;#34;Day 5&amp;#34;, &amp;#34;Day 12&amp;#34;)) &amp;gt; blogDT[, lag.price := c(NA, price[-.N]), by = name] &amp;gt; blogDT[, diff := price - lag.price] &amp;gt; blogDT name price date lag.price diff 1: Property 1 10000 Day 1 NA NA 2: Property 1 12500 Day 7 10000 2500 3: Property 1 18000 Day 10 12500 5500 4: Property 2 245000 Day 3 NA NA 5: Property 2 512000 Day 5 245000 267000 6: Property 2 1000000 Day 12 512000 488000 &amp;gt; blogDT[!</description>
    </item>
    
    <item>
      <title>R: data.table - Comparing adjacent rows</title>
      <link>https://markhneedham.com/blog/2015/09/27/r-data-table-comparing-adjacent-rows/</link>
      <pubDate>Sun, 27 Sep 2015 22:02:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/09/27/r-data-table-comparing-adjacent-rows/</guid>
      <description>&amp;gt; blogDT = data.table(name = c(&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 1&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;,&amp;#34;Property 2&amp;#34;), price = c(10000, 12500, 18000, 245000, 512000, 1000000)) &amp;gt; blogDT name price 1: Property 1 10000 2: Property 1 12500 3: Property 1 18000 4: Property 2 245000 5: Property 2 512000 6: Property 2 1000000 &amp;gt; blogDT[, lag.price := c(NA, price[-.N]), by = name] &amp;gt; blogDT name price lag.price 1: Property 1 10000 NA 2: Property 1 12500 10000 3: Property 1 18000 12500 4: Property 2 245000 NA 5: Property 2 512000 245000 6: Property 2 1000000 512000 &amp;gt; blogDT[, diff := price - lag.</description>
    </item>
    
    <item>
      <title>R: Querying a 20 million line CSV file - data.table vs data frame</title>
      <link>https://markhneedham.com/blog/2015/09/25/r-querying-a-20-million-line-csv-file-data-table-vs-data-frame/</link>
      <pubDate>Fri, 25 Sep 2015 06:28:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/09/25/r-querying-a-20-million-line-csv-file-data-table-vs-data-frame/</guid>
      <description>&amp;gt; library(readr) &amp;gt; system.time(read_csv(&amp;#34;pp-complete.csv&amp;#34;, col_names = FALSE)) user system elapsed 127.367 21.957 159.963 &amp;gt; df = read_csv(&amp;#34;pp-complete.csv&amp;#34;, col_names = FALSE) &amp;gt; head(df) Source: local data frame [6 x 16] X1 X2 X3 X4 X5 X6 X7 X8 X9 (chr) (int) (date) (chr) (chr) (chr) (chr) (chr) (chr) 1 {0C7ADEF5-878D-4066-B785-0000003ED74A} 163000 &amp;lt;NA&amp;gt; UB5 4PJ T N F 106 2 {35F67271-ABD4-40DA-AB09-00000085B9D3} 247500 &amp;lt;NA&amp;gt; TA19 9DD D N F 58 3 {B20B1C74-E8E1-4137-AB3E-0000011DF342} 320000 &amp;lt;NA&amp;gt; W4 1DZ F N L 58 4 {7D6B0915-C56B-4275-AF9B-00000156BCE7} 104000 &amp;lt;NA&amp;gt; NE61 2BH D N F 17 5 {47B60101-B64C-413D-8F60-000002F1692D} 147995 &amp;lt;NA&amp;gt; PE33 0RU D N F 4 6 {51F797CA-7BEB-4958-821F-000003E464AE} 110000 &amp;lt;NA&amp;gt; NR35 2SF T N F 5 Variables not shown: X10 (chr), X11 (chr), X12 (chr), X13 (chr), X14 (chr), X15 (chr), address (chr) &amp;gt; library(dplyr) &amp;gt; system.</description>
    </item>
    
    <item>
      <title>R: Bootstrap confidence intervals</title>
      <link>https://markhneedham.com/blog/2015/07/19/r-bootstrap-confidence-intervals/</link>
      <pubDate>Sun, 19 Jul 2015 19:44:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/19/r-bootstrap-confidence-intervals/</guid>
      <description>&amp;gt; data = c(0, 1, 3, 2, 8, 2, 3, 4) &amp;gt; quantile(data, 0.05) 5% 0.35 &amp;gt; sample(data, replace = TRUE) [1] 0 3 2 8 8 0 8 0 &amp;gt; sample(data, replace = TRUE) [1] 2 2 4 3 4 4 2 2 library(ggplot) bootstrap_5th_percentile = function(data, n_bootstraps) { return(sapply(1:n_bootstraps, function(iteration) quantile(sample(data, replace = TRUE), 0.05))) } values = bootstrap_5th_percentile(data, 10000) ggplot(aes(x = value), data = data.frame(value = values)) + geom_histogram(binwidth=0.</description>
    </item>
    
    <item>
      <title>R: Blog post frequency anomaly detection</title>
      <link>https://markhneedham.com/blog/2015/07/17/r-blog-post-frequency-anomaly-detection/</link>
      <pubDate>Fri, 17 Jul 2015 23:34:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/17/r-blog-post-frequency-anomaly-detection/</guid>
      <description>install.packages(&amp;#34;devtools&amp;#34;) devtools::install_github(&amp;#34;twitter/AnomalyDetection&amp;#34;) library(AnomalyDetection) &amp;gt; library(dplyr) &amp;gt; raw_data %&amp;gt;% head() timestamp count 1 1980-09-25 14:01:00 182.478 2 1980-09-25 14:02:00 176.231 3 1980-09-25 14:03:00 183.917 4 1980-09-25 14:04:00 177.798 5 1980-09-25 14:05:00 165.469 6 1980-09-25 14:06:00 181.878 res = AnomalyDetectionTs(raw_data, max_anoms=0.02, direction=&amp;#39;both&amp;#39;, plot=TRUE) res$plot &amp;gt; df %&amp;gt;% sample_n(5) title date 1425 Coding: Copy/Paste then refactor 2009-10-31 07:54:31 783 Neo4j 2.0.0-M06 -&amp;gt; 2.0.0-RC1: Working with path expressions 2013-11-23 10:30:41 960 R: Removing for loops 2015-04-18 23:53:20 966 R: dplyr - Error in (list: invalid subscript type &amp;#39;double&amp;#39; 2015-04-27 22:34:43 343 Parsing XML from the unix terminal/shell 2011-09-03 23:42:11 &amp;gt; byWeek = df %&amp;gt;% mutate(year = year(date), week = week(date)) %&amp;gt;% group_by(week, year) %&amp;gt;% summarise(n = n()) %&amp;gt;% ungroup() %&amp;gt;% arrange(desc(n)) &amp;gt; byWeek %&amp;gt;% sample_n(5) Source: local data frame [5 x 3] week year n 1 44 2009 6 2 37 2011 4 3 39 2012 3 4 7 2013 4 5 6 2010 6 &amp;gt; data = byWeek %&amp;gt;% mutate(start_of_week = calculate_start_of_week(week, year)) %&amp;gt;% filter(start_of_week &amp;gt; ymd(&amp;#34;2008-07-01&amp;#34;)) %&amp;gt;% select(start_of_week, n) &amp;gt; data %&amp;gt;% sample_n(5) Source: local data frame [5 x 2] start_of_week n 1 2010-09-10 4 2 2013-04-09 4 3 2010-04-30 6 4 2012-03-11 3 5 2014-12-03 3 res = AnomalyDetectionTs(data, max_anoms=0.</description>
    </item>
    
    <item>
      <title>R: I write more in the last week of the month, or do I?</title>
      <link>https://markhneedham.com/blog/2015/07/12/r-i-write-more-in-the-last-week-of-the-month-or-do-i/</link>
      <pubDate>Sun, 12 Jul 2015 09:53:04 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/12/r-i-write-more-in-the-last-week-of-the-month-or-do-i/</guid>
      <description>&amp;gt; df %&amp;gt;% sample_n(5) title date 946 Python: Equivalent to flatMap for flattening an array of arrays 2015-03-23 00:45:00 175 Ruby: Hash default value 2010-10-16 14:02:37 375 Java/Scala: Runtime.exec hanging/in &amp;#39;pipe_w&amp;#39; state 2011-11-20 20:20:08 1319 Coding Dojo #18: Groovy Bowling Game 2009-06-26 08:15:23 381 Continuous Delivery: Removing manual scenarios 2011-12-05 23:13:34 calculate_start_of_week = function(week, year) { date &amp;lt;- ymd(paste(year, 1, 1, sep=&amp;#34;-&amp;#34;)) week(date) = week return(date) } tidy_df = df %&amp;gt;% mutate(year = year(date), week = week(date), week_in_month = ceiling(day(date) / 7), max_week = max(week_in_month), weeks_from_end = max_week - week_in_month, start_of_week = calculate_start_of_week(week, year)) &amp;gt; tidy_df %&amp;gt;% select(date, weeks_from_end, start_of_week) %&amp;gt;% sample_n(5) date weeks_from_end start_of_week 1023 2008-08-08 21:16:02 3 2008-08-05 800 2014-01-31 06:51:06 0 2014-01-29 859 2014-08-14 10:24:52 3 2014-08-13 107 2010-07-10 22:49:52 3 2010-07-09 386 2011-12-20 23:57:51 2 2011-12-17 weeks_from_end_counts = tidy_df %&amp;gt;% group_by(start_of_week, weeks_from_end) %&amp;gt;% summarise(count = n()) &amp;gt; weeks_from_end_counts Source: local data frame [540 x 4] Groups: start_of_week, weeks_from_end start_of_week weeks_from_end year count 1 2006-08-27 0 2006 1 2 2006-08-27 4 2006 3 3 2006-09-03 4 2006 1 4 2008-02-05 3 2008 2 5 2008-02-12 3 2008 2 6 2008-07-15 2 2008 1 7 2008-07-22 1 2008 1 8 2008-08-05 3 2008 8 9 2008-08-12 2 2008 5 10 2008-08-12 3 2008 9 .</description>
    </item>
    
    <item>
      <title>R: Filling in missing dates with 0s</title>
      <link>https://markhneedham.com/blog/2015/07/12/r-filling-in-missing-dates-with-0s/</link>
      <pubDate>Sun, 12 Jul 2015 08:30:40 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/12/r-filling-in-missing-dates-with-0s/</guid>
      <description>&amp;gt; library(zoo) &amp;gt; library(dplyr) &amp;gt; df %&amp;gt;% sample_n(5) title date 888 R: Converting a named vector to a data frame 2014-10-31 23:47:26 144 Rails: Populating a dropdown list using &amp;#39;form_for&amp;#39; 2010-08-31 01:22:14 615 Onboarding: Sketch the landscape 2013-02-15 07:36:06 28 Javascript: The &amp;#39;new&amp;#39; keyword 2010-03-06 15:16:02 1290 Coding Dojo #16: Reading SUnit code 2009-05-28 23:23:19 &amp;gt; posts_by_date = df %&amp;gt;% mutate(year_mon = as.Date(as.yearmon(date))) %&amp;gt;% count(year_mon) &amp;gt; posts_by_date %&amp;gt;% head(5) year_mon n 1 2006-08-01 1 2 2006-09-01 4 3 2008-02-01 4 4 2008-07-01 2 5 2008-08-01 38 &amp;gt; ggplot(aes(x = year_mon, y = n), data = posts_by_date) + geom_line() &amp;gt; all_dates = seq(as.</description>
    </item>
    
    <item>
      <title>R: Date for given week/year</title>
      <link>https://markhneedham.com/blog/2015/07/10/r-date-for-given-weekyear/</link>
      <pubDate>Fri, 10 Jul 2015 22:01:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/10/r-date-for-given-weekyear/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; df = read.csv(&amp;#34;posts.csv&amp;#34;) &amp;gt; df$date = ymd_hms(df$date) &amp;gt; df %&amp;gt;% sample_n(10) title date 538 Nygard Big Data Model: The Investigation Stage 2012-10-10 00:00:36 341 The read-only database 2011-08-29 23:32:26 1112 CSS in Internet Explorer - Some lessons learned 2008-10-31 15:24:51 143 Coding: Mutating parameters 2010-08-26 07:47:23 433 Scala: Counting number of inversions (via merge sort) for an unsorted collection 2012-03-20 06:53:18 618 neo4j/cypher: SQL style GROUP BY functionality 2013-02-17 21:05:27 1111 Testing Hibernate mappings: Setting up test data 2008-10-30 13:24:14 462 neo4j: What question do you want to answer?</description>
    </item>
    
    <item>
      <title>R: dplyr - Error: cannot modify grouping variable</title>
      <link>https://markhneedham.com/blog/2015/07/09/r-dplyr-error-cannot-modify-grouping-variable/</link>
      <pubDate>Thu, 09 Jul 2015 05:55:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/09/r-dplyr-error-cannot-modify-grouping-variable/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; df %&amp;gt;% sample_n(5) title date 1148 Taiichi Ohno&amp;#39;s Workplace Management: Book Review 2008-12-08 14:14:48 158 Rails: Faking a delete method with &amp;#39;form_for&amp;#39; 2010-09-20 18:52:15 331 Retrospectives: The 4 L&amp;#39;s Retrospective 2011-07-25 21:00:30 1035 msbuild - Use OutputPath instead of OutDir 2008-08-14 18:54:03 1181 The danger of commenting out code 2009-01-17 06:02:33 &amp;gt; df %&amp;gt;% mutate(day = as.Date(date)) %&amp;gt;% count(day) %&amp;gt;% arrange(desc(n)) Source: local data frame [1,140 x 2] day n 1 2012-12-31 6 2 2014-05-31 6 3 2008-08-08 5 4 2013-01-27 5 5 2009-08-24 4 6 2012-06-24 4 7 2012-09-30 4 8 2012-10-27 4 9 2012-11-24 4 10 2013-02-28 4 &amp;gt; df %&amp;gt;% mutate(day = as.</description>
    </item>
    
    <item>
      <title>R: Wimbledon - How do the seeds get on?</title>
      <link>https://markhneedham.com/blog/2015/07/05/r-wimbledon-how-do-the-seeds-get-on/</link>
      <pubDate>Sun, 05 Jul 2015 08:38:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/05/r-wimbledon-how-do-the-seeds-get-on/</guid>
      <description>expected_round = function(seeding) { if(seeding == 1) { return(&amp;#34;Winner&amp;#34;) } else if(seeding == 2) { return(&amp;#34;Finals&amp;#34;) } else if(seeding &amp;lt;= 4) { return(&amp;#34;Semi-Finals&amp;#34;) } else if(seeding &amp;lt;= 8) { return(&amp;#34;Quarter-Finals&amp;#34;) } else if(seeding &amp;lt;= 16) { return(&amp;#34;Round of 16&amp;#34;) } else { return(&amp;#34;Round of 32&amp;#34;) } } &amp;gt; expected_round(1) [1] &amp;#34;Winner&amp;#34; &amp;gt; expected_round(4) [1] &amp;#34;Semi-Finals&amp;#34; round_reached = function(player, main_matches) { furthest_match = main_matches %&amp;gt;% filter(winner == player | loser == player) %&amp;gt;% arrange(desc(round)) %&amp;gt;% head(1) return(ifelse(furthest_match$winner == player, &amp;#34;Winner&amp;#34;, as.</description>
    </item>
    
    <item>
      <title>R: Calculating the difference between ordered factor variables</title>
      <link>https://markhneedham.com/blog/2015/07/02/r-calculating-the-difference-between-ordered-factor-variables/</link>
      <pubDate>Thu, 02 Jul 2015 22:55:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/02/r-calculating-the-difference-between-ordered-factor-variables/</guid>
      <description>rounds = c(&amp;#34;Did not enter&amp;#34;, &amp;#34;Round of 128&amp;#34;, &amp;#34;Round of 64&amp;#34;, &amp;#34;Round of 32&amp;#34;, &amp;#34;Round of 16&amp;#34;, &amp;#34;Quarter-Finals&amp;#34;, &amp;#34;Semi-Finals&amp;#34;, &amp;#34;Finals&amp;#34;, &amp;#34;Winner&amp;#34;) round = factor(&amp;#34;Finals&amp;#34;, levels = rounds, ordered = TRUE) expected = factor(&amp;#34;Winner&amp;#34;, levels = rounds, ordered = TRUE) &amp;gt; round [1] Finals 9 Levels: Did not enter &amp;lt; Round of 128 &amp;lt; Round of 64 &amp;lt; Round of 32 &amp;lt; Round of 16 &amp;lt; Quarter-Finals &amp;lt; ... &amp;lt; Winner &amp;gt; expected [1] Winner 9 Levels: Did not enter &amp;lt; Round of 128 &amp;lt; Round of 64 &amp;lt; Round of 32 &amp;lt; Round of 16 &amp;lt; Quarter-Finals &amp;lt; .</description>
    </item>
    
    <item>
      <title>R: write.csv - unimplemented type &#39;list&#39; in &#39;EncodeElement&#39;</title>
      <link>https://markhneedham.com/blog/2015/06/30/r-write-csv-unimplemented-type-list-in-encodeelement/</link>
      <pubDate>Tue, 30 Jun 2015 22:26:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/30/r-write-csv-unimplemented-type-list-in-encodeelement/</guid>
      <description>&amp;gt; write.csv(foo, &amp;#34;/tmp/foo.csv&amp;#34;, row.names = FALSE) Error in .External2(C_writetable, x, file, nrow(x), p, rnames, sep, eol, : unimplemented type &amp;#39;list&amp;#39; in &amp;#39;EncodeElement&amp;#39; &amp;gt; foo col1 col2 1 1 a 2 2 b 3 3 c &amp;gt; typeof(foo$col1) [1] &amp;#34;double&amp;#34; &amp;gt; typeof(foo$col2) [1] &amp;#34;list&amp;#34; library(dplyr) foo = data.frame(col1 = c(1,2,3)) %&amp;gt;% mutate(col2 = list(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;)) foo = data.frame(col1 = c(1,2,3)) %&amp;gt;% mutate(col2 = list(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;) %&amp;gt;% unlist()) write.csv(foo, &amp;#34;/tmp/foo.csv&amp;#34;, row.</description>
    </item>
    
    <item>
      <title>R: Speeding up the Wimbledon scraping job</title>
      <link>https://markhneedham.com/blog/2015/06/29/r-speeding-up-the-wimbledon-scraping-job/</link>
      <pubDate>Mon, 29 Jun 2015 05:36:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/29/r-speeding-up-the-wimbledon-scraping-job/</guid>
      <description>library(rvest) library(dplyr) scrape_matches1 = function(uri) { matches = data.frame() s = html(uri) rows = s %&amp;gt;% html_nodes(&amp;#34;div#scoresResultsContent tr&amp;#34;) i = 0 for(row in rows) { players = row %&amp;gt;% html_nodes(&amp;#34;td.day-table-name a&amp;#34;) seedings = row %&amp;gt;% html_nodes(&amp;#34;td.day-table-seed&amp;#34;) score = row %&amp;gt;% html_node(&amp;#34;td.day-table-score a&amp;#34;) flags = row %&amp;gt;% html_nodes(&amp;#34;td.day-table-flag img&amp;#34;) if(!is.null(score)) { player1 = players[1] %&amp;gt;% html_text() %&amp;gt;% str_trim() seeding1 = ifelse(!is.na(seedings[1]), seedings[1] %&amp;gt;% html_node(&amp;#34;span&amp;#34;) %&amp;gt;% html_text() %&amp;gt;% str_trim(), NA) flag1 = flags[1] %&amp;gt;% html_attr(&amp;#34;alt&amp;#34;) player2 = players[2] %&amp;gt;% html_text() %&amp;gt;% str_trim() seeding2 = ifelse(!</description>
    </item>
    
    <item>
      <title>R: dplyr - Update rows with earlier/previous rows values</title>
      <link>https://markhneedham.com/blog/2015/06/28/r-dplyr-update-rows-with-earlierprevious-rows-values/</link>
      <pubDate>Sun, 28 Jun 2015 22:30:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/28/r-dplyr-update-rows-with-earlierprevious-rows-values/</guid>
      <description>&amp;gt; data.frame(col1 = c(1,2,3,4,5), col2 = c(&amp;#34;a&amp;#34;, NA, NA , &amp;#34;b&amp;#34;, NA)) col1 col2 1 1 a 2 2 &amp;lt;NA&amp;gt; 3 3 &amp;lt;NA&amp;gt; 4 4 b 5 5 &amp;lt;NA&amp;gt; 1 1 a 2 2 a 3 3 a 4 4 b 5 5 b library(zoo) library(dplyr) &amp;gt; data.frame(col1 = c(1,2,3,4,5), col2 = c(&amp;#34;a&amp;#34;, NA, NA , &amp;#34;b&amp;#34;, NA)) %&amp;gt;% do(na.locf(.)) col1 col2 1 1 a 2 2 a 3 3 a 4 4 b 5 5 b &amp;gt; data.</description>
    </item>
    
    <item>
      <title>R: Command line - Error in GenericTranslator$new : could not find function &#34;loadMethod&#34;</title>
      <link>https://markhneedham.com/blog/2015/06/27/r-command-line-error-in-generictranslatornew-could-not-find-function-loadmethod/</link>
      <pubDate>Sat, 27 Jun 2015 22:47:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/27/r-command-line-error-in-generictranslatornew-could-not-find-function-loadmethod/</guid>
      <description>wimbledon#!/usr/bin/env Rscript library(rvest) library(dplyr) library(stringr) library(readr) # stuff $ time ./wimbledon ... Error in GenericTranslator$new : could not find function &amp;#34;loadMethod&amp;#34; Calls: write.csv ... html_extract_n -&amp;gt; &amp;lt;Anonymous&amp;gt; -&amp;gt; Map -&amp;gt; mapply -&amp;gt; &amp;lt;Anonymous&amp;gt; -&amp;gt; $ Execution halted real	0m1.431s user	0m1.127s sys	0m0.078s library(methods) #!/usr/bin/env Rscript library(methods) library(rvest) library(dplyr) library(stringr) library(readr) </description>
    </item>
    
    <item>
      <title>R: dplyr - squashing multiple rows per group into one</title>
      <link>https://markhneedham.com/blog/2015/06/27/r-dplyr-squashing-multiple-rows-per-group-into-one/</link>
      <pubDate>Sat, 27 Jun 2015 22:36:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/27/r-dplyr-squashing-multiple-rows-per-group-into-one/</guid>
      <description>library(dplyr) &amp;gt; main_matches %&amp;gt;% filter(loser == &amp;#34;Andy Murray&amp;#34;) %&amp;gt;% select(winner, year) winner year 1 Grigor Dimitrov 2014 2 Roger Federer 2012 3 Rafael Nadal 2011 4 Rafael Nadal 2010 5 Andy Roddick 2009 6 Rafael Nadal 2008 7 Marcos Baghdatis 2006 8 David Nalbandian 2005 &amp;gt; main_matches %&amp;gt;% filter(loser == &amp;#34;Andy Murray&amp;#34;) %&amp;gt;% group_by(winner) %&amp;gt;% summarise(years = paste(year)) Source: local data frame [6 x 2] winner years 1 Andy Roddick 2009 2 David Nalbandian 2005 3 Grigor Dimitrov 2014 4 Marcos Baghdatis 2006 5 Rafael Nadal 2011 6 Roger Federer 2012 &amp;gt; paste(c(2008,2009,2010)) [1] &amp;#34;2008&amp;#34; &amp;#34;2009&amp;#34; &amp;#34;2010&amp;#34; &amp;gt; paste(c(2008,2009,2010), collapse=&amp;#34;, &amp;#34;) [1] &amp;#34;2008, 2009, 2010&amp;#34; &amp;gt; main_matches %&amp;gt;% filter(loser == &amp;#34;Andy Murray&amp;#34;) %&amp;gt;% group_by(winner) %&amp;gt;% summarise(years = paste(year, collapse=&amp;#34;, &amp;#34;)) Source: local data frame [6 x 2] winner years 1 Andy Roddick 2009 2 David Nalbandian 2005 3 Grigor Dimitrov 2014 4 Marcos Baghdatis 2006 5 Rafael Nadal 2011, 2010, 2008 6 Roger Federer 2012 &amp;gt; main_matches %&amp;gt;% filter(loser == &amp;#34;Andy Murray&amp;#34;) %&amp;gt;% group_by(winner) %&amp;gt;% arrange(year) %&amp;gt;% summarise(years = paste(year, collapse =&amp;#34;,&amp;#34;), times = length(year)) %&amp;gt;% arrange(desc(times), years) Source: local data frame [6 x 3] winner years times 1 Rafael Nadal 2008,2010,2011 3 2 David Nalbandian 2005 1 3 Marcos Baghdatis 2006 1 4 Andy Roddick 2009 1 5 Roger Federer 2012 1 6 Grigor Dimitrov 2014 1 </description>
    </item>
    
    <item>
      <title>R: ggplot - Show discrete scale even with no value</title>
      <link>https://markhneedham.com/blog/2015/06/26/r-ggplot-show-discrete-scale-even-with-no-value/</link>
      <pubDate>Fri, 26 Jun 2015 22:48:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/26/r-ggplot-show-discrete-scale-even-with-no-value/</guid>
      <description>round_reached = function(player, main_matches) { furthest_match = main_matches %&amp;gt;% filter(winner == player | loser == player) %&amp;gt;% arrange(desc(round)) %&amp;gt;% head(1) return(ifelse(furthest_match$winner == player, &amp;#34;Winner&amp;#34;, as.character(furthest_match$round))) } player_performance = function(name, matches) { player = data.frame() for(y in 2005:2014) { round = round_reached(name, filter(matches, year == y)) if(length(round) == 1) { player = rbind(player, data.frame(year = y, round = round)) } else { player = rbind(player, data.frame(year = y, round = &amp;#34;Did not enter&amp;#34;)) } } return(player) } &amp;gt; player_performance(&amp;#34;Andy Murray&amp;#34;, main_matches) year round 1 2005 Round of 32 2 2006 Round of 16 3 2007 Did not enter 4 2008 Quarter-Finals 5 2009 Semi-Finals 6 2010 Semi-Finals 7 2011 Semi-Finals 8 2012 Finals 9 2013 Winner 10 2014 Quarter-Finals df = player_performance(&amp;#34;Andy Murray&amp;#34;, main_matches) rounds = c(&amp;#34;Did not enter&amp;#34;, &amp;#34;Round of 128&amp;#34;, &amp;#34;Round of 64&amp;#34;, &amp;#34;Round of 32&amp;#34;, &amp;#34;Round of 16&amp;#34;, &amp;#34;Quarter-Finals&amp;#34;, &amp;#34;Semi-Finals&amp;#34;, &amp;#34;Finals&amp;#34;, &amp;#34;Winner&amp;#34;) df$round = factor(df$round, levels = rounds) &amp;gt; df$round [1] Round of 32 Round of 16 Did not enter Quarter-Finals Semi-Finals Semi-Finals Semi-Finals [8] Finals Winner Quarter-Finals Levels: Did not enter Round of 128 Round of 64 Round of 32 Round of 16 Quarter-Finals Semi-Finals Finals Winner ggplot(aes(x = year, y = round, group=1), data = df) + geom_point() + geom_line() + scale_x_continuous(breaks=df$year) + scale_y_discrete(breaks = rounds) ggplot(aes(x = year, y = round, group=1), data = df) + geom_point() + geom_line() + scale_x_continuous(breaks=df$year) + scale_y_discrete(breaks = rounds, drop = FALSE) draw_chart = function(player, main_matches){ df = player_performance(player, main_matches) df$round = factor(df$round, levels = rounds) ggplot(aes(x = year, y = round, group=1), data = df) + geom_point() + geom_line() + scale_x_continuous(breaks=df$year) + scale_y_discrete(breaks = rounds, drop=FALSE) + ggtitle(player) + theme(axis.</description>
    </item>
    
    <item>
      <title>R: Scraping Wimbledon draw data</title>
      <link>https://markhneedham.com/blog/2015/06/25/r-scraping-wimbledon-draw-data/</link>
      <pubDate>Thu, 25 Jun 2015 23:14:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/25/r-scraping-wimbledon-draw-data/</guid>
      <description>library(rvest) library(dplyr) library(stringr) s = html_session(&amp;#34;http://www.atpworldtour.com/en/scores/archive/wimbledon/540/2013/results&amp;#34;) rows = s %&amp;gt;% html_nodes(&amp;#34;div#scoresResultsContent tr&amp;#34;) matches = data.frame() for(row in rows) { players = row %&amp;gt;% html_nodes(&amp;#34;td.day-table-name a&amp;#34;) seedings = row %&amp;gt;% html_nodes(&amp;#34;td.day-table-seed&amp;#34;) score = row %&amp;gt;% html_node(&amp;#34;td.day-table-score a&amp;#34;) if(!is.null(score)) { player1 = players[1] %&amp;gt;% html_text() %&amp;gt;% str_trim() seeding1 = ifelse(!is.na(seedings[1]), seedings[1] %&amp;gt;% html_node(&amp;#34;span&amp;#34;) %&amp;gt;% html_text() %&amp;gt;% str_trim(), NA) player2 = players[2] %&amp;gt;% html_text() %&amp;gt;% str_trim() seeding2 = ifelse(!is.na(seedings[2]), seedings[2] %&amp;gt;% html_node(&amp;#34;span&amp;#34;) %&amp;gt;% html_text() %&amp;gt;% str_trim(), NA) matches = rbind(data.</description>
    </item>
    
    <item>
      <title>R: Scraping the release dates of github projects</title>
      <link>https://markhneedham.com/blog/2015/06/23/r-scraping-the-release-dates-of-github-projects/</link>
      <pubDate>Tue, 23 Jun 2015 22:34:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/23/r-scraping-the-release-dates-of-github-projects/</guid>
      <description>library(dplyr) library(rvest) process_page = function(releases, session) { rows = session %&amp;gt;% html_nodes(&amp;#34;ul.release-timeline-tags li&amp;#34;) for(row in rows) { date = row %&amp;gt;% html_node(&amp;#34;span.date&amp;#34;) version = row %&amp;gt;% html_node(&amp;#34;div.tag-info a&amp;#34;) if(!is.null(version) &amp;amp;&amp;amp; !is.null(date)) { date = date %&amp;gt;% html_text() %&amp;gt;% str_trim() version = version %&amp;gt;% html_text() %&amp;gt;% str_trim() releases = rbind(releases, data.frame(date = date, version = version)) } } return(releases) } &amp;gt; r = process_page(data.frame(), html_session(&amp;#34;https://github.com/apache/cassandra/releases&amp;#34;)) &amp;gt; r date version 1 Jun 22, 2015 cassandra-2.</description>
    </item>
    
    <item>
      <title>R: Scraping Neo4j release dates with rvest</title>
      <link>https://markhneedham.com/blog/2015/06/21/r-scraping-neo4j-release-dates-with-rvest/</link>
      <pubDate>Sun, 21 Jun 2015 22:07:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/21/r-scraping-neo4j-release-dates-with-rvest/</guid>
      <description>download.file(&amp;#34;http://neo4j.com/release-notes/page/1&amp;#34;, &amp;#34;release-notes.html&amp;#34;) download.file(&amp;#34;http://neo4j.com/release-notes/page/2&amp;#34;, &amp;#34;release-notes2.html&amp;#34;) library(rvest) library(dplyr) page1 &amp;lt;- html(&amp;#34;release-notes.html&amp;#34;) page2 &amp;lt;- html(&amp;#34;release-notes2.html&amp;#34;) rows = c(page1 %&amp;gt;% html_nodes(&amp;#34;div.small-12 div.row&amp;#34;), page2 %&amp;gt;% html_nodes(&amp;#34;div.small-12 div.row&amp;#34;) ) &amp;gt; rows %&amp;gt;% head(1) [[1]] &amp;lt;div class=&amp;#34;row&amp;#34;&amp;gt; &amp;lt;h3 class=&amp;#34;entry-title&amp;#34;&amp;gt;&amp;lt;a href=&amp;#34;http://neo4j.com/release-notes/neo4j-2-2-2/&amp;#34;&amp;gt;Latest Release: Neo4j 2.2.2&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt; &amp;lt;h6&amp;gt;05/21/2015&amp;lt;/h6&amp;gt; &amp;lt;p&amp;gt;Neo4j 2.2.2 is a maintenance release, with critical improvements.&amp;lt;/p&amp;gt; &amp;lt;p&amp;gt;Notably, this release:&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;Provides support for running Neo4j on Oracle and OpenJDK Java 8 runtimes&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Resolves an issue that prevented the Neo4j Browser from loading in the latest Chrome release (43.</description>
    </item>
    
    <item>
      <title>R: dplyr - segfault cause &#39;memory not mapped&#39;</title>
      <link>https://markhneedham.com/blog/2015/06/20/r-dplyr-segfault-cause-memory-not-mapped/</link>
      <pubDate>Sat, 20 Jun 2015 22:18:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/20/r-dplyr-segfault-cause-memory-not-mapped/</guid>
      <description>library(readr) dlines = data.frame(column = read_lines(&amp;#34;~/projects/logs/2015-06-18-22-docs&amp;#34;)) extract_uri = function(log) { parts = str_extract_all(log, &amp;#34;\&amp;#34;[^\&amp;#34;]*\&amp;#34;&amp;#34;) return(lapply(parts, function(p) str_match(p[1], &amp;#34;GET (.*) HTTP&amp;#34;)[2] %&amp;gt;% as.character)) } library(dplyr) pages_viewed = dlines %&amp;gt;% mutate(uri = extract_uri(column)) %&amp;gt;% count(uri) %&amp;gt;% arrange(desc(n)) segfault cause &amp;#39;memory not mapped&amp;#39; ## Error in eval(expr, envir, enclos): cannot group column uri, of class &amp;#39;list&amp;#39; extract_uri = function(log) { parts = str_extract_all(log, &amp;#34;\&amp;#34;[^\&amp;#34;]*\&amp;#34;&amp;#34;) return(unlist(lapply(parts, function(p) str_match(p[1], &amp;#34;GET (.*) HTTP&amp;#34;)[2] %&amp;gt;% as.character))) } </description>
    </item>
    
    <item>
      <title>R: Regex - capturing multiple matches of the same group</title>
      <link>https://markhneedham.com/blog/2015/06/19/r-regex-capturing-multiple-matches-of-the-same-group/</link>
      <pubDate>Fri, 19 Jun 2015 21:38:47 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/19/r-regex-capturing-multiple-matches-of-the-same-group/</guid>
      <description>log = &amp;#39;2015-06-18-22:277:548311224723746831\t2015-06-18T22:00:11\t2015-06-18T22:00:05Z\t93317114\tip-127-0-0-1\t127.0.0.5\tUser\tNotice\tneo4j.com.access.log\t127.0.0.3 - - [18/Jun/2015:22:00:11 +0000] &amp;#34;GET /docs/stable/query-updating.html HTTP/1.1&amp;#34; 304 0 &amp;#34;http://neo4j.com/docs/stable/cypher-introduction.html&amp;#34; &amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.124 Safari/537.36&amp;#34;&amp;#39; &amp;gt; library(stringr) &amp;gt; str_match(log, &amp;#34;\&amp;#34;[^\&amp;#34;]*\&amp;#34;&amp;#34;) [,1] [1,] &amp;#34;\&amp;#34;GET /docs/stable/query-updating.html HTTP/1.1\&amp;#34;&amp;#34; &amp;gt; str_extract_all(log, &amp;#34;\&amp;#34;[^\&amp;#34;]*\&amp;#34;&amp;#34;) [[1]] [1] &amp;#34;\&amp;#34;GET /docs/stable/query-updating.html HTTP/1.1\&amp;#34;&amp;#34; [2] &amp;#34;\&amp;#34;http://neo4j.com/docs/stable/cypher-introduction.html\&amp;#34;&amp;#34; [3] &amp;#34;\&amp;#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.124 Safari/537.36\&amp;#34;&amp;#34; parts = str_extract_all(log, &amp;#34;\&amp;#34;[^\&amp;#34;]*\&amp;#34;&amp;#34;)[[1]] uri = str_match(parts[1], &amp;#34;GET (.*) HTTP&amp;#34;)[2] referer = str_match(parts[2], &amp;#34;\&amp;#34;(.</description>
    </item>
    
    <item>
      <title>R: ggplot geom_density - Error in exists(name, envir = env, mode = mode) : argument &#34;env&#34; is missing, with no default</title>
      <link>https://markhneedham.com/blog/2015/06/03/r-ggplot-geom_density-error-in-existsname-envir-env-mode-mode-argument-env-is-missing-with-no-default/</link>
      <pubDate>Wed, 03 Jun 2015 05:52:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/03/r-ggplot-geom_density-error-in-existsname-envir-env-mode-mode-argument-env-is-missing-with-no-default/</guid>
      <description>library(dplyr) df2011 = read.csv(&amp;#34;~/projects/rLearning/showcases.2011.csv&amp;#34;, na.strings = c(&amp;#34;&amp;#34;, &amp;#34;NA&amp;#34;)) df2011 = df2011 %&amp;gt;% na.omit() &amp;gt; df2011 %&amp;gt;% head() X Sep..19 Sep..20 Sep..21 Sep..22 Sep..23 Sep..26 Sep..27 Sep..28 Sep..29 Sep..30 Oct..3 3 Showcase 1 50969 21901 32815 44432 24273 30554 20963 28941 25851 28800 37703 4 Showcase 2 45429 34061 53186 31428 22320 24337 41373 45437 41125 36319 38752 6 Bid 1 42000 14000 32000 27000 18750 27222 25000 35000 22500 21300 21567 7 Bid 2 34000 59900 45000 38000 23000 18525 32000 45000 32000 27500 23800 9 Difference 1 8969 7901 815 17432 5523 3332 -4037 -6059 3351 7500 16136 10 Difference 2 11429 -25839 8186 -6572 -680 5812 9373 437 9125 8819 14952 .</description>
    </item>
    
    <item>
      <title>R: dplyr - removing empty rows</title>
      <link>https://markhneedham.com/blog/2015/06/02/r-dplyr-removing-empty-rows/</link>
      <pubDate>Tue, 02 Jun 2015 06:49:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/02/r-dplyr-removing-empty-rows/</guid>
      <description>wget ￼http://www.greenteapress.com/thinkbayes/showcases.2011.csv￼ library(dplyr) df2011 = read.csv(&amp;#34;~/projects/rLearning/showcases.2011.csv&amp;#34;) &amp;gt; df2011 %&amp;gt;% head(10) X Sep..19 Sep..20 Sep..21 Sep..22 Sep..23 Sep..26 Sep..27 Sep..28 Sep..29 Sep..30 Oct..3 1 5631K 5632K 5633K 5634K 5635K 5641K 5642K 5643K 5644K 5645K 5681K 2 3 Showcase 1 50969 21901 32815 44432 24273 30554 20963 28941 25851 28800 37703 4 Showcase 2 45429 34061 53186 31428 22320 24337 41373 45437 41125 36319 38752 5 ... df2011 = read.csv(&amp;#34;~/projects/rLearning/showcases.2011.csv&amp;#34;, na.strings = c(&amp;#34;&amp;#34;, &amp;#34;NA&amp;#34;)) df2011 = df2011 %&amp;gt;% na.</description>
    </item>
    
    <item>
      <title>R: Think Bayes Euro Problem</title>
      <link>https://markhneedham.com/blog/2015/05/31/r-think-bayes-euro-problem/</link>
      <pubDate>Sun, 31 May 2015 23:11:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/31/r-think-bayes-euro-problem/</guid>
      <description>When spun on edge 250 times, a Belgian one-euro coin came up heads 140 times and tails 110. ‘It looks very suspicious to me,’ said Barry Blight, a statistics lecturer at the London School of Economics. ‘If the coin were unbiased, the chance of getting a result as extreme as that would be less than 7%.’
But do these data give evidence that the coin is biased rather than fair?</description>
    </item>
    
    <item>
      <title>R: ggplot - Displaying multiple charts with a for loop</title>
      <link>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</link>
      <pubDate>Thu, 14 May 2015 00:17:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</guid>
      <description>library(RNeo4j) graph = startGraph(&amp;#34;http://127.0.0.1:7474/db/data/&amp;#34;) eventId = &amp;#34;220750415&amp;#34; query = &amp;#34;match (g:Group {name: &amp;#39;Neo4j - London User Group&amp;#39;})-[:HOSTED_EVENT]-&amp;gt; (e {id: {id}})&amp;lt;-[:TO]-(rsvp {response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(person) WITH rsvp, person MATCH (person)-[:RSVPD]-&amp;gt;(otherRSVP) WITH person, rsvp, otherRSVP ORDER BY person.id, otherRSVP.time WITH person, rsvp, COLLECT(otherRSVP)[0] AS earliestRSVP return rsvp.time, earliestRSVP.time, person.id&amp;#34; df = cypher(graph, query, id= eventId) &amp;gt; df %&amp;gt;% sample_n(10) rsvp.time earliestRSVP.time person.id 18 1.430819e+12 1.392726e+12 130976662 95 1.430069e+12 1.430069e+12 10286388 79 1.429035e+12 1.429035e+12 38344282 64 1.</description>
    </item>
    
    <item>
      <title>R: Cohort heatmap of Neo4j London meetup</title>
      <link>https://markhneedham.com/blog/2015/05/11/r-cohort-heatmap-of-neo4j-london-meetup/</link>
      <pubDate>Mon, 11 May 2015 23:16:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/11/r-cohort-heatmap-of-neo4j-london-meetup/</guid>
      <description>df = read.csv(&amp;#34;/tmp/df.csv&amp;#34;) &amp;gt; df %&amp;gt;% sample_n(5) rsvp.time person.id time date 255 1.354277e+12 12228948 2012-11-30 12:05:08 2012-11 2475 1.407342e+12 19057581 2014-08-06 16:26:04 2014-08 3988 1.421769e+12 66122172 2015-01-20 15:58:02 2015-01 4411 1.419377e+12 165750262 2014-12-23 23:27:44 2014-12 1010 1.383057e+12 74602292 2013-10-29 14:24:32 2013-10 firstMeetup = df %&amp;gt;% group_by(person.id) %&amp;gt;% summarise(firstEvent = min(time), count = n()) %&amp;gt;% arrange(desc(count)) firstMeetup$date = format(as.Date(firstMeetup$firstEvent), &amp;#34;%Y-%m&amp;#34;) countsForCohort = function(df, firstMeetup, cohort) { members = (firstMeetup %&amp;gt;% filter(date == cohort))$person.</description>
    </item>
    
    <item>
      <title>R: Neo4j London meetup group - How many events do people come to?</title>
      <link>https://markhneedham.com/blog/2015/05/09/r-neo4j-london-meetup-group-how-many-events-do-people-come-to/</link>
      <pubDate>Sat, 09 May 2015 22:33:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/09/r-neo4j-london-meetup-group-how-many-events-do-people-come-to/</guid>
      <description>How often do people come to meetups?
library(RNeo4j) library(dplyr) graph = startGraph(&amp;#34;http://localhost:7474/db/data/&amp;#34;) query = &amp;#34;MATCH (g:Group {name: &amp;#39;Neo4j - London User Group&amp;#39;})-[:HOSTED_EVENT]-&amp;gt;(event)&amp;lt;-[:TO]-({response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(profile)-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g) WHERE (event.time + event.utc_offset) &amp;lt; timestamp() RETURN event.id, event.time + event.utc_offset AS eventTime, profile.id, membership.joined&amp;#34; df = cypher(graph, query) &amp;gt; df %&amp;gt;% head() event.id eventTime profile.id membership.joined 1 20616111 1.309372e+12 6436797 1.307285e+12 2 20616111 1.309372e+12 12964956 1.307275e+12 3 20616111 1.309372e+12 14533478 1.307290e+12 4 20616111 1.309372e+12 10793775 1.307705e+12 5 24528711 1.</description>
    </item>
    
    <item>
      <title>R: dplyr - Error in (list: invalid subscript type &#39;double&#39;</title>
      <link>https://markhneedham.com/blog/2015/04/27/r-dplyr-error-in-list-invalid-subscript-type-double/</link>
      <pubDate>Mon, 27 Apr 2015 22:34:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/27/r-dplyr-error-in-list-invalid-subscript-type-double/</guid>
      <description>library(dplyr) df = data.frame(score = c(5,7,8,10,12,20), percentile = c(0.05,0.1,0.15,0.20,0.25,0.5)) &amp;gt; (df %&amp;gt;% filter(percentile &amp;gt; 0.05) %&amp;gt;% slice(1))$score [1] 7 targetPercentiles = c(0.05, 0.2) percentilesDf = data.frame(targetPercentile = targetPercentiles) &amp;gt; percentilesDf %&amp;gt;% group_by(targetPercentile) %&amp;gt;% mutate(x = (df %&amp;gt;% filter(percentile &amp;gt; targetPercentile) %&amp;gt;% slice(1))$score) Error in (list(score = c(5, 7, 8, 10, 12, 20), percentile = c(0.05, 0.1, : invalid subscript type &amp;#39;double&amp;#39; df = data.frame(score = c(5,7,8,10,12,20), percentile = c(0.05,0.1,0.15,0.20,0.25,0.5)) targetPercentiles = c(0.</description>
    </item>
    
    <item>
      <title>R: Think Bayes Locomotive Problem - Posterior probabilities for different priors</title>
      <link>https://markhneedham.com/blog/2015/04/24/r-think-bayes-locomotive-problem-posterior-probabilities-for-different-priors/</link>
      <pubDate>Fri, 24 Apr 2015 23:53:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/24/r-think-bayes-locomotive-problem-posterior-probabilities-for-different-priors/</guid>
      <description>One day you see a locomotive with the number 60. Estimate how many loco- motives the railroad has.
library(dplyr) possibleValues = 1:1000 observations = c(60) l = list(value = possibleValues, observation = observations) df = expand.grid(l) &amp;gt; df %&amp;gt;% head() value observation 1 1 60 2 2 60 3 3 60 4 4 60 5 5 60 6 6 60 prior = 1 / length(possibleValues) df = df %&amp;gt;% mutate(score = ifelse(value &amp;lt; observation, 0, 1/value)) &amp;gt; df %&amp;gt;% sample_n(10) value observation score 179 179 60 0.</description>
    </item>
    
    <item>
      <title>R: Replacing for loops with data frames</title>
      <link>https://markhneedham.com/blog/2015/04/22/r-replacing-for-loops-with-data-frames/</link>
      <pubDate>Wed, 22 Apr 2015 22:18:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/22/r-replacing-for-loops-with-data-frames/</guid>
      <description>Suppose I select a die from the box at random, roll it, and get a 6. What is the probability that I rolled each die?
likelihoods = function(names, observations) { scores = rep(1.0 / length(names), length(names)) names(scores) = names for(name in names) { for(observation in observations) { if(name &amp;lt; observation) { scores[paste(name)] = 0 } else { scores[paste(name)] = scores[paste(name)] * (1.0 / name) } } } return(scores) } dice = c(4,6,8,12,20) l1 = likelihoods(dice, c(6)) &amp;gt; l1 / sum(l1) 4 6 8 12 20 0.</description>
    </item>
    
    <item>
      <title>R: Numeric keys in the nested list/dictionary</title>
      <link>https://markhneedham.com/blog/2015/04/21/r-numeric-keys-in-the-nested-listdictionary/</link>
      <pubDate>Tue, 21 Apr 2015 05:59:24 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/21/r-numeric-keys-in-the-nested-listdictionary/</guid>
      <description>Suppose I select a die from the box at random, roll it, and get a 6. What is the probability that I rolled each die?
dice = c(4,6,8,12,20) priors = rep(1.0 / length(dice), length(dice)) names(priors) = dice &amp;gt; priors 4 6 8 12 20 0.2 0.2 0.2 0.2 0.2 &amp;gt; priors[8] &amp;lt;NA&amp;gt; NA dice = c(4,6,8,12,20) priors = rep(1.0 / length(dice), length(dice)) names(priors) = sapply(dice, paste) &amp;gt; priors[&amp;#34;8&amp;#34;] 8 0.2 dice = c(4,6,8,12,20) priors = rep(1.</description>
    </item>
    
    <item>
      <title>R: non-numeric argument to binary operator</title>
      <link>https://markhneedham.com/blog/2015/04/19/r-non-numeric-argument-to-binary-operator/</link>
      <pubDate>Sun, 19 Apr 2015 23:08:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/19/r-non-numeric-argument-to-binary-operator/</guid>
      <description>names = c(1,2,3,4,5,6) &amp;gt; print(&amp;#34;names: &amp;#34; + names) Error in &amp;#34;names: &amp;#34; + names : non-numeric argument to binary operator &amp;gt; print(&amp;#34;names: &amp;#34;, names) [1] &amp;#34;names: &amp;#34; &amp;gt; print(paste(&amp;#34;names: &amp;#34;, names)) [1] &amp;#34;names: 1&amp;#34; &amp;#34;names: 2&amp;#34; &amp;#34;names: 3&amp;#34; &amp;#34;names: 4&amp;#34; &amp;#34;names: 5&amp;#34; &amp;#34;names: 6&amp;#34; &amp;gt; print(paste(&amp;#34;names: &amp;#34;, toString(names))) [1] &amp;#34;names: 1, 2, 3, 4, 5, 6&amp;#34; </description>
    </item>
    
    <item>
      <title>R: Removing for loops</title>
      <link>https://markhneedham.com/blog/2015/04/18/r-removing-for-loops/</link>
      <pubDate>Sat, 18 Apr 2015 23:53:20 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/18/r-removing-for-loops/</guid>
      <description>likelihoods = function(names, mixes, observations) { scores = rep(1, length(names)) names(scores) = names for(name in names) { for(observation in observations) { scores[name] = scores[name] * mixes[[name]][observation] } } return(scores) } Names = c(&amp;#34;Bowl 1&amp;#34;, &amp;#34;Bowl 2&amp;#34;) bowl1Mix = c(0.75, 0.25) names(bowl1Mix) = c(&amp;#34;vanilla&amp;#34;, &amp;#34;chocolate&amp;#34;) bowl2Mix = c(0.5, 0.5) names(bowl2Mix) = c(&amp;#34;vanilla&amp;#34;, &amp;#34;chocolate&amp;#34;) Mixes = list(&amp;#34;Bowl 1&amp;#34; = bowl1Mix, &amp;#34;Bowl 2&amp;#34; = bowl2Mix) Mixes Observations = c(&amp;#34;vanilla&amp;#34;, &amp;#34;vanilla&amp;#34;, &amp;#34;vanilla&amp;#34;, &amp;#34;chocolate&amp;#34;) l = likelihoods(Names, Mixes, Observations) &amp;gt; l / sum(l) Bowl 1 Bowl 2 0.</description>
    </item>
    
    <item>
      <title>R: Think Bayes - More posterior probability calculations</title>
      <link>https://markhneedham.com/blog/2015/04/16/r-think-bayes-more-posterior-probability-calculations/</link>
      <pubDate>Thu, 16 Apr 2015 20:57:20 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/16/r-think-bayes-more-posterior-probability-calculations/</guid>
      <description>f = function(names,likelihoods) { # Assume each option has an equal prior priors = rep(1, length(names)) / length(names) # create a data frame with all info you have dt = data.frame(names,priors,likelihoods) # calculate posterior probabilities dt$post = dt$priors*dt$likelihoods / sum(dt$priors*dt$likelihoods) # specify what you want the function to return list(names=dt$names, priors=dt$priors, likelihoods=dt$likelihoods, posteriors=dt$post) } mixes = { &amp;#39;Bowl 1&amp;#39;:dict(vanilla=0.75, chocolate=0.25), &amp;#39;Bowl 2&amp;#39;:dict(vanilla=0.5, chocolate=0.5), } Likelihoods = c(0.75,0.5) Names = c(&amp;#34;Bowl 1&amp;#34;, &amp;#34;Bowl 2&amp;#34;) res=f(Names,Likelihoods) &amp;gt; res$posteriors[res$name == &amp;#34;Bowl 1&amp;#34;] [1] 0.</description>
    </item>
    
    <item>
      <title>R: Creating an object with functions to calculate conditional probability</title>
      <link>https://markhneedham.com/blog/2015/04/12/r-creating-an-object-with-functions-to-calculate-conditional-probability/</link>
      <pubDate>Sun, 12 Apr 2015 07:55:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/12/r-creating-an-object-with-functions-to-calculate-conditional-probability/</guid>
      <description>Now suppose you choose one of the bowls at random and, without looking, select a cookie at random. The cookie is vanilla.
What is the probability that it came from Bowl 1?
pmf = Pmf() pmf.Set(&amp;#39;Bowl 1&amp;#39;, 0.5) pmf.Set(&amp;#39;Bowl 2&amp;#39;, 0.5) pmf.Mult(&amp;#39;Bowl 1&amp;#39;, 0.75) pmf.Mult(&amp;#39;Bowl 2&amp;#39;, 0.5) pmf.Normalize() print pmf.Prob(&amp;#39;Bowl 1&amp;#39;) pBowl1 = 0.5 pBowl2 = 0.5 pVanillaGivenBowl1 = 0.75 pVanillaGivenBowl2 = 0.5 &amp;gt; (pBowl1 * pVanillaGivenBowl1) / ((pBowl1 * pVanillaGivenBowl1) + (PBowl2 * pVanillaGivenBowl2)) 0.</description>
    </item>
    
    <item>
      <title>R: Snakes and ladders markov chain</title>
      <link>https://markhneedham.com/blog/2015/04/09/r-snakes-and-ladders-markov-chain/</link>
      <pubDate>Thu, 09 Apr 2015 22:02:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/09/r-snakes-and-ladders-markov-chain/</guid>
      <description>n=100 # We have 6 extra columns because we want to represent throwing of the dice which results in a final square &amp;gt; 100 M=matrix(0,n+1,n+1+6) rownames(M)=0:n colnames(M)=0:(n+6) # set probabilities of landing on each square assuming that there aren&amp;#39;t any snakes or ladders for(i in 1:6){ diag(M[,(i+1):(i+1+n)])=1/6 } # account for &amp;#39;bounce back&amp;#39; if a dice roll leads to a final score &amp;gt; 100 for(i in 96:100) { for(c in 102:107) { idx = 101 - (c - 101) M[i, idx] = M[i, idx] + M[i, c] } } &amp;gt; M[95:100,95:101] 94 95 96 97 98 99 100 94 0 0.</description>
    </item>
    
    <item>
      <title>R: Markov Chain Wikipedia Example</title>
      <link>https://markhneedham.com/blog/2015/04/05/r-markov-chain-wikipedia-example/</link>
      <pubDate>Sun, 05 Apr 2015 10:07:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/05/r-markov-chain-wikipedia-example/</guid>
      <description>It is required to possess a property that is usually characterized as &amp;ldquo;memoryless&amp;rdquo;: the probability distribution of the next state depends only on the current state and not on the sequence of events that preceded it.
M = matrix(c(0.9, 0.075, 0.025, 0.15, 0.8, 0.05, 0.25, 0.25, 0.5), nrow = 3, ncol = 3, byrow = TRUE) &amp;gt; M [,1] [,2] [,3] [1,] 0.90 0.075 0.025 [2,] 0.15 0.800 0.050 [3,] 0.</description>
    </item>
    
    <item>
      <title>R/ggplot: Controlling X axis order</title>
      <link>https://markhneedham.com/blog/2015/02/27/rggplot-controlling-x-axis-order/</link>
      <pubDate>Fri, 27 Feb 2015 00:49:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/27/rggplot-controlling-x-axis-order/</guid>
      <description>df = read.csv(&amp;#34;/tmp/friends.csv&amp;#34;) top = df %&amp;gt;% head(20) ggplot(aes(x = p.name, y = colleagues), data = top) + geom_bar(fill = &amp;#34;dark blue&amp;#34;, stat = &amp;#34;identity&amp;#34;) ggplot(aes(x = p.name, y = colleagues), data = top) + geom_bar(fill = &amp;#34;dark blue&amp;#34;, stat = &amp;#34;identity&amp;#34;) + scale_x_discrete(limits= top$p.name) </description>
    </item>
    
    <item>
      <title>R: Conditionally updating rows of a data frame</title>
      <link>https://markhneedham.com/blog/2015/02/26/r-conditionally-updating-rows-of-a-data-frame/</link>
      <pubDate>Thu, 26 Feb 2015 00:45:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/26/r-conditionally-updating-rows-of-a-data-frame/</guid>
      <description>library(zoo) library(dplyr) monthNumber = function(cohort, date) { cohortAsDate = as.yearmon(cohort) dateAsDate = as.yearmon(date) if(cohortAsDate &amp;gt; dateAsDate) { &amp;#34;NA&amp;#34; } else { paste(round((dateAsDate - cohortAsDate) * 12), sep=&amp;#34;&amp;#34;) } } cohortAttendance %&amp;gt;% group_by(row_number()) %&amp;gt;% mutate(monthNumber = monthNumber(cohort, date)) %&amp;gt;% filter(monthNumber != &amp;#34;NA&amp;#34;) %&amp;gt;% filter(monthNumber != &amp;#34;0&amp;#34;) %&amp;gt;% mutate(monthNumber = as.numeric(monthNumber)) %&amp;gt;% arrange(monthNumber) system.time(cohortAttendance %&amp;gt;% group_by(row_number()) %&amp;gt;% mutate(monthNumber = monthNumber(cohort, date)) %&amp;gt;% filter(monthNumber != &amp;#34;NA&amp;#34;) %&amp;gt;% filter(monthNumber != &amp;#34;0&amp;#34;) %&amp;gt;% mutate(monthNumber = as.</description>
    </item>
    
    <item>
      <title>R: Cohort analysis of Neo4j meetup members</title>
      <link>https://markhneedham.com/blog/2015/02/24/r-cohort-analysis-of-neo4j-meetup-members/</link>
      <pubDate>Tue, 24 Feb 2015 01:19:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/24/r-cohort-analysis-of-neo4j-meetup-members/</guid>
      <description>library(RNeo4j) graph = startGraph(&amp;#34;http://127.0.0.1:7474/db/data/&amp;#34;) query = &amp;#34;MATCH (g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;})-[:HOSTED_EVENT]-&amp;gt;(e), (e)&amp;lt;-[:TO]-(rsvp {response: \&amp;#34;yes\&amp;#34;})&amp;lt;-[:RSVPD]-(person) RETURN rsvp.time, person.id&amp;#34; timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;, tz = &amp;#34;GMT&amp;#34;) df = cypher(graph, query) df$time = timestampToDate(df$rsvp.time) df$date = format(as.Date(df$time), &amp;#34;%Y-%m&amp;#34;) &amp;gt; df %&amp;gt;% head() ## rsvp.time person.id time date ## 612 1.404857e+12 23362191 2014-07-08 22:00:29 2014-07 ## 1765 1.380049e+12 112623332 2013-09-24 18:58:00 2013-09 ## 1248 1.390563e+12 9746061 2014-01-24 11:24:35 2014-01 ## 1541 1.</description>
    </item>
    
    <item>
      <title>R/dplyr: Extracting data frame column value for filtering with %in%</title>
      <link>https://markhneedham.com/blog/2015/02/22/rdplyr-extracting-data-frame-column-value-for-filtering-with-in/</link>
      <pubDate>Sun, 22 Feb 2015 08:58:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/22/rdplyr-extracting-data-frame-column-value-for-filtering-with-in/</guid>
      <description>library(dplyr) df = data.frame(userId = c(1,2,3,4,5), score = c(2,3,4,5,5)) highScoringPeople = df %&amp;gt;% filter(score &amp;gt; 3) %&amp;gt;% select(userId) &amp;gt; highScoringPeople userId 1 3 2 4 3 5 &amp;gt; df %&amp;gt;% filter(userId %in% highScoringPeople) [1] userId score &amp;lt;0 rows&amp;gt; (or 0-length row.names) &amp;gt; df %&amp;gt;% filter(userId %in% c(3,4,5)) userId score 1 3 4 2 4 5 3 5 5 &amp;gt; str(c(3,4,5)) num [1:3] 3 4 5 &amp;gt; str(highScoringPeople) &amp;#39;data.frame&amp;#39;:	3 obs. of 1 variable: $ userId: num 3 4 5 highScoringPeople = (df %&amp;gt;% filter(score &amp;gt; 3))$userId &amp;gt; str(highScoringPeople) num [1:3] 3 4 5 &amp;gt; df %&amp;gt;% filter(userId %in% highScoringPeople) userId score 1 3 4 2 4 5 3 5 5 highScoringPeople = (df %&amp;gt;% filter(score &amp;gt; 3) %&amp;gt;% select(userId))[[1]] &amp;gt; str(highScoringPeople) num [1:3] 3 4 5 </description>
    </item>
    
    <item>
      <title>R: Weather vs attendance at NoSQL meetups</title>
      <link>https://markhneedham.com/blog/2015/02/11/r-weather-vs-attendance-at-nosql-meetups/</link>
      <pubDate>Wed, 11 Feb 2015 07:09:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/11/r-weather-vs-attendance-at-nosql-meetups/</guid>
      <description>library(weatherData) # London City Airport getDetailedWeatherForYear = function(year) { getWeatherForDate(&amp;#34;LCY&amp;#34;, start_date= paste(sep=&amp;#34;&amp;#34;, year, &amp;#34;-01-01&amp;#34;), end_date = paste(sep=&amp;#34;&amp;#34;, year, &amp;#34;-12-31&amp;#34;), opt_detailed = FALSE, opt_all_columns = TRUE) } df = rbind(getDetailedWeatherForYear(2011), getDetailedWeatherForYear(2012), getDetailedWeatherForYear(2013), getDetailedWeatherForYear(2014), getWeatherForDate(&amp;#34;LCY&amp;#34;, start_date=&amp;#34;2015-01-01&amp;#34;, end_date = &amp;#34;2015-01-25&amp;#34;, opt_detailed = FALSE, opt_all_columns = TRUE)) write.csv(df, &amp;#39;weather/temp_data.csv&amp;#39;, row.names = FALSE) &amp;#34;Date&amp;#34;,&amp;#34;GMT&amp;#34;,&amp;#34;Max_TemperatureC&amp;#34;,&amp;#34;Mean_TemperatureC&amp;#34;,&amp;#34;Min_TemperatureC&amp;#34;,&amp;#34;Dew_PointC&amp;#34;,&amp;#34;MeanDew_PointC&amp;#34;,&amp;#34;Min_DewpointC&amp;#34;,&amp;#34;Max_Humidity&amp;#34;,&amp;#34;Mean_Humidity&amp;#34;,&amp;#34;Min_Humidity&amp;#34;,&amp;#34;Max_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Mean_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Min_Sea_Level_PressurehPa&amp;#34;,&amp;#34;Max_VisibilityKm&amp;#34;,&amp;#34;Mean_VisibilityKm&amp;#34;,&amp;#34;Min_VisibilitykM&amp;#34;,&amp;#34;Max_Wind_SpeedKm_h&amp;#34;,&amp;#34;Mean_Wind_SpeedKm_h&amp;#34;,&amp;#34;Max_Gust_SpeedKm_h&amp;#34;,&amp;#34;Precipitationmm&amp;#34;,&amp;#34;CloudCover&amp;#34;,&amp;#34;Events&amp;#34;,&amp;#34;WindDirDegrees&amp;#34; 2011-01-01,&amp;#34;2011-1-1&amp;#34;,7,6,4,5,3,1,93,85,76,1027,1025,1023,10,9,3,14,10,NA,0,7,&amp;#34;Rain&amp;#34;,312 2011-01-02,&amp;#34;2011-1-2&amp;#34;,4,3,2,1,0,-1,87,81,75,1029,1028,1027,10,10,10,11,8,NA,0,7,&amp;#34;&amp;#34;,321 2011-01-03,&amp;#34;2011-1-3&amp;#34;,4,2,1,0,-2,-5,87,74,56,1028,1024,1019,10,10,10,8,5,NA,0,6,&amp;#34;Rain-Snow&amp;#34;,249 2011-01-04,&amp;#34;2011-1-4&amp;#34;,6,3,1,3,1,-1,93,83,65,1019,1013,1008,10,10,10,21,6,NA,0,5,&amp;#34;Rain&amp;#34;,224 2011-01-05,&amp;#34;2011-1-5&amp;#34;,8,7,5,6,3,0,93,80,61,1008,1000,994,10,9,4,26,16,45,0,4,&amp;#34;Rain&amp;#34;,200 2011-01-06,&amp;#34;2011-1-6&amp;#34;,7,4,3,6,3,1,93,90,87,1002,996,993,10,9,5,13,6,NA,0,5,&amp;#34;Rain&amp;#34;,281 2011-01-07,&amp;#34;2011-1-7&amp;#34;,11,6,2,9,5,2,100,91,82,1003,999,996,10,7,2,24,11,NA,0,5,&amp;#34;Rain-Snow&amp;#34;,124 2011-01-08,&amp;#34;2011-1-8&amp;#34;,11,7,4,8,4,-1,87,77,65,1004,997,987,10,10,5,39,23,50,0,5,&amp;#34;Rain&amp;#34;,230 2011-01-09,&amp;#34;2011-1-9&amp;#34;,7,4,3,1,0,-1,87,74,57,1018,1012,1004,10,10,10,24,16,NA,0,NA,&amp;#34;&amp;#34;,242 weather = read.csv(&amp;#34;weather/temp_data.csv&amp;#34;) weather$Date = as.POSIXct(weather$Date) &amp;gt; weather %&amp;gt;% sample_n(10) %&amp;gt;% select(Date, Min_TemperatureC, Mean_TemperatureC, Max_TemperatureC) Date Min_TemperatureC Mean_TemperatureC Max_TemperatureC 1471 2015-01-10 5 9 14 802 2013-03-12 -2 1 4 1274 2014-06-27 14 18 22 848 2013-04-27 5 8 10 832 2013-04-11 6 8 10 717 2012-12-17 6 7 9 1463 2015-01-02 6 9 13 1090 2013-12-25 4 6 7 560 2012-07-13 15 18 20 1230 2014-05-14 9 14 19 timestampToDate &amp;lt;- function(x) as.</description>
    </item>
    
    <item>
      <title>R: ggplot2 - Each group consist of only one observation. Do you need to adjust the group aesthetic?</title>
      <link>https://markhneedham.com/blog/2015/01/30/r-ggplot2-each-group-consist-of-only-one-observation-do-you-need-to-adjust-the-group-aesthetic/</link>
      <pubDate>Fri, 30 Jan 2015 00:27:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/01/30/r-ggplot2-each-group-consist-of-only-one-observation-do-you-need-to-adjust-the-group-aesthetic/</guid>
      <description>$ cat /tmp/averageTemperatureByMonth.csv &amp;#34;month&amp;#34;,&amp;#34;aveTemperature&amp;#34; &amp;#34;January&amp;#34;,6.02684563758389 &amp;#34;February&amp;#34;,5.89380530973451 &amp;#34;March&amp;#34;,7.54838709677419 &amp;#34;April&amp;#34;,10.875 &amp;#34;May&amp;#34;,13.3064516129032 &amp;#34;June&amp;#34;,15.9666666666667 &amp;#34;July&amp;#34;,18.8387096774194 &amp;#34;August&amp;#34;,18.3709677419355 &amp;#34;September&amp;#34;,16.2583333333333 &amp;#34;October&amp;#34;,13.4596774193548 &amp;#34;November&amp;#34;,9.19166666666667 &amp;#34;December&amp;#34;,7.01612903225806 df = read.csv(&amp;quot;/tmp/averageTemperatureByMonth.csv&amp;quot;) df$month = factor(df$month, month.name) ggplot(aes(x = month, y = aveTemperature), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) geom_path: Each group consist of only one observation. Do you need to adjust the group aesthetic? ggplot(aes(x = as.numeric(month), y = aveTemperature), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) ggplot(aes(x = month, y = aveTemperature, group=1), data = df) + geom_line( ) + ggtitle(&amp;quot;Temperature by month&amp;quot;) </description>
    </item>
    
    <item>
      <title>R: Featuring engineering for a linear model</title>
      <link>https://markhneedham.com/blog/2014/12/28/r-featuring-engineering-for-a-linear-model/</link>
      <pubDate>Sun, 28 Dec 2014 21:55:23 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/28/r-featuring-engineering-for-a-linear-model/</guid>
      <description>&amp;gt; df = read.csv(&amp;#34;/tmp/membersWithGroupCounts.csv&amp;#34;) &amp;gt; df$eventTime = as.POSIXct(df$eventTime) &amp;gt; df %&amp;gt;% sample_n(10) %&amp;gt;% select(event.name, g.name, eventTime, groupMembers, rsvps) event.name g.name eventTime groupMembers rsvps 23 Scoring Models, Apache Drill for querying structured &amp;amp; unstructured data Data Science London 2014-09-18 18:30:00 3466 159 421 London Office Hours London MongoDB User Group 2012-08-22 17:00:00 468 6 304 MongoDB University Study Group London Meet up London MongoDB User Group 2014-07-16 17:00:00 1256 23 43 December Meetup London ElasticSearch User Group 2014-12-10 18:30:00 721 126 222 Intro to Graphs Neo4j - London User Group 2014-09-03 18:30:00 1453 39 207 Intro to Machine Learning with Scikit-Learn Women in Data 2014-11-11 18:15:00 574 41 168 NoSQL panel and LevelDB + Node.</description>
    </item>
    
    <item>
      <title>R: Vectorising all the things</title>
      <link>https://markhneedham.com/blog/2014/12/22/r-vectorising-all-the-things/</link>
      <pubDate>Mon, 22 Dec 2014 11:46:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/22/r-vectorising-all-the-things/</guid>
      <description>library(dplyr) library(lubridate) library(geosphere) options(&amp;#34;scipen&amp;#34;=100, &amp;#34;digits&amp;#34;=4) times = ymd_hms(&amp;#34;2002-01-01 17:00:00&amp;#34;) + c(0:99) * hours(1) data = data.frame(time = times) &amp;gt; data %&amp;gt;% head() time 1 2002-01-01 17:00:00 2 2002-01-01 18:00:00 3 2002-01-01 19:00:00 4 2002-01-01 20:00:00 5 2002-01-01 21:00:00 6 2002-01-01 22:00:00 distanceFromWeekend = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) timeToBefore = dateToLookup - before timeToAfter = after - dateToLookup if(timeToBefore &amp;lt; 0 || timeToAfter &amp;lt; 0) { 0 } else { if(timeToBefore &amp;lt; timeToAfter) { timeToBefore / dhours(1) } else { timeToAfter / dhours(1) } } } &amp;gt; system.</description>
    </item>
    
    <item>
      <title>R: Time to/from the weekend</title>
      <link>https://markhneedham.com/blog/2014/12/13/r-time-tofrom-the-weekend/</link>
      <pubDate>Sat, 13 Dec 2014 20:38:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/13/r-time-tofrom-the-weekend/</guid>
      <description>&amp;gt; library(lubridate) &amp;gt; floor_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) [1] &amp;#34;2014-12-14 UTC&amp;#34; &amp;gt; ceiling_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) [1] &amp;#34;2014-12-21 UTC&amp;#34; &amp;gt; ceiling_date(ymd(&amp;#34;2014-12-18&amp;#34;), &amp;#34;week&amp;#34;) - days(1) [1] &amp;#34;2014-12-20 UTC&amp;#34; findClosestWeekendDay = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) if((dateToLookup - before) &amp;lt; (after - dateToLookup)) { before } else { after } } &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-13 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-13 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-14 18:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-15 18:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-17 11:33:29&amp;#34;)) [1] &amp;#34;2014-12-14 23:59:59 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-17 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-20 UTC&amp;#34; &amp;gt; findClosestWeekendDay(ymd_hms(&amp;#34;2014-12-19 13:33:29&amp;#34;)) [1] &amp;#34;2014-12-20 UTC&amp;#34; distanceFromWeekend = function(dateToLookup) { before = floor_date(dateToLookup, &amp;#34;week&amp;#34;) + hours(23) + minutes(59) + seconds(59) after = ceiling_date(dateToLookup, &amp;#34;week&amp;#34;) - days(1) timeToBefore = dateToLookup - before timeToAfter = after - dateToLookup if(timeToBefore &amp;lt; 0 || timeToAfter &amp;lt; 0) { 0 } else { if(timeToBefore &amp;lt; timeToAfter) { timeToBefore / dhours(1) } else { timeToAfter / dhours(1) } } } &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-13 13:33:29&amp;#34;)) [1] 0 &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-14 18:33:29&amp;#34;)) [1] 0 &amp;gt; distanceFromWeekend(ymd_hms(&amp;#34;2014-12-15 18:33:29&amp;#34;)) [1] 18.</description>
    </item>
    
    <item>
      <title>R: Numeric representation of date time</title>
      <link>https://markhneedham.com/blog/2014/12/13/r-numeric-representation-of-date-time/</link>
      <pubDate>Sat, 13 Dec 2014 19:58:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/13/r-numeric-representation-of-date-time/</guid>
      <description>&amp;gt; december13 = as.POSIXlt(&amp;#34;2014-12-13 17:30:00&amp;#34;) &amp;gt; as.numeric(december13 - trunc(december13, &amp;#34;day&amp;#34;), units=&amp;#34;hours&amp;#34;) [1] 17.5 &amp;gt; (december13 - floor_date(december13, &amp;#34;day&amp;#34;)) Time difference of 17.5 hours &amp;gt; class((december13 - floor_date(december13, &amp;#34;day&amp;#34;))) [1] &amp;#34;difftime&amp;#34; &amp;gt; diff = (december13 - floor_date(december13, &amp;#34;day&amp;#34;)) &amp;gt; diff / dhours(1) [1] 17.5 &amp;gt; diff / ddays(1) [1] 0.7291667 &amp;gt; diff / dminutes(1) [1] 1050 &amp;gt; ymd_hms(&amp;#34;2014-12-13 17:00:00&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd_hm(&amp;#34;2014-12-13 17:00&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd_h(&amp;#34;2014-12-13 17&amp;#34;) [1] &amp;#34;2014-12-13 17:00:00 UTC&amp;#34; &amp;gt; ymd(&amp;#34;2014-12-13&amp;#34;) [1] &amp;#34;2014-12-13 UTC&amp;#34; &amp;gt; with_tz(ymd(&amp;#34;2014-12-13&amp;#34;), &amp;#34;GMT&amp;#34;) [1] &amp;#34;2014-12-13 GMT&amp;#34; </description>
    </item>
    
    <item>
      <title>R: data.table/dplyr/lubridate - Error in wday(date, label = TRUE, abbr = FALSE) :  unused arguments (label = TRUE, abbr = FALSE)</title>
      <link>https://markhneedham.com/blog/2014/12/11/r-data-tabledplyrlubridate-error-in-wdaydate-label-true-abbr-false-unused-arguments-label-true-abbr-false/</link>
      <pubDate>Thu, 11 Dec 2014 19:03:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/11/r-data-tabledplyrlubridate-error-in-wdaydate-label-true-abbr-false-unused-arguments-label-true-abbr-false/</guid>
      <description>&amp;gt; library(lubridate) &amp;gt; library(dplyr) &amp;gt; dates = data.frame(date = seq( dmy(&amp;#34;01-01-2010&amp;#34;), to=dmy(&amp;#34;01-01-2015&amp;#34;), by=&amp;#34;day&amp;#34; )) &amp;gt; dates = dates %&amp;gt;% filter(wday(date, label = TRUE, abbr = FALSE) %in% c(&amp;#34;Saturday&amp;#34;, &amp;#34;Sunday&amp;#34;)) &amp;gt; dates %&amp;gt;% head() date 1: 2010-01-02 2: 2010-01-03 3: 2010-01-09 4: 2010-01-10 5: 2010-01-16 6: 2010-01-17 &amp;gt; library(data.table) &amp;gt; dates = data.table(date = seq( dmy(&amp;#34;01-01-2010&amp;#34;), to=dmy(&amp;#34;01-01-2015&amp;#34;), by=&amp;#34;day&amp;#34; )) &amp;gt; dates = dates %&amp;gt;% filter(wday(date, label = TRUE, abbr = FALSE) %in% c(&amp;#34;Saturday&amp;#34;, &amp;#34;Sunday&amp;#34;)) Error in wday(date, label = TRUE, abbr = FALSE) : unused arguments (label = TRUE, abbr = FALSE) &amp;gt; dates = data.</description>
    </item>
    
    <item>
      <title>R: Cleaning up and plotting Google Trends data</title>
      <link>https://markhneedham.com/blog/2014/12/09/r-cleaning-up-plotting-google-trends-data/</link>
      <pubDate>Tue, 09 Dec 2014 18:14:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/09/r-cleaning-up-plotting-google-trends-data/</guid>
      <description>While I&amp;rsquo;m writing the scripts, I&amp;rsquo;m often jumping around, selectively executing individual lines or code blocks, running commands to inspect the data in the REPL (read-evaluate-print-loop, where each command is executed as soon as you type enter, in the picture above it&amp;rsquo;s the pane to the right), etc.
But I try to make sure that when I finish up, the script is runnable by itself.
&amp;gt; library(dplyr) &amp;gt; googleTrends = read.</description>
    </item>
    
    <item>
      <title>R: dplyr - mutate with strptime (incompatible size/wrong result size)</title>
      <link>https://markhneedham.com/blog/2014/12/08/r-dplyr-mutate-with-strptime-incompatible-sizewrong-result-size/</link>
      <pubDate>Mon, 08 Dec 2014 19:02:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/08/r-dplyr-mutate-with-strptime-incompatible-sizewrong-result-size/</guid>
      <description>data = data.frame(x = c(&amp;#34;2014-01-01&amp;#34;, &amp;#34;2014-02-01&amp;#34;, &amp;#34;foo&amp;#34;)) &amp;gt; data x 1 2014-01-01 2 2014-02-01 3 foo &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;)) Error: wrong result size (11), expected 3 or 1 &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.character()) x y 1 2014-01-01 2014-01-01 2 2014-02-01 2014-02-01 3 foo &amp;lt;NA&amp;gt; &amp;gt; data %&amp;gt;% mutate(y = strptime(x, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.character()) %&amp;gt;% filter(!is.na(y)) x y 1 2014-01-01 2014-01-01 2 2014-02-01 2014-02-01 &amp;gt; data %&amp;gt;% mutate(y = x %&amp;gt;% strptime(&amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% as.</description>
    </item>
    
    <item>
      <title>R: String to Date or NA</title>
      <link>https://markhneedham.com/blog/2014/12/07/r-string-to-date-or-na/</link>
      <pubDate>Sun, 07 Dec 2014 19:29:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/07/r-string-to-date-or-na/</guid>
      <description>&amp;gt; as.Date(&amp;#34;2014-01-01&amp;#34;) [1] &amp;#34;2014-01-01&amp;#34; &amp;gt; as.Date(&amp;#34;foo&amp;#34;) Error in charToDate(x) : character string is not in a standard unambiguous format &amp;gt; strptime(&amp;#34;2014-01-01&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) [1] &amp;#34;2014-01-01 GMT&amp;#34; &amp;gt; strptime(&amp;#34;foo&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) [1] NA &amp;gt; strptime(&amp;#34;2014-01-01&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% is.na() [1] FALSE &amp;gt; strptime(&amp;#34;foo&amp;#34;, &amp;#34;%Y-%m-%d&amp;#34;) %&amp;gt;% is.na() [1] TRUE </description>
    </item>
    
    <item>
      <title>R: Applying a function to every row of a data frame</title>
      <link>https://markhneedham.com/blog/2014/12/04/r-applying-a-function-to-every-row-of-a-data-frame/</link>
      <pubDate>Thu, 04 Dec 2014 06:31:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/04/r-applying-a-function-to-every-row-of-a-data-frame/</guid>
      <description>library(dplyr) # https://gist.github.com/mneedham/7e926a213bf76febf5ed venues = read.csv(&amp;#34;/tmp/venues.csv&amp;#34;) venues %&amp;gt;% head() ## venue lat lon ## 1 Skills Matter 51.52482 -0.099109 ## 2 Skinkers 51.50492 -0.083870 ## 3 Theodore Bullfrog 51.50878 -0.123749 ## 4 The Skills Matter eXchange 51.52452 -0.099231 ## 5 The Guardian 51.53373 -0.122340 ## 6 White Bear Yard 51.52227 -0.109804 options(&amp;#34;scipen&amp;#34;=100, &amp;#34;digits&amp;#34;=4) library(geosphere) centre = c(-0.129581, 51.516578) aVenue = venues %&amp;gt;% slice(1) aVenue ## venue lat lon ## 1 Skills Matter 51.</description>
    </item>
    
    <item>
      <title>R: dplyr - Select &#39;random&#39; rows from a data frame</title>
      <link>https://markhneedham.com/blog/2014/11/26/r-dplyr-select-random-rows-from-a-data-frame/</link>
      <pubDate>Wed, 26 Nov 2014 00:01:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/26/r-dplyr-select-random-rows-from-a-data-frame/</guid>
      <description>data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; randomRows = sample(1:length(data[,1]), 10, replace=T) &amp;gt; randomRows [1] 8723 18772 4964 36134 27467 31890 16313 12841 49214 15621 &amp;gt; data %&amp;gt;% slice(randomRows) letter number 1 Z 4 2 F 1 3 Y 6 4 R 6 5 Y 4 6 V 10 7 R 6 8 D 6 9 J 7 10 E 2 pickRandomRows = function(df, numberOfRows = 10) { df %&amp;gt;% slice(runif(numberOfRows,0, length(df[,1]))) } &amp;gt; data %&amp;gt;% pickRandomRows() letter number 1 W 5 2 Y 3 3 E 6 4 Q 8 5 M 9 6 H 9 7 E 10 8 T 2 9 I 5 10 V 4 &amp;gt; data %&amp;gt;% pickRandomRows(7) letter number 1 V 7 2 N 4 3 W 1 4 N 8 5 G 7 6 V 1 7 N 7 &amp;gt; data %&amp;gt;% sample_n(10) letter number 29771 U 1 48666 T 10 30635 A 1 34865 X 7 20140 A 3 41715 T 10 43786 E 10 18284 A 7 21406 S 8 35542 J 8 </description>
    </item>
    
    <item>
      <title>R: dplyr - &#34;Variables not shown&#34;</title>
      <link>https://markhneedham.com/blog/2014/11/23/r-dplyr-variables-not-shown/</link>
      <pubDate>Sun, 23 Nov 2014 01:02:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/23/r-dplyr-variables-not-shown/</guid>
      <description>words = function(numberOfWords, lengthOfWord) { w = c(1:numberOfWords) for(i in 1:numberOfWords) { w[i] = paste(sample(letters, lengthOfWord, replace=TRUE), collapse = &amp;#34;&amp;#34;) } w } numberOfRows = 100 df = data.frame(a = sample (1:numberOfRows, 10, replace = TRUE), b = sample (1:numberOfRows, 10, replace = TRUE), name = words(numberOfRows, 10)) &amp;gt; df %&amp;gt;% group_by(a,b) %&amp;gt;% summarise(n = n(), words = paste(name, collapse = &amp;#34;,&amp;#34;)) %&amp;gt;% arrange(desc(n)) %&amp;gt;% head(5) Source: local data frame [5 x 4] Groups: a a b n 1 19 90 10 2 24 36 10 3 29 20 10 4 29 80 10 5 62 54 10 Variables not shown: words (chr) &amp;gt; df %&amp;gt;% group_by(a,b) %&amp;gt;% summarise(n = n(), words = paste(name, collapse = &amp;#34;,&amp;#34;)) %&amp;gt;% arrange(desc(n)) %&amp;gt;% head(5) %&amp;gt;% print(width = Inf) &amp;gt; options(dplyr.</description>
    </item>
    
    <item>
      <title>R: ggmap - Overlay shapefile with filled polygon of regions</title>
      <link>https://markhneedham.com/blog/2014/11/17/r-ggmap-overlay-shapefile-with-filled-polygon-of-regions/</link>
      <pubDate>Mon, 17 Nov 2014 00:53:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/17/r-ggmap-overlay-shapefile-with-filled-polygon-of-regions/</guid>
      <description>&amp;gt; library(ggmap) &amp;gt; sfMap = map = get_map(location = &amp;#39;San Francisco&amp;#39;, zoom = 12) &amp;gt; library(rgdal) &amp;gt; library(ggplot2) &amp;gt; sfn = readOGR(&amp;#34;.&amp;#34;,&amp;#34;sfzipcodes&amp;#34;) %&amp;gt;% spTransform(CRS(&amp;#34;+proj=longlat +datum=WGS84&amp;#34;)) &amp;gt; ggplot(data = sfn, aes(x = long, y = lat, group = group)) + geom_path() &amp;gt; class(sfn) [1] &amp;#34;SpatialPolygonsDataFrame&amp;#34; attr(,&amp;#34;package&amp;#34;) [1] &amp;#34;sp&amp;#34; &amp;gt; names(sfn) [1] &amp;#34;OBJECTID&amp;#34; &amp;#34;ZIP_CODE&amp;#34; &amp;#34;ID&amp;#34; &amp;gt; sfn.f = sfn %&amp;gt;% fortify(region = &amp;#39;ZIP_CODE&amp;#39;) SFNeighbourhoods = merge(sfn.f, sfn@data, by.x = &amp;#39;id&amp;#39;, by.y = &amp;#39;ZIP_CODE&amp;#39;) &amp;gt; library(dplyr) &amp;gt; postcodes = SFNeighbourhoods %&amp;gt;% select(id) %&amp;gt;% distinct() &amp;gt; values = data.</description>
    </item>
    
    <item>
      <title>R: dplyr - Sum for group_by multiple columns</title>
      <link>https://markhneedham.com/blog/2014/11/11/r-dplyr-sum-for-group_by-multiple-columns/</link>
      <pubDate>Tue, 11 Nov 2014 00:17:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/11/r-dplyr-sum-for-group_by-multiple-columns/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; data %&amp;gt;% count(letter, number) %&amp;gt;% head(20) Source: local data frame [20 x 3] Groups: letter letter number n 1 A 1 184 2 A 2 192 3 A 3 183 4 A 4 193 5 A 5 214 6 A 6 172 7 A 7 196 8 A 8 198 9 A 9 174 10 A 10 196 11 B 1 212 12 B 2 198 13 B 3 194 14 B 4 181 15 B 5 203 16 B 6 234 17 B 7 221 18 B 8 179 19 B 9 182 20 B 10 170 &amp;gt; data %&amp;gt;% count(letter) Source: local data frame [26 x 2] letter n 1 A 1902 2 B 1974 3 C 1911 4 D 1948 5 E 1888 6 F 1975 7 G 1914 8 H 1886 9 I 1910 10 J 1924 11 K 1974 12 L 1891 13 M 1894 14 N 1946 15 O 1956 16 P 1934 17 Q 1865 18 R 1992 19 S 1946 20 T 1854 21 U 1919 22 V 1913 23 W 1928 24 X 1934 25 Y 1908 26 Z 1914 &amp;gt; data %&amp;gt;% count(letter, number) %&amp;gt;% ungroup %&amp;gt;% group_by(letter) %&amp;gt;% mutate(sum.</description>
    </item>
    
    <item>
      <title>R: dplyr - Maximum value row in each group</title>
      <link>https://markhneedham.com/blog/2014/11/10/r-maximum-value-row-in-each-group/</link>
      <pubDate>Mon, 10 Nov 2014 22:06:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/10/r-maximum-value-row-in-each-group/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; data %&amp;gt;% count(letter, number) Source: local data frame [260 x 3] Groups: letter letter number n 1 A 1 184 2 A 2 192 3 A 3 183 4 A 4 193 5 A 5 214 6 A 6 172 7 A 7 196 8 A 8 198 9 A 9 174 10 A 10 196 .</description>
    </item>
    
    <item>
      <title>R: dplyr - Ordering by count after multiple column group_by</title>
      <link>https://markhneedham.com/blog/2014/11/09/r-dplyr-ordering-by-count-after-multiple-column-group_by/</link>
      <pubDate>Sun, 09 Nov 2014 09:30:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/09/r-dplyr-ordering-by-count-after-multiple-column-group_by/</guid>
      <description>library(dplyr) data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; data %&amp;gt;% count(letter, number, sort = TRUE) Source: local data frame [260 x 3] Groups: letter letter number n 1 A 4 205 2 A 9 201 3 A 3 197 4 A 1 195 5 A 10 191 6 A 2 189 7 A 8 184 8 A 7 183 9 A 5 181 10 A 6 173 .</description>
    </item>
    
    <item>
      <title>R: Refactoring to dplyr</title>
      <link>https://markhneedham.com/blog/2014/11/09/r-refactoring-to-dplyr/</link>
      <pubDate>Sun, 09 Nov 2014 00:11:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/09/r-refactoring-to-dplyr/</guid>
      <description>library(dplyr) data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; data[1:5,] letter number 1 R 7 2 Q 3 3 B 8 4 R 3 5 U 2 &amp;gt; data %&amp;gt;% head(5) letter number 1 R 7 2 Q 3 3 B 8 4 R 3 5 U 2 &amp;gt; data[order(-(data$number)),][1:5,] letter number 14 H 10 17 G 10 63 L 10 66 W 10 73 R 10 &amp;gt; data %&amp;gt;% arrange(desc(number)) %&amp;gt;% head(5) letter number 1 H 10 2 G 10 3 L 10 4 W 10 5 R 10 &amp;gt; length(data[,1]) [1] 50000 &amp;gt; data %&amp;gt;% count() Source: local data frame [1 x 1] n 1 50000 &amp;gt; length(subset(data, number == 1)[, 1]) [1] 4928 &amp;gt; data %&amp;gt;% filter(number == 1) %&amp;gt;% count() Source: local data frame [1 x 1] n 1 4928 &amp;gt; aggregate(data, by= list(data$number), function(x) length(x)) Group.</description>
    </item>
    
    <item>
      <title>R: dplyr - Group by field dynamically (&#39;regroup&#39; is deprecated / no applicable method for &#39;as.lazy&#39; applied to an object of class &#34;list&#34; )</title>
      <link>https://markhneedham.com/blog/2014/11/08/r-dplyr-group-by-field-dynamically-regroup-is-deprecated-no-applicable-method-for-as-lazy-applied-to-an-object-of-class-list/</link>
      <pubDate>Sat, 08 Nov 2014 22:29:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/08/r-dplyr-group-by-field-dynamically-regroup-is-deprecated-no-applicable-method-for-as-lazy-applied-to-an-object-of-class-list/</guid>
      <description>library(dplyr) groupBy = function(df, field) { df %.% regroup(list(field)) %.% summarise(n = n()) } &amp;gt; data = data.frame( letter = sample(LETTERS, 50000, replace = TRUE), number = sample (1:10, 50000, replace = TRUE) ) &amp;gt; groupBy(data, &amp;#39;letter&amp;#39;) %&amp;gt;% head(5) Source: local data frame [5 x 2] letter n 1 A 1951 2 B 1903 3 C 1954 4 D 1923 5 E 1886 Warning messages: 1: %.% is deprecated. Please use %&amp;gt;% 2: %.</description>
    </item>
    
    <item>
      <title>R: Joining multiple data frames</title>
      <link>https://markhneedham.com/blog/2014/11/07/r-joining-multiple-data-frames/</link>
      <pubDate>Fri, 07 Nov 2014 01:29:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/11/07/r-joining-multiple-data-frames/</guid>
      <description>df &amp;lt;- read.csv(&amp;#39;http://www.football-data.co.uk/mmz4281/1314/E0.csv&amp;#39;) # munge data into format compatible with glm function df &amp;lt;- apply(df, 1, function(row){ data.frame(team=c(row[&amp;#39;HomeTeam&amp;#39;], row[&amp;#39;AwayTeam&amp;#39;]), opponent=c(row[&amp;#39;AwayTeam&amp;#39;], row[&amp;#39;HomeTeam&amp;#39;]), goals=c(row[&amp;#39;FTHG&amp;#39;], row[&amp;#39;FTAG&amp;#39;]), home=c(1, 0)) }) df &amp;lt;- do.call(rbind, df) &amp;gt; library(dplyr) &amp;gt; df %&amp;gt;% select(HomeTeam, AwayTeam, FTHG, FTAG) %&amp;gt;% head(1) HomeTeam AwayTeam FTHG FTAG 1 Arsenal Aston Villa 1 3~~~ &amp;lt;p&amp;gt;And we want to get it to look like this:&amp;lt;/p&amp;gt; ~~~r &amp;gt; head(df, 2) team opponent goals home HomeTeam Arsenal Aston Villa 1 1 AwayTeam Aston Villa Arsenal 3 0 df %&amp;gt;% select(team = HomeTeam, opponent = AwayTeam, goals = FTHG) %&amp;gt;% mutate(home = 1) df %&amp;gt;% select(team = AwayTeam, opponent = HomeTeam, goals = FTAG) %&amp;gt;% mutate(home = 0) # load data into data.</description>
    </item>
    
    <item>
      <title>R: Converting a named vector to a data frame</title>
      <link>https://markhneedham.com/blog/2014/10/31/r-converting-a-named-vector-to-a-data-frame/</link>
      <pubDate>Fri, 31 Oct 2014 23:47:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/31/r-converting-a-named-vector-to-a-data-frame/</guid>
      <description>&amp;gt; library(dplyr) &amp;gt; data %&amp;gt;% arrange(desc(times)) %&amp;gt;% head(10) p.name other.name times 1 Amit Nandi Anish Mohammed 51 2 Amit Nandi Enzo Martoglio 49 3 louis zheng 46 4 louis Raja Kolli 45 5 Raja Kolli Enzo Martoglio 43 6 Amit Nandi Raja Kolli 42 7 zheng Anish Mohammed 42 8 Raja Kolli Rohit 41 9 Amit Nandi zheng 40 10 louis Rohit 40 &amp;gt; length(data[,1]) [1] 985664 g = graph.data.frame(data, directed = F) pr = page.</description>
    </item>
    
    <item>
      <title>R: Linear models with the lm function, NA values and Collinearity</title>
      <link>https://markhneedham.com/blog/2014/10/18/r-linear-models-with-the-lm-function-na-values-and-collinearity/</link>
      <pubDate>Sat, 18 Oct 2014 06:35:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/18/r-linear-models-with-the-lm-function-na-values-and-collinearity/</guid>
      <description>library(datasets); data(swiss); require(stats); require(graphics) z &amp;lt;- swiss$Agriculture + swiss$Education fit = lm(Fertility ~ . + z, data = swiss) &amp;gt; alias(fit) Model : Fertility ~ Agriculture + Examination + Education + Catholic + Infant.Mortality + z Complete : (Intercept) Agriculture Examination Education Catholic Infant.Mortality z 0 1 0 1 0 0 &amp;gt; require(dplyr) &amp;gt; summary(lm(Fertility ~ . + z, data = swiss))$coefficients Estimate Std. Error t value Pr(&amp;gt;|t|) (Intercept) 66.9151817 10.</description>
    </item>
    
    <item>
      <title>R: A first attempt at linear regression</title>
      <link>https://markhneedham.com/blog/2014/09/30/r-a-first-attempt-at-linear-regression/</link>
      <pubDate>Tue, 30 Sep 2014 22:20:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/30/r-a-first-attempt-at-linear-regression/</guid>
      <description>library(RNeo4j) officeEventsQuery = &amp;#34;MATCH (g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;})-[:HOSTED_EVENT]-&amp;gt;(event)&amp;lt;-[:TO]-({response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(), (event)-[:HELD_AT]-&amp;gt;(venue) WHERE (event.time + event.utc_offset) &amp;lt; timestamp() AND venue.name IN [\&amp;#34;Neo Technology\&amp;#34;, \&amp;#34;OpenCredo\&amp;#34;] RETURN event.time + event.utc_offset AS eventTime,event.announced_at AS announcedAt, event.name, COUNT(*) AS rsvps&amp;#34; events = subset(cypher(graph, officeEventsQuery), !is.na(announcedAt)) events$eventTime &amp;lt;- timestampToDate(events$eventTime) events$day &amp;lt;- format(events$eventTime, &amp;#34;%A&amp;#34;) events$monthYear &amp;lt;- format(events$eventTime, &amp;#34;%m-%Y&amp;#34;) events$month &amp;lt;- format(events$eventTime, &amp;#34;%m&amp;#34;) events$year &amp;lt;- format(events$eventTime, &amp;#34;%Y&amp;#34;) events$announcedAt&amp;lt;- timestampToDate(events$announcedAt) events$timeDiff = as.numeric(events$eventTime - events$announcedAt, units = &amp;#34;days&amp;#34;) &amp;gt; head(events) eventTime announcedAt event.</description>
    </item>
    
    <item>
      <title>R: Deriving a new data frame column based on containing string</title>
      <link>https://markhneedham.com/blog/2014/09/29/r-deriving-a-new-data-frame-column-based-on-containing-string/</link>
      <pubDate>Mon, 29 Sep 2014 21:37:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/29/r-deriving-a-new-data-frame-column-based-on-containing-string/</guid>
      <description>&amp;gt; x = data.frame(name = c(&amp;#34;Java Hackathon&amp;#34;, &amp;#34;Intro to Graphs&amp;#34;, &amp;#34;Hands on Cypher&amp;#34;)) &amp;gt; x name 1 Java Hackathon 2 Intro to Graphs 3 Hands on Cypher &amp;gt; grepl(&amp;#34;Hackathon|Hands on|Hands On&amp;#34;, x$name) [1] TRUE FALSE TRUE x$practical = grepl(&amp;#34;Hackathon|Hands on|Hands On&amp;#34;, x$name) &amp;gt; x name practical 1 Java Hackathon TRUE 2 Intro to Graphs FALSE 3 Hands on Cypher TRUE </description>
    </item>
    
    <item>
      <title>R: Filtering data frames by column type (&#39;x&#39; must be numeric)</title>
      <link>https://markhneedham.com/blog/2014/09/29/r-filtering-data-frames-by-column-type-x-must-be-numeric/</link>
      <pubDate>Mon, 29 Sep 2014 05:46:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/29/r-filtering-data-frames-by-column-type-x-must-be-numeric/</guid>
      <description>&amp;gt; install.packages(&amp;#34;ISLR&amp;#34;) &amp;gt; library(ISLR) &amp;gt; head(Carseats) Sales CompPrice Income Advertising Population Price ShelveLoc Age Education Urban US 1 9.50 138 73 11 276 120 Bad 42 17 Yes Yes 2 11.22 111 48 16 260 83 Good 65 10 Yes Yes 3 10.06 113 35 10 269 80 Medium 59 12 Yes Yes 4 7.40 117 100 4 466 97 Medium 55 14 Yes Yes 5 4.15 141 64 3 340 128 Bad 38 13 Yes No 6 10.</description>
    </item>
    
    <item>
      <title>R: ggplot - Plotting multiple variables on a line chart</title>
      <link>https://markhneedham.com/blog/2014/09/16/r-ggplot-plotting-multiple-variables-on-a-line-chart/</link>
      <pubDate>Tue, 16 Sep 2014 16:59:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/16/r-ggplot-plotting-multiple-variables-on-a-line-chart/</guid>
      <description>&amp;gt; head(byWeek) Source: local data frame [6 x 2] week n 1 2011-06-02 8 2 2011-06-09 4 3 2011-06-30 2 4 2011-07-14 1 5 2011-07-21 1 6 2011-08-18 1 library(zoo) joinsByWeek = data.frame(actual = byWeek$n, week = byWeek$week, rolling = rollmean(byWeek$n, 4, fill = NA, align=c(&amp;#34;right&amp;#34;))) &amp;gt; head(joinsByWeek, 10) actual week rolling 1 8 2011-06-02 NA 2 4 2011-06-09 NA 3 2 2011-06-30 NA 4 1 2011-07-14 3.75 5 1 2011-07-21 2.</description>
    </item>
    
    <item>
      <title>R: ggplot - Plotting a single variable line chart (geom_line requires the following missing aesthetics: y)</title>
      <link>https://markhneedham.com/blog/2014/09/13/r-ggplot-plotting-a-single-variable-line-chart-geom_line-requires-the-following-missing-aesthetics-y/</link>
      <pubDate>Sat, 13 Sep 2014 11:41:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/13/r-ggplot-plotting-a-single-variable-line-chart-geom_line-requires-the-following-missing-aesthetics-y/</guid>
      <description>&amp;gt; rollmean(byWeek$n, 4) [1] 3.75 2.00 1.25 1.00 1.25 1.25 1.75 1.75 1.75 2.50 2.25 2.75 3.50 2.75 2.75 [16] 2.25 1.50 1.50 2.00 2.00 2.00 2.00 1.25 1.50 2.25 2.50 3.00 3.25 2.75 4.00 [31] 4.25 5.25 7.50 6.50 5.75 5.00 3.50 4.00 5.75 6.25 6.25 6.00 5.25 6.25 7.25 [46] 7.75 7.00 4.75 2.75 1.75 2.00 4.00 5.25 5.50 11.50 11.50 12.75 14.50 12.50 11.75 [61] 11.00 9.25 5.</description>
    </item>
    
    <item>
      <title>R: Calculating rolling or moving averages</title>
      <link>https://markhneedham.com/blog/2014/09/13/r-calculating-rolling-or-moving-averages/</link>
      <pubDate>Sat, 13 Sep 2014 08:15:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/13/r-calculating-rolling-or-moving-averages/</guid>
      <description>mav &amp;lt;- function(x,n=5){filter(x,rep(1/n,n), sides=2)} &amp;gt; mav(c(4,5,4,6), 3) Time Series: Start = 1 End = 4 Frequency = 1 [1] NA 4.333333 5.000000 NA sides	for convolution filters only. If sides = 1 the filter coefficients are for past values only; if sides = 2 they are centred around lag 0. In this case the length of the filter should be odd, but if it is even, more of the filter is forward in time than backward.</description>
    </item>
    
    <item>
      <title>R: ggplot - Cumulative frequency graphs</title>
      <link>https://markhneedham.com/blog/2014/08/31/r-ggplot-cumulative-frequency-graphs/</link>
      <pubDate>Sun, 31 Aug 2014 22:10:42 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/31/r-ggplot-cumulative-frequency-graphs/</guid>
      <description>&amp;gt; head(meetupMembers) joinTimestamp joinDate monthYear quarterYear week dayMonthYear 1 1.376572e+12 2013-08-15 13:13:40 2013-08-01 2013-07-01 2013-08-15 2013-08-15 2 1.379491e+12 2013-09-18 07:55:11 2013-09-01 2013-07-01 2013-09-12 2013-09-18 3 1.349454e+12 2012-10-05 16:28:04 2012-10-01 2012-10-01 2012-10-04 2012-10-05 4 1.383127e+12 2013-10-30 09:59:03 2013-10-01 2013-10-01 2013-10-24 2013-10-30 5 1.372239e+12 2013-06-26 09:27:40 2013-06-01 2013-04-01 2013-06-20 2013-06-26 6 1.330295e+12 2012-02-26 22:27:00 2012-02-01 2012-01-01 2012-02-23 2012-02-26 library(dplyr) &amp;gt; head(meetupMembers %.% group_by(dayMonthYear) %.% summarise(n = n())) Source: local data frame [6 x 2] dayMonthYear n 1 2011-06-05 7 2 2011-06-07 1 3 2011-06-10 1 4 2011-06-12 1 5 2011-06-13 1 6 2011-06-15 1 ggplot(data = meetupMembers %.</description>
    </item>
    
    <item>
      <title>R: dplyr - group_by dynamic or programmatic field / variable (Error: index out of bounds)</title>
      <link>https://markhneedham.com/blog/2014/08/29/r-dplyr-group_by-dynamic-or-programmatic-field-variable-error-index-out-of-bounds/</link>
      <pubDate>Fri, 29 Aug 2014 09:13:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/29/r-dplyr-group_by-dynamic-or-programmatic-field-variable-error-index-out-of-bounds/</guid>
      <description>library(RNeo4j) library(zoo) timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;, tz = &amp;#34;GMT&amp;#34;) query = &amp;#34;MATCH (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinTimestamp&amp;#34; meetupMembers = cypher(graph, query) meetupMembers$joinDate &amp;lt;- timestampToDate(meetupMembers$joinTimestamp) meetupMembers$monthYear &amp;lt;- as.Date(as.yearmon(meetupMembers$joinDate)) meetupMembers$quarterYear &amp;lt;- as.Date(as.yearqtr(meetupMembers$joinDate)) meetupMembers %.% group_by(week) %.% summarise(n = n()) meetupMembers %.% group_by(monthYear) %.% summarise(n = n()) meetupMembers %.% group_by(quarterYear) %.% summarise(n = n()) groupMembersBy = function(field) { meetupMembers %.% group_by(field) %.% summarise(n = n()) } &amp;gt; groupMembersBy(&amp;#34;week&amp;#34;) Show Traceback Rerun with Debug Error: index out of bounds groupMembersBy = function(field) { meetupMembers %.</description>
    </item>
    
    <item>
      <title>R: Grouping by week, month, quarter</title>
      <link>https://markhneedham.com/blog/2014/08/29/r-grouping-by-week-month-quarter/</link>
      <pubDate>Fri, 29 Aug 2014 00:25:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/29/r-grouping-by-week-month-quarter/</guid>
      <description>library(RNeo4j) query = &amp;#34;MATCH (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinTimestamp&amp;#34; meetupMembers = cypher(graph, query) &amp;gt; head(meetupMembers) joinTimestamp 1 1.376572e+12 2 1.379491e+12 3 1.349454e+12 4 1.383127e+12 5 1.372239e+12 6 1.330295e+12 timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;, tz = &amp;#34;GMT&amp;#34;) meetupMembers$joinDate &amp;lt;- timestampToDate(meetupMembers$joinTimestamp) &amp;gt; head(meetupMembers) joinTimestamp joinDate 1 1.376572e+12 2013-08-15 13:13:40 2 1.379491e+12 2013-09-18 07:55:11 3 1.349454e+12 2012-10-05 16:28:04 4 1.383127e+12 2013-10-30 09:59:03 5 1.372239e+12 2013-06-26 09:27:40 6 1.</description>
    </item>
    
    <item>
      <title>R: Rook - Hello world example - &#39;Cannot find a suitable app in file&#39;</title>
      <link>https://markhneedham.com/blog/2014/08/22/r-rook-hello-world-example-cannot-find-a-suitable-app-in-file/</link>
      <pubDate>Fri, 22 Aug 2014 11:05:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/22/r-rook-hello-world-example-cannot-find-a-suitable-app-in-file/</guid>
      <description>library(Rook) s &amp;lt;- Rhttpd$new() s$add(name=&amp;#39;MyApp&amp;#39;,app=&amp;#39;helloworld.R&amp;#39;) s$start() s$browse(&amp;#34;MyApp&amp;#34;) function(env){ list( status=200, headers = list( &amp;#39;Content-Type&amp;#39; = &amp;#39;text/html&amp;#39; ), body = paste(&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;) ) } &amp;gt; s$add(name=&amp;#39;MyApp&amp;#39;,app=&amp;#39;helloworld.R&amp;#39;) Error in .Object$initialize(...) : Cannot find a suitable app in file helloworld.R app &amp;lt;- function(env){ list( status=200, headers = list( &amp;#39;Content-Type&amp;#39; = &amp;#39;text/html&amp;#39; ), body = paste(&amp;#39;&amp;lt;h1&amp;gt;Hello World!&amp;lt;/h1&amp;gt;&amp;#39;) ) } &amp;gt; s Server started on 127.0.0.1:27120 [1] MyApp http://127.0.0.1:27120/custom/MyApp Call browse() with an index number or name to run an application.</description>
    </item>
    
    <item>
      <title>Where does r studio install packages/libraries?</title>
      <link>https://markhneedham.com/blog/2014/08/14/where-does-r-studio-install-packageslibraries/</link>
      <pubDate>Thu, 14 Aug 2014 10:24:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/14/where-does-r-studio-install-packageslibraries/</guid>
      <description>&amp;gt; .libPaths() [1] &amp;#34;/Library/Frameworks/R.framework/Versions/3.1/Resources/library&amp;#34; &amp;gt; list.files(&amp;#34;/Library/Frameworks/R.framework/Versions/3.1/Resources/library&amp;#34;) [1] &amp;#34;alr3&amp;#34; &amp;#34;assertthat&amp;#34; &amp;#34;base&amp;#34; &amp;#34;bitops&amp;#34; &amp;#34;boot&amp;#34; &amp;#34;brew&amp;#34; [7] &amp;#34;car&amp;#34; &amp;#34;class&amp;#34; &amp;#34;cluster&amp;#34; &amp;#34;codetools&amp;#34; &amp;#34;colorspace&amp;#34; &amp;#34;compiler&amp;#34; [13] &amp;#34;data.table&amp;#34; &amp;#34;datasets&amp;#34; &amp;#34;devtools&amp;#34; &amp;#34;dichromat&amp;#34; &amp;#34;digest&amp;#34; &amp;#34;dplyr&amp;#34; [19] &amp;#34;evaluate&amp;#34; &amp;#34;foreign&amp;#34; &amp;#34;formatR&amp;#34; &amp;#34;Formula&amp;#34; &amp;#34;gclus&amp;#34; &amp;#34;ggplot2&amp;#34; [25] &amp;#34;graphics&amp;#34; &amp;#34;grDevices&amp;#34; &amp;#34;grid&amp;#34; &amp;#34;gridExtra&amp;#34; &amp;#34;gtable&amp;#34; &amp;#34;hflights&amp;#34; [31] &amp;#34;highr&amp;#34; &amp;#34;Hmisc&amp;#34; &amp;#34;httr&amp;#34; &amp;#34;KernSmooth&amp;#34; &amp;#34;knitr&amp;#34; &amp;#34;labeling&amp;#34; [37] &amp;#34;Lahman&amp;#34; &amp;#34;lattice&amp;#34; &amp;#34;latticeExtra&amp;#34; &amp;#34;magrittr&amp;#34; &amp;#34;manipulate&amp;#34; &amp;#34;markdown&amp;#34; [43] &amp;#34;MASS&amp;#34; &amp;#34;Matrix&amp;#34; &amp;#34;memoise&amp;#34; &amp;#34;methods&amp;#34; &amp;#34;mgcv&amp;#34; &amp;#34;mime&amp;#34; [49] &amp;#34;munsell&amp;#34; &amp;#34;nlme&amp;#34; &amp;#34;nnet&amp;#34; &amp;#34;openintro&amp;#34; &amp;#34;parallel&amp;#34; &amp;#34;plotrix&amp;#34; [55] &amp;#34;plyr&amp;#34; &amp;#34;proto&amp;#34; &amp;#34;RColorBrewer&amp;#34; &amp;#34;Rcpp&amp;#34; &amp;#34;RCurl&amp;#34; &amp;#34;reshape2&amp;#34; [61] &amp;#34;RJSONIO&amp;#34; &amp;#34;RNeo4j&amp;#34; &amp;#34;Rook&amp;#34; &amp;#34;rpart&amp;#34; &amp;#34;rstudio&amp;#34; &amp;#34;scales&amp;#34; [67] &amp;#34;seriation&amp;#34; &amp;#34;spatial&amp;#34; &amp;#34;splines&amp;#34; &amp;#34;stats&amp;#34; &amp;#34;stats4&amp;#34; &amp;#34;stringr&amp;#34; [73] &amp;#34;survival&amp;#34; &amp;#34;swirl&amp;#34; &amp;#34;tcltk&amp;#34; &amp;#34;testthat&amp;#34; &amp;#34;tools&amp;#34; &amp;#34;translations&amp;#34; [79] &amp;#34;TSP&amp;#34; &amp;#34;utils&amp;#34; &amp;#34;whisker&amp;#34; &amp;#34;xts&amp;#34; &amp;#34;yaml&amp;#34; &amp;#34;zoo&amp;#34; $ cat /Library/Frameworks/R.</description>
    </item>
    
    <item>
      <title>R: Grouping by two variables</title>
      <link>https://markhneedham.com/blog/2014/08/11/r-grouping-by-two-variables/</link>
      <pubDate>Mon, 11 Aug 2014 16:47:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/11/r-grouping-by-two-variables/</guid>
      <description>&amp;gt; head(eventsOf2014, 20) eventTime event.name rsvps datetime day monthYear 16 1.393351e+12 Intro to Graphs 38 2014-02-25 18:00:00 Tuesday 02-2014 17 1.403635e+12 Intro to Graphs 44 2014-06-24 18:30:00 Tuesday 06-2014 19 1.404844e+12 Intro to Graphs 38 2014-07-08 18:30:00 Tuesday 07-2014 28 1.398796e+12 Intro to Graphs 45 2014-04-29 18:30:00 Tuesday 04-2014 31 1.395772e+12 Intro to Graphs 56 2014-03-25 18:30:00 Tuesday 03-2014 41 1.406054e+12 Intro to Graphs 12 2014-07-22 18:30:00 Tuesday 07-2014 49 1.</description>
    </item>
    
    <item>
      <title>R: ggplot  - Plotting back to back charts using facet_wrap</title>
      <link>https://markhneedham.com/blog/2014/07/25/r-ggplot-plotting-back-to-back-charts-using-facet_wrap/</link>
      <pubDate>Fri, 25 Jul 2014 21:57:24 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/25/r-ggplot-plotting-back-to-back-charts-using-facet_wrap/</guid>
      <description>timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;quot;1970-01-01&amp;quot;, tz = &amp;quot;GMT&amp;quot;) query = &amp;quot;MATCH (e:Event)&amp;lt;-[:TO]-(response {response: &#39;yes&#39;}) WITH e, COLLECT(response) AS yeses MATCH (e)&amp;lt;-[:TO]-(response {response: &#39;no&#39;})&amp;lt;-[:NEXT]-() WITH e, COLLECT(response) + yeses AS responses UNWIND responses AS response RETURN response.time AS time, e.time + e.utc_offset AS eventTime, response.response AS response&amp;quot; allRSVPs = cypher(graph, query) allRSVPs$time = timestampToDate(allRSVPs$time) allRSVPs$eventTime = timestampToDate(allRSVPs$eventTime) allRSVPs$difference = as.numeric(allRSVPs$eventTime - allRSVPs$time, units=&amp;quot;days&amp;quot;) &amp;gt; allRSVPs[1:10,] time eventTime response difference 1 2014-06-13 21:49:20 2014-07-22 18:30:00 no 38.</description>
    </item>
    
    <item>
      <title>R: ggplot - Plotting back to back bar charts</title>
      <link>https://markhneedham.com/blog/2014/07/20/r-ggplot-plotting-back-to-back-bar-charts/</link>
      <pubDate>Sun, 20 Jul 2014 16:50:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/20/r-ggplot-plotting-back-to-back-bar-charts/</guid>
      <description>query = &amp;#34;MATCH (e:Event)&amp;lt;-[:TO]-(response {response: &amp;#39;yes&amp;#39;}) RETURN response.time AS time, e.time + e.utc_offset AS eventTime&amp;#34; allYesRSVPs = cypher(graph, query) allYesRSVPs$time = timestampToDate(allYesRSVPs$time) allYesRSVPs$eventTime = timestampToDate(allYesRSVPs$eventTime) allYesRSVPs$difference = as.numeric(allYesRSVPs$eventTime - allYesRSVPs$time, units=&amp;#34;days&amp;#34;) ggplot(allYesRSVPs, aes(x=difference)) + geom_histogram(binwidth=1, fill=&amp;#34;green&amp;#34;) query = &amp;#34;MATCH (e:Event)&amp;lt;-[:TO]-(response {response: &amp;#39;no&amp;#39;})&amp;lt;-[:NEXT]-() RETURN response.time AS time, e.time + e.utc_offset AS eventTime&amp;#34; allNoRSVPs = cypher(graph, query) allNoRSVPs$time = timestampToDate(allNoRSVPs$time) allNoRSVPs$eventTime = timestampToDate(allNoRSVPs$eventTime) allNoRSVPs$difference = as.numeric(allNoRSVPs$eventTime - allNoRSVPs$time, units=&amp;#34;days&amp;#34;) ggplot(allNoRSVPs, aes(x=difference)) + geom_histogram(binwidth=1, fill=&amp;#34;red&amp;#34;) yes = ggplot(allYesRSVPs, aes(x=difference)) + geom_histogram(binwidth=1, fill=&amp;#34;green&amp;#34;) no = ggplot(allNoRSVPs, aes(x=difference)) + geom_histogram(binwidth=1, fill=&amp;#34;red&amp;#34;) + scale_y_reverse() library(gridExtra) grid.</description>
    </item>
    
    <item>
      <title>R: ggplot - Don&#39;t know how to automatically pick scale for object of type difftime - Discrete value supplied to continuous scale</title>
      <link>https://markhneedham.com/blog/2014/07/20/r-ggplot-dont-know-how-to-automatically-pick-scale-for-object-of-type-difftime-discrete-value-supplied-to-continuous-scale/</link>
      <pubDate>Sun, 20 Jul 2014 00:21:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/20/r-ggplot-dont-know-how-to-automatically-pick-scale-for-object-of-type-difftime-discrete-value-supplied-to-continuous-scale/</guid>
      <description>library(Rneo4j) query = &amp;#34;MATCH (e:Event)&amp;lt;-[:TO]-(response {response: &amp;#39;yes&amp;#39;}) RETURN response.time AS time, e.time + e.utc_offset AS eventTime&amp;#34; allYesRSVPs = cypher(graph, query) allYesRSVPs$time = timestampToDate(allYesRSVPs$time) allYesRSVPs$eventTime = timestampToDate(allYesRSVPs$eventTime) &amp;gt; allYesRSVPs[1:10,] time eventTime 1 2011-06-05 12:12:27 2011-06-29 18:30:00 2 2011-06-05 14:49:04 2011-06-29 18:30:00 3 2011-06-10 11:22:47 2011-06-29 18:30:00 4 2011-06-07 15:27:07 2011-06-29 18:30:00 5 2011-06-06 20:21:45 2011-06-29 18:30:00 6 2011-07-04 19:49:04 2011-07-27 19:00:00 7 2011-07-05 16:40:10 2011-07-27 19:00:00 8 2011-08-19 07:41:10 2011-08-31 18:30:00 9 2011-08-24 12:47:40 2011-08-31 18:30:00 10 2011-08-18 09:56:53 2011-08-31 18:30:00 allYesRSVPs$difference = allYesRSVPs$eventTime - allYesRSVPs$time &amp;gt; allYesRSVPs[1:10,] time eventTime difference 1 2011-06-05 12:12:27 2011-06-29 18:30:00 34937.</description>
    </item>
    
    <item>
      <title>R: Apply a custom function across multiple lists</title>
      <link>https://markhneedham.com/blog/2014/07/16/r-apply-a-custom-function-across-multiple-lists/</link>
      <pubDate>Wed, 16 Jul 2014 05:04:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/16/r-apply-a-custom-function-across-multiple-lists/</guid>
      <description>&amp;gt; c(10,9,8,7,6,5,4,3,2,1) - c(5,4,3,4,3,2,2,1,2,1) [1] 5 5 5 3 3 3 2 2 0 0 &amp;gt; mapply(function(x, y) { if((x-y) &amp;gt;= 5) { &amp;#34;5 or more&amp;#34; } else if((x-y) &amp;gt;= 3) { &amp;#34;3 to 5&amp;#34; } else { &amp;#34;less than 5&amp;#34; } }, c(10,9,8,7,6,5,4,3,2,1),c(5,4,3,4,3,2,2,1,2,1)) [1] &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;less than 5&amp;#34; [8] &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; summarisedDifference &amp;lt;- function(one, two) { mapply(function(x, y) { if((x-y) &amp;gt;= 5) { &amp;#34;5 or more&amp;#34; } else if((x-y) &amp;gt;= 3) { &amp;#34;3 to 5&amp;#34; } else { &amp;#34;less than 5&amp;#34; } }, one, two) } &amp;gt; summarisedDifference(c(10,9,8,7,6,5,4,3,2,1),c(5,4,3,4,3,2,2,1,2,1)) [1] &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;less than 5&amp;#34; [8] &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; &amp;gt; summarisedDifference(c(10,9,8,7,6,5,4,3,2,1), 1) [1] &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;5 or more&amp;#34; &amp;#34;3 to 5&amp;#34; &amp;#34;3 to 5&amp;#34; [8] &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; &amp;#34;less than 5&amp;#34; &amp;gt; library(plyr) &amp;gt; df = data.</description>
    </item>
    
    <item>
      <title>R/plyr: ddply - Error in vector(type, length) : vector: cannot make a vector of mode &#39;closure&#39;.</title>
      <link>https://markhneedham.com/blog/2014/07/07/rplyr-ddply-error-in-vectortype-length-vector-cannot-make-a-vector-of-mode-closure/</link>
      <pubDate>Mon, 07 Jul 2014 06:07:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/07/rplyr-ddply-error-in-vectortype-length-vector-cannot-make-a-vector-of-mode-closure/</guid>
      <description>n = c(2, 3, 5) s = c(&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;) b = c(TRUE, FALSE, TRUE) df = data.frame(n, s, b) ddply(df, &amp;#34;b&amp;#34;, function(x) { countr &amp;lt;- length(x$n) data.frame(count = count) }) Error in vector(type, length) : vector: cannot make a vector of mode &amp;#39;closure&amp;#39;. &amp;gt; count = 10 &amp;gt; ddply(df, &amp;#34;b&amp;#34;, function(x) { + countr &amp;lt;- length(x$n) + data.frame(count = count) + }) b count 1 FALSE 4 2 TRUE 4 &amp;gt; ddply(df, &amp;#34;b&amp;#34;, function(x) { + count &amp;lt;- length(x$n) + data.</description>
    </item>
    
    <item>
      <title>R/plyr: ddply - Renaming the grouping/generated column when grouping by date</title>
      <link>https://markhneedham.com/blog/2014/07/02/rplyr-ddply-renaming-the-groupinggenerate-column-when-grouping-by-date/</link>
      <pubDate>Wed, 02 Jul 2014 06:30:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/02/rplyr-ddply-renaming-the-groupinggenerate-column-when-grouping-by-date/</guid>
      <description>library(Rneo4j) timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;) query = &amp;#34;MATCH (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinDate&amp;#34; meetupMembers = cypher(graph, query) meetupMembers$joined &amp;lt;- timestampToDate(meetupMembers$joinDate) dd = aggregate(meetupMembers$joined, by=list(format(meetupMembers$joined, &amp;#34;%A&amp;#34;)), function(x) length(x)) colnames(dd) = c(&amp;#34;dayOfWeek&amp;#34;, &amp;#34;count&amp;#34;) &amp;gt; dd dayOfWeek count 1 Friday 135 2 Monday 287 3 Saturday 80 4 Sunday 102 5 Thursday 187 6 Tuesday 286 7 Wednesday 211 &amp;gt; meetupMembers[1:10,] joinDate joined 1 1.</description>
    </item>
    
    <item>
      <title>R: Aggregate by different functions and join results into one data frame</title>
      <link>https://markhneedham.com/blog/2014/06/30/r-aggregate-by-different-functions-and-join-results-into-one-data-frame/</link>
      <pubDate>Mon, 30 Jun 2014 22:47:44 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/30/r-aggregate-by-different-functions-and-join-results-into-one-data-frame/</guid>
      <description>library(Rneo4j) timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;) query = &amp;#34;MATCH (g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;})-[:HOSTED_EVENT]-&amp;gt;(event)&amp;lt;-[:TO]-({response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-() WHERE (event.time + event.utc_offset) &amp;lt; timestamp() RETURN event.time + event.utc_offset AS eventTime, COUNT(*) AS rsvps&amp;#34; events = cypher(graph, query) events$datetime &amp;lt;- timestampToDate(events$eventTime) eventTime rsvps datetime 1 1.314815e+12 3 2011-08-31 19:30:00 2 1.337798e+12 13 2012-05-23 19:30:00 3 1.383070e+12 29 2013-10-29 18:00:00 4 1.362474e+12 5 2013-03-05 09:00:00 5 1.369852e+12 66 2013-05-29 19:30:00 6 1.</description>
    </item>
    
    <item>
      <title>R: Order by data frame column and take top 10 rows</title>
      <link>https://markhneedham.com/blog/2014/06/30/r-order-by-data-frame-column-and-take-top-10-rows/</link>
      <pubDate>Mon, 30 Jun 2014 21:44:14 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/30/r-order-by-data-frame-column-and-take-top-10-rows/</guid>
      <description>library(Rneo4j) query = &amp;#34;MATCH (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinDate&amp;#34; timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;) meetupMembers = cypher(graph, query) meetupMembers$joined &amp;lt;- timestampToDate(meetupMembers$joinDate) groupBy = function(dates, format) { dd = aggregate(dates, by= list(format(dates, format)), function(x) length(x)) colnames(dd) = c(&amp;#34;key&amp;#34;, &amp;#34;count&amp;#34;) dd } byDayTime = groupBy(meetupMembers$joined, &amp;#34;%A %H:00&amp;#34;) &amp;gt; byDayTime[12:25,] key count 12 Friday 14:00 12 13 Friday 15:00 8 14 Friday 16:00 11 15 Friday 17:00 10 16 Friday 18:00 3 17 Friday 19:00 1 18 Friday 20:00 3 19 Friday 21:00 4 20 Friday 22:00 7 21 Friday 23:00 2 22 Monday 00:00 3 23 Monday 01:00 1 24 Monday 03:00 1 25 Monday 05:00 3 &amp;gt; byDayTime[order(byDayTime$count),][1:10,] key count 2 Friday 03:00 1 3 Friday 04:00 1 4 Friday 05:00 1 5 Friday 07:00 1 17 Friday 19:00 1 23 Monday 01:00 1 24 Monday 03:00 1 46 Saturday 03:00 1 66 Sunday 06:00 1 67 Sunday 07:00 1 &amp;gt; order(byDayTime$count) [1] 2 3 4 5 17 23 24 46 66 67 109 128 129 1 21 44 47 48 81 86 87 88 108 130 16 18 22 25 45 53 64 71 75 107 19 26 49 51 55 56 58 59 61 [44] 65 68 77 79 85 106 110 143 50 52 54 82 84 101 127 146 27 57 60 62 63 69 70 73 99 103 126 145 6 20 76 83 89 105 122 131 144 7 13 40 43 72 80 [87] 102 39 78 100 132 147 15 94 121 123 142 14 42 74 104 137 140 12 38 92 93 111 124 8 9 11 90 96 125 139 10 32 34 36 95 97 98 28 135 136 33 35 112 [130] 113 116 134 91 141 41 115 120 133 37 119 138 31 117 118 30 114 29 key count 2 Friday 03:00 1 3 Friday 04:00 1 4 Friday 05:00 1 5 Friday 07:00 1 &amp;gt; byDayTime[order(-byDayTime$count),][1:10,] key count 29 Monday 09:00 34 30 Monday 10:00 28 114 Tuesday 11:00 28 31 Monday 11:00 27 117 Tuesday 14:00 27 118 Tuesday 15:00 27 138 Wednesday 14:00 23 119 Tuesday 16:00 22 37 Monday 17:00 21 115 Tuesday 12:00 20 </description>
    </item>
    
    <item>
      <title>Neo4j/R: Grouping meetup members by join timestamp</title>
      <link>https://markhneedham.com/blog/2014/06/30/neo4jr-grouping-meetup-members-by-join-timestamp/</link>
      <pubDate>Mon, 30 Jun 2014 00:06:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/30/neo4jr-grouping-meetup-members-by-join-timestamp/</guid>
      <description>&amp;gt; library(Rneo4j) &amp;gt; query = &amp;#34;match (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinDate&amp;#34; &amp;gt; meetupMembers = cypher(graph, query) &amp;gt; meetupMembers[1:5,] [1] 1.389107e+12 1.376572e+12 1.379491e+12 1.349454e+12 1.383127e+12 &amp;gt; timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;) &amp;gt; meetupMembers$joined &amp;lt;- timestampToDate(meetupMembers$joinDate) &amp;gt; meetupMembers[1:5,] joinDate joined 1 1.389107e+12 2014-01-07 15:08:40 2 1.376572e+12 2013-08-15 14:13:40 3 1.379491e+12 2013-09-18 08:55:11 4 1.349454e+12 2012-10-05 17:28:04 5 1.383127e+12 2013-10-30 09:59:03 &amp;gt; dd = aggregate(meetupMembers$joined, by=list(format(meetupMembers$joined, &amp;#34;%m-%Y&amp;#34;)), function(x) length(x)) &amp;gt; colnames(dd) = c(&amp;#34;month&amp;#34;, &amp;#34;count&amp;#34;) &amp;gt; dd month count 1 01-2012 4 2 01-2013 52 3 01-2014 88 4 02-2012 7 5 02-2013 52 6 02-2014 91 7 03-2012 12 8 03-2013 23 9 03-2014 93 10 04-2012 3 11 04-2013 34 12 04-2014 119 13 05-2012 9 14 05-2013 69 15 05-2014 102 16 06-2011 14 17 06-2012 5 18 06-2013 39 19 06-2014 114 20 07-2011 4 21 07-2012 16 22 07-2013 20 23 08-2011 2 24 08-2012 34 25 08-2013 50 26 09-2012 14 27 09-2013 52 28 10-2011 2 29 10-2012 29 30 10-2013 42 31 11-2011 2 32 11-2012 31 33 11-2013 34 34 12-2012 7 35 12-2013 19 groupBy = function(dates, format) { dd = aggregate(dates, by= list(format(dates, format)), function(x) length(x)) colnames(dd) = c(&amp;#34;key&amp;#34;, &amp;#34;count&amp;#34;) dd } &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%Y&amp;#34;) key count 1 2011 24 2 2012 171 3 2013 486 4 2014 607 &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%A&amp;#34;) key count 1 Friday 135 2 Monday 287 3 Saturday 80 4 Sunday 102 5 Thursday 187 6 Tuesday 286 7 Wednesday 211 &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%m&amp;#34;) key count 1 01 144 2 02 150 3 03 128 4 04 156 5 05 180 6 06 172 7 07 40 8 08 86 9 09 66 10 10 73 11 11 67 12 12 26 &amp;gt; groupBy(meetupMembers$joined[format(meetupMembers$joined, &amp;#34;%Y&amp;#34;) !</description>
    </item>
    
    <item>
      <title>Neo4j/R: Analysing London NoSQL meetup membership</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4jr-analysing-london-nosql-meetup-membership/</link>
      <pubDate>Sat, 31 May 2014 21:32:24 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4jr-analysing-london-nosql-meetup-membership/</guid>
      <description>MATCH (group1:Group), (group2:Group) OPTIONAL MATCH (group1)&amp;lt;-[:MEMBER_OF]-()-[:MEMBER_OF]-&amp;gt;(group2) WITH group1, group2, COUNT(*) as commonMembers MATCH (group1)&amp;lt;-[:MEMBER_OF]-(group1Member) WITH group1, group2, commonMembers, COLLECT(id(group1Member)) AS group1Members MATCH (group2)&amp;lt;-[:MEMBER_OF]-(group2Member) WITH group1, group2, commonMembers, group1Members, COLLECT(id(group2Member)) AS group2Members WITH group1, group2, commonMembers, group1Members, group2Members UNWIND(group1Members + group2Members) AS combinedMember WITH DISTINCT group1, group2, commonMembers, combinedMember WITH group1, group2, commonMembers, COUNT(combinedMember) AS combinedMembers RETURN group1.name, group2.name, toInt(round(100.0 * commonMembers / combinedMembers)) AS percentage	ORDER BY group1.name, group1.name install.packages(&amp;#34;devtools&amp;#34;) devtools::install_github(&amp;#34;nicolewhite/Rneo4j&amp;#34;) install.</description>
    </item>
    
    <item>
      <title>R: Building up a data frame row by row</title>
      <link>https://markhneedham.com/blog/2013/02/10/r-building-up-a-data-frame-row-by-row/</link>
      <pubDate>Sun, 10 Feb 2013 13:29:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/10/r-building-up-a-data-frame-row-by-row/</guid>
      <description>&amp;gt; head(titanic) survived pclass name sex age sibsp parch ticket fare cabin embarked 1 0 3 Braund, Mr. Owen Harris male 22 1 0 A/5 21171 7.2500 S 2 1 1 Cumings, Mrs. John Bradley (Florence Briggs Thayer) female 38 1 0 PC 17599 71.2833 C85 C 3 1 3 Heikkinen, Miss. Laina female 26 0 0 STON/O2. 3101282 7.9250 S 4 1 1 Futrelle, Mrs. Jacques Heath (Lily May Peel) female 35 1 0 113803 53.</description>
    </item>
    
    <item>
      <title>R: Modelling a conversion rate with a binomial distribution</title>
      <link>https://markhneedham.com/blog/2013/02/07/r-modelling-a-conversion-rate-with-a-binomial-distribution/</link>
      <pubDate>Thu, 07 Feb 2013 01:26:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/07/r-modelling-a-conversion-rate-with-a-binomial-distribution/</guid>
      <description>generateConversionRates &amp;lt;- function(sampleSize) { sample_a &amp;lt;- rbinom(seq(0, sampleSize), 1, 0.12) conversion_a &amp;lt;- length(sample_a[sample_a == 1]) / sampleSize sample_b &amp;lt;- rbinom(seq(0, sampleSize), 1, 0.12) conversion_b &amp;lt;- length(sample_b[sample_b == 1]) / sampleSize c(conversion_a, conversion_b) } &amp;gt; generateConversionRates(10000) [1] 0.1230 0.1207 generateSample &amp;lt;- function(sampleSize) { lapply(seq(1, 1000), function(x) generateConversionRates(sampleSize)) } &amp;gt; getSample(10000) [[998]] [1] 0.1179 0.1216 [[999]] [1] 0.1246 0.1211 [[1000]] [1] 0.1248 0.1234 </description>
    </item>
    
    <item>
      <title>R: Mapping over a list of lists</title>
      <link>https://markhneedham.com/blog/2013/02/03/r-mapping-over-a-list-of-lists/</link>
      <pubDate>Sun, 03 Feb 2013 10:40:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/03/r-mapping-over-a-list-of-lists/</guid>
      <description>&amp;gt; file &amp;lt;- &amp;#34;https://dl.dropbox.com/u/7710864/data/csv_hid/ss06hid.csv&amp;#34; &amp;gt; download.file(file, destfile=&amp;#34;americancommunity.csv&amp;#34;, method=&amp;#34;curl&amp;#34;) &amp;gt; acomm &amp;lt;- read.csv(&amp;#34;americancommunity.csv&amp;#34;) &amp;gt; one &amp;lt;- acomm[acomm$RMS == 4 &amp;amp; !is.na(acomm$RMS) &amp;amp; acomm$BDS == 3 &amp;amp; !is.na(acomm$BDS), c(&amp;#34;RMS&amp;#34;)] &amp;gt; one [1] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 ... [137] 4 4 4 4 4 4 4 4 4 4 4 4 &amp;gt; two &amp;lt;- acomm[acomm$RMS == 5 &amp;amp; !</description>
    </item>
    
    <item>
      <title>R: Ordering rows in a data frame by multiple columns</title>
      <link>https://markhneedham.com/blog/2013/01/23/r-ordering-rows-in-a-data-frame-by-multiple-columns/</link>
      <pubDate>Wed, 23 Jan 2013 23:09:28 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/23/r-ordering-rows-in-a-data-frame-by-multiple-columns/</guid>
      <description>&amp;gt; names &amp;lt;- c(&amp;#34;paul&amp;#34;, &amp;#34;mark&amp;#34;, &amp;#34;dave&amp;#34;, &amp;#34;will&amp;#34;, &amp;#34;john&amp;#34;) &amp;gt; values &amp;lt;- c(1,4,1,2,1) &amp;gt; smallData &amp;lt;- data.frame(name = names, value = values) &amp;gt; smallData name value 1 paul 1 2 mark 4 3 dave 1 4 will 2 5 john 1 name value 3 dave 1 5 john 1 1 paul 1 4 will 2 2 mark 4 &amp;gt; order(c(1,4,1,2,1)) [1] 1 3 5 4 2 &amp;gt; smallData[c(5,4,3,2,1),] name value 5 john 1 4 will 2 3 dave 1 2 mark 4 1 paul 1 &amp;gt; smallData[order(smallData[,2]),] name value 1 paul 1 3 dave 1 5 john 1 4 will 2 2 mark 4 &amp;gt; smallData[order(smallData[,2], smallData[,1]),] name value 3 dave 1 5 john 1 1 paul 1 4 will 2 2 mark 4 &amp;gt; smallData[order(smallData$value, smallData$name),] name value 3 dave 1 5 john 1 1 paul 1 4 will 2 2 mark 4 &amp;gt; smallData[with(smallData, order(value, name)),] name value 3 dave 1 5 john 1 1 paul 1 4 will 2 2 mark 4 </description>
    </item>
    
    <item>
      <title>R: Filter a data frame based on values in two columns</title>
      <link>https://markhneedham.com/blog/2013/01/23/r-filter-a-data-frame-based-on-values-in-two-columns/</link>
      <pubDate>Wed, 23 Jan 2013 22:34:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/23/r-filter-a-data-frame-based-on-values-in-two-columns/</guid>
      <description>&amp;gt; data &amp;lt;- read.csv(&amp;#34;specdata/002.csv&amp;#34;) &amp;gt; # we&amp;#39;ll just use a few rows to make it easier to see what&amp;#39;s going on &amp;gt; data[2494:2500,] Date sulfate nitrate ID 2494 2007-10-30 3.25 0.902 2 2495 2007-10-31 NA NA 2 2496 2007-11-01 NA NA 2 2497 2007-11-02 6.56 1.270 2 2498 2007-11-03 NA NA 2 2499 2007-11-04 NA NA 2 2500 2007-11-05 6.10 0.772 2 &amp;gt; smallData &amp;lt;- data[2494:2500,] &amp;gt; Filter(function(x) !is.na(x$sulfate), smallData) Error in x$sulfate : $ operator is invalid for atomic vectors &amp;gt; smallData[!</description>
    </item>
    
    <item>
      <title>R: Mapping a function over a collection of values</title>
      <link>https://markhneedham.com/blog/2012/07/23/r-mapping-a-function-over-a-collection-of-values/</link>
      <pubDate>Mon, 23 Jul 2012 23:25:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/23/r-mapping-a-function-over-a-collection-of-values/</guid>
      <description>I spent a bit of Sunday playing around with R and one thing I wanted to do was map a function over a collection of values and transform each value slightly.
I loaded my data set using the &amp;lsquo;Import Dataset&amp;rsquo; option in R Studio(suggested to me by Rob) which gets converted to the following function call:
&amp;gt; data &amp;lt;- read.csv(&amp;#34;~/data.csv&amp;#34;, header=T, encoding=&amp;#34;ISO-8859&amp;#34;) &amp;gt; data Column1 InterestingColumn 1 Mark 12.50 2 Dave 100.</description>
    </item>
    
  </channel>
</rss>