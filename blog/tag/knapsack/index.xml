<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>knapsack on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/knapsack/</link>
    <description>Recent content in knapsack on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jan 2013 00:12:25 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/knapsack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Knapsack Problem in Haskell</title>
      <link>https://markhneedham.com/blog/2013/01/09/knapsack-problem-in-haskell/</link>
      <pubDate>Wed, 09 Jan 2013 00:12:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/09/knapsack-problem-in-haskell/</guid>
      <description>ref :: a -&amp;gt; IORef a ref x = unsafePerformIO (newIORef x) knapsackCached1 :: [[Int]] -&amp;gt; Int -&amp;gt; Int -&amp;gt; IORef (Map.Map (Int, Int) Int) -&amp;gt; Int knapsackCached1 rows knapsackWeight index cacheContainer = unsafePerformIO $ do cache &amp;lt;- readIORef cacheContainer if index == 0 || knapsackWeight == 0 then do return 0 else let (value:weight:_) = rows !! index best = knapsackCached1 rows knapsackWeight prevIndex cacheContainer in if weight &amp;gt; knapsackWeight &amp;amp;&amp;amp; lookupPreviousIn cache == Nothing then do let updatedCache = Map.</description>
    </item>
    
    <item>
      <title>Knapsack Problem: Python vs Ruby</title>
      <link>https://markhneedham.com/blog/2013/01/07/knapsack-problem-python-vs-ruby/</link>
      <pubDate>Mon, 07 Jan 2013 00:47:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/01/07/knapsack-problem-python-vs-ruby/</guid>
      <description>number_of_items,knapsack_size = # calculated from file cache = [].tap { |m| (number_of_items+1).times { m &amp;lt;&amp;lt; Array.new(knapsack_size+1) } } cache[0].each_with_index { |value, weight| cache[0][weight] = 0 } (1..number_of_items).each do |i| value, weight = rows[i-1] (0..knapsack_size).each do |x| if weight &amp;gt; x cache[i][x] = cache[i-1][x] else cache[i][x] = [cache[i-1][x], cache[i-1][x-weight] + value].max end end end p cache[number_of_items][knapsack_size] @new_cache = [].tap { |m| (@number_of_items+1).times { m &amp;lt;&amp;lt; {} } } def knapsack_cached(rows, knapsack_size, index) return 0 if knapsack_size == 0 || index == 0 value, weight = rows[index] if weight &amp;gt; knapsack_size stored_value = @new_cache[index-1][knapsack_size] return stored_value unless stored_value.</description>
    </item>
    
  </channel>
</rss>