<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apoc on Mark Needham</title>
    <link>https://markhneedham.com/blog/tag/apoc/</link>
    <description>Recent content in Apoc on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Jan 2019 19:05:00 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/tag/apoc/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Neo4j: APOC - Caused by: java.io.RuntimeException: Can&#39;t read url or key file (No such file or directory)</title>
      <link>https://markhneedham.com/blog/2019/01/12/neo4j-apoc-file-not-found-exception-no-such-file-directory/</link>
      <pubDate>Sat, 12 Jan 2019 19:05:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/12/neo4j-apoc-file-not-found-exception-no-such-file-directory/</guid>
      <description>I&amp;#8217;ve been using Neo4j&amp;#8217;s APOC library to load some local JSON files this week, and ran into an interesting problem.
 The LOAD CSV tool assumes that any files you load locally are in the import directory, so I&amp;#8217;ve got into the habit of putting my data there. Let&amp;#8217;s check what I&amp;#8217;m trying to import by opening the import directory:
   What&amp;#8217;s in there?
   Just the one JSON file needs processing.</description>
    </item>
    
    <item>
      <title>Neo4j: Storing inferred relationships with APOC triggers</title>
      <link>https://markhneedham.com/blog/2018/11/05/neo4j-inferred-relationships-apoc-triggers/</link>
      <pubDate>Mon, 05 Nov 2018 06:15:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/11/05/neo4j-inferred-relationships-apoc-triggers/</guid>
      <description>One of my favourite things about modelling data in graphs is how easy it makes it to infer relationships between pieces of data based on other relationships. In this post we&amp;#8217;re going to learn how to compute and store those inferred relationships using the triggers feature from the APOC library.
 Meetup Graph Before we get to that, let&amp;#8217;s first understand what we mean when we say inferred relationship. We&amp;#8217;ll create a small graph containing Person, Meetup, and Topic nodes with the following query:</description>
    </item>
    
    <item>
      <title>Neo4j Graph Algorithms: Visualising Projected Graphs</title>
      <link>https://markhneedham.com/blog/2018/10/31/neo4j-graph-algorithms-visualise-projected-graph/</link>
      <pubDate>Wed, 31 Oct 2018 18:12:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/10/31/neo4j-graph-algorithms-visualise-projected-graph/</guid>
      <description>A few weeks ago I wrote a blog post showing how to work out the best tennis player of all time using the Weighted PageRank algorithm, and in the process created a projected credibility graph which I want to explore in more detail in this post.
 As I pointed out in that post, sometimes the graph model doesn&amp;#8217;t fit well with what the algorithm expects, so we need to project the graph on which we run graph algorithms.</description>
    </item>
    
    <item>
      <title>Neo4j: Building a graph of Strava activities</title>
      <link>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</guid>
      <description>In my last post I showed how to import activities from Strava&amp;#8217;s API into Neo4j using only the APOC library, but that was only part of the graph so I thought I&amp;#8217;d share the rest of what I&amp;#8217;ve done.
 The Graph Model In the previous post I showed how to import nodes with Run label, but there are some other pieces of data that I wanted to import as well.</description>
    </item>
    
    <item>
      <title>Neo4j APOC: Importing data from Strava&#39;s paginated JSON API</title>
      <link>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</link>
      <pubDate>Tue, 05 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</guid>
      <description>Over the weekend I&amp;#8217;ve been playing around with loading data from the Strava API into Neo4j and I started with the following Python script which creates a node with a Run label for each of my activities.
 If you want to follow along on your own data you&amp;#8217;ll need to get an API key via the &#39;My API Application&#39; section of the website. Once you&amp;#8217;ve got that put it in the TOKEN environment variable and you should be good to go.</description>
    </item>
    
    <item>
      <title>AWS: Spinning up a Neo4j instance with APOC installed</title>
      <link>https://markhneedham.com/blog/2017/09/30/aws-spinning-up-a-neo4j-instance-with-apoc-installed/</link>
      <pubDate>Sat, 30 Sep 2017 21:23:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/30/aws-spinning-up-a-neo4j-instance-with-apoc-installed/</guid>
      <description>One of the first things I do after installing Neo4j is install the APOC library, but I find it&#39;s a bit of a manual process when spinning up a server on AWS so I wanted to simplify it a bit.  There&#39;s already a Neo4j AMI which installs Neo4j 3.2.0 and my colleague Michael pointed out that we could download APOC into the correct folder by writing a script and sending it as UserData.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Create Cypher map with dynamic keys</title>
      <link>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</link>
      <pubDate>Tue, 19 Sep 2017 19:30:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</guid>
      <description>I was recently trying to create a map in a Cypher query but wanted to have dynamic keys in that map. I started off with this query: WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN { dynamicKey: dynamicValue } AS map ╒══════════════════╕ │&amp;quot;map&amp;quot; │ ╞══════════════════╡ │{&amp;quot;dynamicKey&amp;quot;:&amp;quot;b&amp;quot;}│ └──────────────────┘   Not quite what we want! We want dynamicKey to be evaluated rather than treated as a literal. As usual, APOC comes to the rescue!</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding of floating point numbers/BigDecimals</title>
      <link>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</link>
      <pubDate>Sun, 13 Aug 2017 07:23:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</guid>
      <description>I was doing some data cleaning a few days ago and wanting to multiply a value by 1 million. My Cypher code to do this looked like this: with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(rawNumeric) * 1000000 AS numeric ╒═════════════════╕ │&amp;quot;numeric&amp;quot; │ ╞═════════════════╡ │8369999.999999999│ └─────────────────┘   Unfortunately that suffers from the classic rounding error when working with floating point numbers. I couldn&#39;t figure out a way to solve it using pure Cypher, but there tends to be an APOC function to solve every problem and this was no exception.</description>
    </item>
    
    <item>
      <title>Neo4j: Create dynamic relationship type</title>
      <link>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</link>
      <pubDate>Sun, 30 Oct 2016 22:12:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</guid>
      <description>One of the things I&#39;ve often found frustrating when importing data using Cypher, Neo4j&#39;s query language, is that it&#39;s quite difficult to create dynamic relationship types. Say we have a CSV file structured like this:
load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row RETURN row  ╒═══════════════════════════════════════════════════════╕ │row │ ╞═══════════════════════════════════════════════════════╡ │{node1: Mark, node2: Reshmee, relationship: MARRIED_TO}│ ├───────────────────────────────────────────────────────┤ │{node1: Mark, node2: Alistair, relationship: FRIENDS} │ └───────────────────────────────────────────────────────┘  We want to create nodes with the relationship type specified in the file.</description>
    </item>
    
  </channel>
</rss>