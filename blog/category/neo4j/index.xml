<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>neo4j on Mark Needham</title>
    <link>https://markhneedham.com/blog/category/neo4j/</link>
    <description>Recent content in neo4j on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Oct 2020 00:21:00 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/category/neo4j/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Neo4j: Cypher - FOREACH vs CALL {} (subquery)</title>
      <link>https://markhneedham.com/blog/2020/10/29/neo4j-foreach-call-subquery/</link>
      <pubDate>Thu, 29 Oct 2020 00:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2020/10/29/neo4j-foreach-call-subquery/</guid>
      <description>I recently wanted to create a graph based on an adjacency list, and in this post we&amp;#8217;ll learn how to do that using the FOREACH clause and then with the new CALL {} subquery clause.
 We&amp;#8217;ll start with the following map of ids &amp;#8594; arrays of ids:
 :param list =&amp;gt; ({`0`: [7, 9], `1`: [2, 4, 5, 6, 8, 9], `2`: [0, 6, 8, 9], `3`: [1, 2, 6, 9], `4`: [1, 2, 3, 7], `5`: [8, 9], `6`: [2, 4, 5, 7, 8, 9], `7`: [0, 3, 4, 6, 8, 9], `8`: [1, 6, 9], `9`: [0, 1, 3, 5]})   We want to create one node per id and create a relationship from each node to the nodes in its array.</description>
    </item>
    
    <item>
      <title>QuickGraph #7: An entity graph of TWIN4j using APOC NLP</title>
      <link>https://markhneedham.com/blog/2020/05/05/quick-graph-building-entity-graph-twin4j-apoc-nlp/</link>
      <pubDate>Tue, 05 May 2020 00:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2020/05/05/quick-graph-building-entity-graph-twin4j-apoc-nlp/</guid>
      <description>One of the most popular use cases for Neo4j is knowledge graphs, and part of that process involves using NLP to create a graph structure from raw text. If we were doing a serious NLP project we&amp;#8217;d want to use something like GraphAware Hume, but in this blog post we&amp;#8217;re going to learn how to add basic NLP functionality to our graph applications.
  Figure 1. Building an entity graph of TWIN4j using APOC NLP  APOC NLP The big cloud providers (AWS, GCP, and Azure) all have Natural Language Processing APIs and, although their APIs aren&amp;#8217;t identical, they all let us extract entities, key phrases, and sentiment from text documents.</description>
    </item>
    
    <item>
      <title>Neo4j: Finding the longest path</title>
      <link>https://markhneedham.com/blog/2020/01/29/neo4j-finding-longest-path/</link>
      <pubDate>Wed, 29 Jan 2020 15:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2020/01/29/neo4j-finding-longest-path/</guid>
      <description>One on my favourite things about storing data in a graph database is executing path based queries against that data. I&amp;#8217;ve been trying to find a way to write such queries against the Australian Open QuickGraph, and in this blog post we&amp;#8217;re going to write what I think of as longest path queries against this graph.
  Figure 1. Finding longest paths in Neo4j  Setting up Neo4j We&amp;#8217;re going to use the following Docker Compose configuration in this blog post:</description>
    </item>
    
    <item>
      <title>Neo4j: Exporting a subset of data from one database to another</title>
      <link>https://markhneedham.com/blog/2020/01/27/neo4j-exporting-subset-database/</link>
      <pubDate>Mon, 27 Jan 2020 00:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2020/01/27/neo4j-exporting-subset-database/</guid>
      <description>As part of the preparation for another blog post, I wanted to export a subset of data from one Neo4j database to another one, which seemed like a blog post in its own right.
  Figure 1. Exporting data using APOC&amp;#8217;s Export JSON  Setting up Neo4j We&amp;#8217;re going to use the following Docker Compose configuration in this blog post:
 Dockerfile version: &#39;3.7&#39; services: neo4j: image: neo4j:4.0.0-enterprise container_name: &#34;</description>
    </item>
    
    <item>
      <title>Creating an Interactive UK Official Charts Data App with Streamlit and Neo4j</title>
      <link>https://markhneedham.com/blog/2020/01/16/interactive-uk-charts-quickgraph-neo4j-streamlit/</link>
      <pubDate>Thu, 16 Jan 2020 00:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2020/01/16/interactive-uk-charts-quickgraph-neo4j-streamlit/</guid>
      <description>I recently came across Streamlit, a tool that makes it easy to build data based single page web applications. I wanted to give it a try, and the UK Charts QuickGraph that I recently wrote about seemed like a good opportunity for that.
 This blog post starts from where we left off. The data is loaded into Neo4j and we&amp;#8217;ve written some queries to explore different aspects of the dataset.</description>
    </item>
    
    <item>
      <title>Graphing Brexit: Did the threat work?</title>
      <link>https://markhneedham.com/blog/2019/09/27/graphing-brexit-did-the-threat-work/</link>
      <pubDate>Fri, 27 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/27/graphing-brexit-did-the-threat-work/</guid>
      <description>Following on from the blog post where we compared how MPs and parties voted on Brexit indicative measures, in this post we&amp;#8217;re going to explore how Conservative MPs have voted with respect to a no deal exit from the European Union. In particular we&amp;#8217;d like to know whether the threat to have the party whip removed had an impact on how they voted in the recent motion to request an extension to work out a deal.</description>
    </item>
    
    <item>
      <title>Graphing Brexit: MPs vs Parties</title>
      <link>https://markhneedham.com/blog/2019/09/23/graphing-brexit-mps-vs-parties/</link>
      <pubDate>Mon, 23 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/23/graphing-brexit-mps-vs-parties/</guid>
      <description>In the previous post of the Graphing Brexit series we computed the average vote by party. In this post we&amp;#8217;re going to take those average party scores and compare them against the votes placed by individual MPs. The goal is to determine whether, Brexit wise, MPs are representing the right party!
 It won&amp;#8217;t be perfect since we know that not everyone in a party voted the same way, but it should still give us some fun results.</description>
    </item>
    
    <item>
      <title>Graphing Brexit: Plotting how the parties voted</title>
      <link>https://markhneedham.com/blog/2019/09/20/graphing-brexit-charting-how-the-parties-voted/</link>
      <pubDate>Fri, 20 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/20/graphing-brexit-charting-how-the-parties-voted/</guid>
      <description>Over the last week I&amp;#8217;ve revisited the Brexit Graph that I created in March 2019, this time looking at how the parties voted on average on each of the indicative votes.
 To recap, we have a graph that has the following schema:
   Since the initial post I&amp;#8217;ve slightly changed how the MEMBER_OF relationship works. As several MPs have switched MPs in the intervening months, we&amp;#8217;re now storing a start property to indicate when they started representing a party and an end property to indicate when they stopped representing a party.</description>
    </item>
    
    <item>
      <title>Neo4j: Approximate string matching/similarity</title>
      <link>https://markhneedham.com/blog/2019/09/18/neo4j-string-matching-similarity/</link>
      <pubDate>Wed, 18 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/18/neo4j-string-matching-similarity/</guid>
      <description>I&amp;#8217;ve been playing with the Brexit Graph over the last few days, and wanted to map the MPs that I got from CommonsVotes with data from the TheyWorkForYou API.
 I already had voting records loaded into Neo4j, but to recap, this is how I did that:
 UNWIND [655,656,657,658,659,660,661,662,711, 669, 668, 667, 666, 664] AS division LOAD CSV FROM &#34;https://github.com/mneedham/graphing-brexit/raw/master/data/commonsvotes/Division&#34; + division + &#34;.csv&#34; AS row // Create motion nodes WITH division, collect(row) AS rows MERGE (motion:Motion {division: trim(split(rows[0][0], &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: apoc.load.csv - Neo.ClientError.Statement.SyntaxError: Type mismatch: expected Float, Integer, Number or String but was Any </title>
      <link>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</link>
      <pubDate>Thu, 05 Sep 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/09/05/neo4j-apoc-load-csv-type-mismatch-expected-float-integer-number-string/</guid>
      <description>The Neo4j APOC library&#39;s Load CSV procedure is very useful if you want more control over the import process than the LOAD CSV clause allows. I found myself using it last week to import a CSV file of embeddings, because I wanted to know the line number of the row in the CSV file while importing the data.
 I had a file that looked like this, which I put into the import directory:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions vs OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</link>
      <pubDate>Fri, 23 Aug 2019 00:47:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/23/neo4j-cypher-path-comprehensions-optional-match/</guid>
      <description>While writing my previous post about Cypher nested path comprehensions, I realised that for this particular problem, the OPTIONAL MATCH clause is a better choice.
 To recap, we have the following graph:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;}) MERGE (club2)-[:IN_LEAGUE]-&amp;gt;(league2)     We started the post with the following query that returns (club)-[:IN_LEAGUE]&amp;#8594;(league)-[:IN_COUNTRY]&amp;#8594;(country) paths:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Nested Path Comprehensions</title>
      <link>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</link>
      <pubDate>Thu, 22 Aug 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/08/22/neo4j-cypher-nested-pattern-comprehensions/</guid>
      <description>I&amp;#8217;ve recently been building an application using the GRANDstack, which uses nested Cypher path comprehensions to translate GraphQL queries to Cypher ones. I&amp;#8217;d not done this before, so I was quite curious how this feature worked. We&amp;#8217;ll explore it using the following dataset:
 MERGE (club:Club {name: &#34;Man Utd&#34;}) MERGE (league:League {name: &#34;Premier League&#34;}) MERGE (country:Country {name: &#34;England&#34;}) MERGE (club)-[:IN_LEAGUE]-&amp;gt;(league) MERGE (league)-[:IN_COUNTRY]-&amp;gt;(country) MERGE (club2:Club {name: &#34;Juventus&#34;}) MERGE (league2:League {name: &#34;Serie A&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Conditional WHERE clause with APOC</title>
      <link>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</link>
      <pubDate>Wed, 31 Jul 2019 11:08:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/07/31/neo4j-conditional-where-query-apoc/</guid>
      <description>Sometimes we want to be able to vary our Cypher queries based on the value of a parameter. I came across such a situation today, and thought I&amp;#8217;d share how I solved it using the APOC library.
 Let&amp;#8217;s first setup some sample data:
 UNWIND range(0, 5) AS id CREATE (:Person {name: &#34;person-&#34; + id})   Now, if we want to get all pairs of people, we could write the following query:</description>
    </item>
    
    <item>
      <title>Twint: Loading tweets into Kafka and Neo4j</title>
      <link>https://markhneedham.com/blog/2019/05/29/loading-tweets-twint-kafka-neo4j/</link>
      <pubDate>Wed, 29 May 2019 06:50:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/05/29/loading-tweets-twint-kafka-neo4j/</guid>
      <description>In this post we&amp;#8217;re going to load tweets via the twint library into Kafka, and once we&amp;#8217;ve got them in there we&amp;#8217;ll use the Kafka Connect Neo4j Sink Plugin to get them into Neo4j.
 What is twint? Twitter data has always been some of the most fun to play with, but over the years the official API has become more and more restritive, and it now takes a really long time to download enough data to do anything interesting.</description>
    </item>
    
    <item>
      <title>Neo4j: keep/filter keys in a map using APOC</title>
      <link>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</link>
      <pubDate>Sun, 12 May 2019 17:58:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/05/12/neo4j-keep-filter-keys-map-apoc/</guid>
      <description>In this post we&amp;#8217;ll learn how to write a Cypher query to create a node in Neo4j containing some of the keys from a map. This post assumes that the APOC library is installed.
 We&amp;#8217;ll start by creating a map that contains data from my twitter profile:
 :param document =&amp;gt; { id: 14707949, name: &#34;Mark Needham&#34;, username: &#34;markhneedham&#34;, bio: &#34;Developer Relations @neo4j&#34;, location: &#34;London, United Kingdom&#34;, url: &#34;http://www.markhneedham.com&#34;, join_date: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Delete all nodes</title>
      <link>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</link>
      <pubDate>Sun, 14 Apr 2019 12:52:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/04/14/neo4j-delete-all-nodes/</guid>
      <description>When experimenting with a new database, at some stage we&amp;#8217;ll probably want to delete all our data and start again. I was trying to do this with Neo4j over the weekend and it didn&amp;#8217;t work as I expected, so I thought I&amp;#8217;d write the lessons I learned.
 We&amp;#8217;ll be using Neo4j via the Neo4j Desktop with the default settings. This means that we have a maximum heap size of 1GB.</description>
    </item>
    
    <item>
      <title>Neo4j: From Graph Model to Neo4j Import</title>
      <link>https://markhneedham.com/blog/2019/03/27/from-graph-model-to-neo4j-import/</link>
      <pubDate>Wed, 27 Mar 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/03/27/from-graph-model-to-neo4j-import/</guid>
      <description>In this post we&amp;#8217;re going to learn how to import the DBLP citation network into Neo4j using the Neo4j Import Tool.
 In case you haven&amp;#8217;t come across this dataset before, Tomaz Bratanic has a great blog post explaining it.
 The tl;dr is that we have articles, authors, and venues. Authors can write articles, articles can reference other articles, and articles are presented at a venue. Below is the graph model for this dataset:</description>
    </item>
    
    <item>
      <title>Neo4j: Delete/Remove dynamic properties</title>
      <link>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</link>
      <pubDate>Thu, 14 Mar 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/03/14/neo4j-delete-dynamic-properties/</guid>
      <description>Irfan and I were playing with a dataset earlier today, and having run a bunch of graph algorithms, we had a lot of properties that we wanted to clear out.
 The following Cypher query puts Neo4j into the state that we were dealing with.
 CREATE (:Node {name: &#34;Mark&#34;, pagerank: 2.302, louvain: 1, lpa: 4 }) CREATE (:Node {name: &#34;Michael&#34;, degree: 23, triangles: 12, betweeness: 48.70 }) CREATE (:Node {name: &#34;</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Date ranges</title>
      <link>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</link>
      <pubDate>Sun, 13 Jan 2019 06:42:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/13/neo4j-cypher-date-ranges/</guid>
      <description>As part of a dataset I&amp;#8217;ve been working with this week, I wanted to generate a collection of a range of dates using the Cypher query language.
 I&amp;#8217;ve previously used the duration function, which lets you add (or subtract) from a specific date, so I thought I&amp;#8217;d start from there. If we want to find the day after 1st January 2019, we could write the following query:
 neo4j&amp;gt; WITH date(&#34;</description>
    </item>
    
    <item>
      <title>Neo4j: APOC - Caused by: java.io.RuntimeException: Can&#39;t read url or key file (No such file or directory)</title>
      <link>https://markhneedham.com/blog/2019/01/12/neo4j-apoc-file-not-found-exception-no-such-file-directory/</link>
      <pubDate>Sat, 12 Jan 2019 19:05:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/12/neo4j-apoc-file-not-found-exception-no-such-file-directory/</guid>
      <description>I&amp;#8217;ve been using Neo4j&amp;#8217;s APOC library to load some local JSON files this week, and ran into an interesting problem.
 The LOAD CSV tool assumes that any files you load locally are in the import directory, so I&amp;#8217;ve got into the habit of putting my data there. Let&amp;#8217;s check what I&amp;#8217;m trying to import by opening the import directory:
   What&amp;#8217;s in there?
   Just the one JSON file needs processing.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Remove consecutive duplicates from a list</title>
      <link>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</link>
      <pubDate>Sat, 12 Jan 2019 04:32:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2019/01/12/neo4j-cypher-remove-consecutive-duplicates/</guid>
      <description>I was playing with a dataset this week and wanted to share how I removes duplicate consecutive elements from a list using the Cypher query language.
 For simplicity&amp;#8217;s sake, imagine that we have this list:
 neo4j&amp;gt; return [1,2,3,3,4,4,4,5,3] AS values; +-----------------------------+ | values | +-----------------------------+ | [1, 2, 3, 3, 4, 4, 4, 5, 3] | +-----------------------------+   We want to remove the duplicate 3&amp;#8217;s and 4&amp;#8217;s, such that our end result should be:</description>
    </item>
    
    <item>
      <title>Neo4j: Pruning transaction logs more aggressively</title>
      <link>https://markhneedham.com/blog/2018/12/24/neo4j-prune-transaction-logs-more-aggressively/</link>
      <pubDate>Mon, 24 Dec 2018 21:09:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/12/24/neo4j-prune-transaction-logs-more-aggressively/</guid>
      <description>One thing that new users of Neo4j when playing around with it locally is how much space the transaction logs can take up, especially when we&amp;#8217;re creating and deleting lots of data while we get started. We can see this by running the following query a few times:
 UNWIND range(0, 1000) AS id CREATE (:Foo {id: id}); MATCH (f:Foo) DELETE f   This query creates a bunch of data before immediately deleting it.</description>
    </item>
    
    <item>
      <title>Neo4j: Storing inferred relationships with APOC triggers</title>
      <link>https://markhneedham.com/blog/2018/11/05/neo4j-inferred-relationships-apoc-triggers/</link>
      <pubDate>Mon, 05 Nov 2018 06:15:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/11/05/neo4j-inferred-relationships-apoc-triggers/</guid>
      <description>One of my favourite things about modelling data in graphs is how easy it makes it to infer relationships between pieces of data based on other relationships. In this post we&amp;#8217;re going to learn how to compute and store those inferred relationships using the triggers feature from the APOC library.
 Meetup Graph Before we get to that, let&amp;#8217;s first understand what we mean when we say inferred relationship. We&amp;#8217;ll create a small graph containing Person, Meetup, and Topic nodes with the following query:</description>
    </item>
    
    <item>
      <title>Neo4j Graph Algorithms: Visualising Projected Graphs</title>
      <link>https://markhneedham.com/blog/2018/10/31/neo4j-graph-algorithms-visualise-projected-graph/</link>
      <pubDate>Wed, 31 Oct 2018 18:12:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/10/31/neo4j-graph-algorithms-visualise-projected-graph/</guid>
      <description>A few weeks ago I wrote a blog post showing how to work out the best tennis player of all time using the Weighted PageRank algorithm, and in the process created a projected credibility graph which I want to explore in more detail in this post.
 As I pointed out in that post, sometimes the graph model doesn&amp;#8217;t fit well with what the algorithm expects, so we need to project the graph on which we run graph algorithms.</description>
    </item>
    
    <item>
      <title>Neo4j: Using LOAD CSV to process csv.gz files from S3</title>
      <link>https://markhneedham.com/blog/2018/09/05/neo4j-load-csv-gz-s3/</link>
      <pubDate>Wed, 05 Sep 2018 07:26:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/09/05/neo4j-load-csv-gz-s3/</guid>
      <description>I&amp;#8217;ve been building some training material for the GraphConnect conference that happens in a couple of weeks time and I wanted to load gzipped CSV files. I got this working using Cypher&amp;#8217;s LOAD CSV command with the file stored locally, but when I uploaded it to S3 it didn&amp;#8217;t work as I expected.
 I uploaded the file to an S3 bucket and then tried to read it back like this:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Grouping Datetimes</title>
      <link>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</link>
      <pubDate>Tue, 10 Jul 2018 04:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/10/neo4j-grouping-datetimes/</guid>
      <description>In my continued analysis of Strava runs I wanted to try and find my best runs grouped by different time components, which was actually much easier than I was expecting.
 Importing the dataset If you want to try out the examples below you can execute the following LOAD CSV commands to load the data:
 LOAD CSV WITH HEADERS FROM &#34;https://github.com/mneedham/strava/raw/master/runs.csv&#34; AS row MERGE (run:Run {id: toInteger(row.id)}) SET run.distance = toFloat(row.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Syntax Error - Text cannot be parsed to a Duration (aka dealing with empty durations)</title>
      <link>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</link>
      <pubDate>Mon, 09 Jul 2018 18:21:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/07/09/neo4j-text-cannot-be-parsed-to-duration/</guid>
      <description>As I continued with my travels with Neo4j 3.4&amp;#8217;s temporal data type I came across some fun edge cases when dealing with empty durations while importing data.
 Imagine we&amp;#8217;re trying to create 3 nodes from the following array of input data. Two of the rows have invalid durations!
 UNWIND [ {id: 12345, duration: &#34;PT2M20S&#34;}, {id: 12346, duration: &#34;&#34;}, {id: 12347, duration: null} ] AS row MERGE (run:Run {id: row.</description>
    </item>
    
    <item>
      <title>Neo4j: Querying the Strava Graph using Py2neo</title>
      <link>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</link>
      <pubDate>Fri, 15 Jun 2018 13:45:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/15/neo4j-querying-strava-graph-py2neo/</guid>
      <description>Last week Nigel released v4 of Py2neo and given I was just getting ready to write some queries against my Strava activity graph I thought I&amp;#8217;d give it a try.
 If you want to learn how to create your own Strava graph you should read my previous post, but just to recap, this is the graph model that we created:
   Let&amp;#8217;s get to it!
 tl;dr the code in this post is available as a Jupyter notebook so if you want the code and nothing but the code head over there!</description>
    </item>
    
    <item>
      <title>Neo4j: Building a graph of Strava activities</title>
      <link>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</link>
      <pubDate>Tue, 12 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/12/neo4j-building-strava-graph/</guid>
      <description>In my last post I showed how to import activities from Strava&amp;#8217;s API into Neo4j using only the APOC library, but that was only part of the graph so I thought I&amp;#8217;d share the rest of what I&amp;#8217;ve done.
 The Graph Model In the previous post I showed how to import nodes with Run label, but there are some other pieces of data that I wanted to import as well.</description>
    </item>
    
    <item>
      <title>Neo4j APOC: Importing data from Strava&#39;s paginated JSON API</title>
      <link>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</link>
      <pubDate>Tue, 05 Jun 2018 05:30:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/05/neo4j-apoc-loading-data-strava-paginated-json-api/</guid>
      <description>Over the weekend I&amp;#8217;ve been playing around with loading data from the Strava API into Neo4j and I started with the following Python script which creates a node with a Run label for each of my activities.
 If you want to follow along on your own data you&amp;#8217;ll need to get an API key via the &#39;My API Application&#39; section of the website. Once you&amp;#8217;ve got that put it in the TOKEN environment variable and you should be good to go.</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Gotchas when working with Durations</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</link>
      <pubDate>Sun, 03 Jun 2018 20:11:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-gotchas-working-with-durations/</guid>
      <description>Continuing with my explorations of Strava data in Neo4j I wanted to share some things I learnt while trying to work out my pace for certain distances.
 Before we get into the pace calculations let&amp;#8217;s first understand how the duration function works. If we run the following query we might expect to get back the same value that we put in&amp;#8230;&amp;#8203;
 RETURN duration({seconds: 413.77}).seconds AS seconds   ╒═════════╕ │&#34;</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Formatting instances of the Duration and Datetime date types</title>
      <link>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</link>
      <pubDate>Sun, 03 Jun 2018 04:08:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/03/neo4j-3.4-formatting-instances-durations-dates/</guid>
      <description>In my last blog post I showed how to compare instances of Neo4j&amp;#8217;s Duration data type, and in the middle of the post I realised that I needed to use the APOC library to return the value in the format I wanted. This was the solution I ended up with:
 WITH duration({seconds: 100}) AS duration RETURN apoc.text.lpad(toString(duration.minutes), 2, &#34;0&#34;) + &#34;:&#34; + apoc.text.lpad(toString(duration.secondsOfMinute), 2, &#34;0&#34;)   If we run that query this is the output:</description>
    </item>
    
    <item>
      <title>Neo4j 3.4: Comparing durations</title>
      <link>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</link>
      <pubDate>Sat, 02 Jun 2018 03:24:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/06/02/neo4j-3.4-comparing-durations/</guid>
      <description>Neo4j 3.4 saw the introduction of the temporal date type, which my colleague Adam Cowley covered in his excellent blog post, and in this post I want to share my experience using durations from my Strava runs.
 I&amp;#8217;ll show how to load the whole Strava dataset in another blog post but for now we&amp;#8217;ll just manually create some durations based on the elapsed time in seconds that Strava provides. We can run the following query to convert duration in seconds into the duration type:</description>
    </item>
    
    <item>
      <title>Neo4j Desktop: undefined: Unable to extract host from undefined</title>
      <link>https://markhneedham.com/blog/2018/03/20/neo4j-undefined-unable-to-extract-host-from-undefined/</link>
      <pubDate>Tue, 20 Mar 2018 17:51:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/20/neo4j-undefined-unable-to-extract-host-from-undefined/</guid>
      <description>During a training session I facilitated today one of the attendees got the following error message while trying to execute a query inside the Neo4j Desktop.
   This error message happens if we try to run a query when the database hasn&amp;#8217;t been started, and would usually be accompanied by this screen:
   On this occasion that wasn&amp;#8217;t happening, but we can easily fix it by going back to the project screen and starting the database:</description>
    </item>
    
    <item>
      <title>Neo4j: Using the Neo4j Import Tool with the Neo4j Desktop</title>
      <link>https://markhneedham.com/blog/2018/03/19/neo4j-using-neo4j-import-tool-with-neo4j-desktop/</link>
      <pubDate>Mon, 19 Mar 2018 21:38:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/19/neo4j-using-neo4j-import-tool-with-neo4j-desktop/</guid>
      <description>Last week as part of a modelling and import webinar I showed how to use the Neo4j Import Tool to create a graph of the Yelp Open Dataset:
  Afterwards I realised that I didn&amp;#8217;t show how to use the tool if you already have an existing database in place so this post will show how to do that.
 Imagine we have a Neo4j Desktop project that looks like this:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Neo.ClientError.Statement.TypeError: Don&#39;t know how to add Double and String</title>
      <link>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</link>
      <pubDate>Wed, 14 Mar 2018 16:53:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/14/neo4j-cypher-neo-clienterror-statement-typeerror-dont-know-add-double-string/</guid>
      <description>RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; ╒══════════╕ │&amp;quot;result&amp;quot; │ ╞══════════╡ │&amp;quot;1.0 Mark&amp;quot;│ └──────────┘ RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; Neo.ClientError.Statement.TypeError: Don&#39;t know how to add `Double(1.000000e+00)` and `String(&amp;quot; Mark&amp;quot;)` CYPHER 3.2 RETURN toFloat(&amp;quot;1.0&amp;quot;) + &amp;quot; Mark&amp;quot; AS result RETURN toString(toFloat(&amp;quot;1.0&amp;quot;)) + &amp;quot; Mark&amp;quot; AS result </description>
    </item>
    
    <item>
      <title>Neo4j Import: java.lang.IllegalStateException: Mixing specified and unspecified group belongings in a single import isn&#39;t supported</title>
      <link>https://markhneedham.com/blog/2018/03/07/neo4j-import-java-lang-illegalstateexception-mixing-specified-unspecified-group-belongings-single-import-isnt-supported/</link>
      <pubDate>Wed, 07 Mar 2018 03:11:12 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2018/03/07/neo4j-import-java-lang-illegalstateexception-mixing-specified-unspecified-group-belongings-single-import-isnt-supported/</guid>
      <description>$ cat people_header.csv name:ID(Person) $ cat people.csv &amp;#34;Mark&amp;#34; &amp;#34;Michael&amp;#34; &amp;#34;Ryan&amp;#34; &amp;#34;Will&amp;#34; &amp;#34;Jennifer&amp;#34; &amp;#34;Karin&amp;#34; $ cat companies_header.csv name:ID(Company) $ cat companies.csv &amp;#34;Neo4j&amp;#34; $ ./bin/neo4j-admin import \ 	--database=blog.db \ 	--mode=csv \ 	--nodes:Person people_header.csv,people.csv \ 	--nodes:Company companies_heade.csv,companies.csv Neo4j version: 3.3.3 Importing the contents of these files into /Users/markneedham/Library/Application Support/Neo4j Desktop/Application/neo4jDatabases/database-b59e33d5-2060-4a5d-bdb8-0b9f6dc919fa/installation-3.3.3/data/databases/blog.db: Nodes: :Person /Users/markneedham/Library/Application Support/Neo4j Desktop/Application/neo4jDatabases/database-b59e33d5-2060-4a5d-bdb8-0b9f6dc919fa/installation-3.3.3/people_header.csv /Users/markneedham/Library/Application Support/Neo4j Desktop/Application/neo4jDatabases/database-b59e33d5-2060-4a5d-bdb8-0b9f6dc919fa/installation-3.3.3/people.csv :Company /Users/markneedham/Library/Application Support/Neo4j Desktop/Application/neo4jDatabases/database-b59e33d5-2060-4a5d-bdb8-0b9f6dc919fa/installation-3.3.3/companies.csv ... Import error: Mixing specified and unspecified group belongings in a single import isn&amp;#39;t supported Caused by:Mixing specified and unspecified group belongings in a single import isn&amp;#39;t supported java.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Property values can only be of primitive types or arrays thereof.</title>
      <link>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</link>
      <pubDate>Fri, 01 Dec 2017 22:09:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/12/01/neo4j-cypher-property-values-can-primitive-types-arrays-thereof/</guid>
      <description>CREATE (:Person {id: [1, &amp;quot;mark&amp;quot;, 2.0]}) Neo.ClientError.Statement.TypeError Property values can only be of primitive types or arrays thereof. CREATE (:Person {id: [value in [1, &amp;quot;mark&amp;quot;, 2.0] | toString(value)]}) Added 1 label, created 1 node, set 1 property, completed after 4 ms. </description>
    </item>
    
    <item>
      <title>Kubernetes: Copy a dataset to a StatefulSet&#39;s PersistentVolume</title>
      <link>https://markhneedham.com/blog/2017/11/18/kubernetes-copy-a-dataset-to-a-statefulsets-persistentvolume/</link>
      <pubDate>Sat, 18 Nov 2017 12:44:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/11/18/kubernetes-copy-a-dataset-to-a-statefulsets-persistentvolume/</guid>
      <description>$ kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE datadir-neo-helm-neo4j-core-0 Bound pvc-043efa91-cc54-11e7-bfa5-080027ab9eac 10Gi RWO standard 45s datadir-neo-helm-neo4j-core-1 Bound pvc-1737755a-cc54-11e7-bfa5-080027ab9eac 10Gi RWO standard 13s datadir-neo-helm-neo4j-core-2 Bound pvc-18696bfd-cc54-11e7-bfa5-080027ab9eac 10Gi RWO standard 11s $ kubectl get pv NAME CAPACITY ACCESS MODES RECLAIM POLICY STATUS CLAIM STORAGECLASS REASON AGE pvc-043efa91-cc54-11e7-bfa5-080027ab9eac 10Gi RWO Delete Bound default/datadir-neo-helm-neo4j-core-0 standard 41m pvc-1737755a-cc54-11e7-bfa5-080027ab9eac 10Gi RWO Delete Bound default/datadir-neo-helm-neo4j-core-1 standard 40m pvc-18696bfd-cc54-11e7-bfa5-080027ab9eac 10Gi RWO Delete Bound default/datadir-neo-helm-neo4j-core-2 standard 40m #!</description>
    </item>
    
    <item>
      <title>Kubernetes 1.8: Using Cronjobs to take Neo4j backups</title>
      <link>https://markhneedham.com/blog/2017/11/17/kubernetes-1-8-using-cronjobs-take-neo4j-backups/</link>
      <pubDate>Fri, 17 Nov 2017 18:10:28 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/11/17/kubernetes-1-8-using-cronjobs-take-neo4j-backups/</guid>
      <description>minikube start --memory 8192 helm init &amp;amp;&amp;amp; kubectl rollout status -w deployment/tiller-deploy --namespace=kube-system helm repo add incubator https://kubernetes-charts-incubator.storage.googleapis.com/ helm install incubator/neo4j --name neo-helm --wait --set authEnabled=false,core.extraVars.NEO4J_dbms_backup_address=0.0.0.0:6362 kubectl exec neo-helm-neo4j-core-0 \  -- bin/cypher-shell --format verbose \  &amp;#34;CALL dbms.cluster.overview() YIELD id, role RETURN id, role&amp;#34; +-----------------------------------------------------+ | id | role | +-----------------------------------------------------+ | &amp;#34;0b3bfe6c-6a68-4af5-9dd2-e96b564df6e5&amp;#34; | &amp;#34;LEADER&amp;#34; | | &amp;#34;09e9bee8-bdc5-4e95-926c-16ea8213e6e7&amp;#34; | &amp;#34;FOLLOWER&amp;#34; | | &amp;#34;859b9b56-9bfc-42ae-90c3-02cedacfe720&amp;#34; | &amp;#34;FOLLOWER&amp;#34; | +-----------------------------------------------------+ kubectl exec neo-helm-neo4j-core-0 \  -- bin/cypher-shell --format verbose \  &amp;#34;UNWIND range(0,1000) AS id CREATE (:Person {id: id})&amp;#34; 0 rows available after 653 ms, consumed after another 0 ms Added 1001 nodes, Set 1001 properties, Added 1001 labels kind: PersistentVolumeClaim apiVersion: v1 metadata: name: backupdir-neo4j labels: app: neo4j-backup spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi --- apiVersion: batch/v1beta1 kind: CronJob metadata: name: neo4j-backup spec: schedule: &amp;#34;*/1 * * * *&amp;#34; jobTemplate: spec: template: spec: volumes: - name: backupdir-neo4j persistentVolumeClaim: claimName: backupdir-neo4j containers: - name: neo4j-backup image: neo4j:3.</description>
    </item>
    
    <item>
      <title>Neo4j Browser: Expected entity id to be an integral value</title>
      <link>https://markhneedham.com/blog/2017/11/06/neo4j-browser-expected-entity-id-integral-value/</link>
      <pubDate>Mon, 06 Nov 2017 16:17:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/11/06/neo4j-browser-expected-entity-id-integral-value/</guid>
      <description>unwind range(0,1000) AS id create (:Person {id: id}) :param ids: [0] match (p:Person) where p.id in {ids} return p ╒════════╕ │&amp;quot;p&amp;quot; │ ╞════════╡ │{&amp;quot;id&amp;quot;:0}│ └────────┘ match (p:Person) where id(p) in {ids} return p Neo.ClientError.Statement.TypeError Expected entity id to be an integral value match (p:Person) where id(p) in [id in {ids} | toInteger(id)] return p ╒════════╕ │&amp;quot;p&amp;quot; │ ╞════════╡ │{&amp;quot;id&amp;quot;:0}│ └────────┘ </description>
    </item>
    
    <item>
      <title>Neo4j: Traversal query timeout</title>
      <link>https://markhneedham.com/blog/2017/10/31/neo4j-traversal-query-timeout/</link>
      <pubDate>Tue, 31 Oct 2017 21:43:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/10/31/neo4j-traversal-query-timeout/</guid>
      <description>StandardExpander orderedExpander = new OrderedByTypeExpander() .add( RelationshipType.withName( &amp;#34;CONNECTS&amp;#34; ), Direction.BOTH ); PathFinder&amp;lt;Path&amp;gt; shortestPathFinder = GraphAlgoFactory.shortestPath( expander, 250 ); ... public class TimeConstrainedExpander implements PathExpander { private final StandardExpander expander; private final long startTime; private final Clock clock; private int pathsExpanded = 0; private long timeLimitInMillis; public TimeConstrainedExpander( StandardExpander expander, Clock clock, long timeLimitInMillis ) { this.expander = expander; this.clock = clock; this.startTime = clock.instant().toEpochMilli(); this.timeLimitInMillis = timeLimitInMillis; } @Override public Iterable&amp;lt;Relationship&amp;gt; expand( Path path, BranchState state ) { long timeSoFar = clock.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Deleting duplicate nodes</title>
      <link>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</link>
      <pubDate>Fri, 06 Oct 2017 16:13:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/10/06/neo4j-cypher-deleting-duplicate-nodes/</guid>
      <description>UNWIND range(0, 100) AS id CREATE (p1:Person {id: toInteger(rand() * id)}) MERGE (p2:Person {id: toInteger(rand() * id)}) MERGE (p3:Person {id: toInteger(rand() * id)}) MERGE (p4:Person {id: toInteger(rand() * id)}) CREATE (p1)-[:KNOWS]-&amp;gt;(p2) CREATE (p1)-[:KNOWS]-&amp;gt;(p3) CREATE (p1)-[:KNOWS]-&amp;gt;(p4) Added 173 labels, created 173 nodes, set 173 properties, created 5829 relationships, completed after 408 ms. MATCH (p:Person) WITH p.id as id, collect(p) AS nodes WHERE size(nodes) &amp;gt; 1 RETURN [ n in nodes | n.</description>
    </item>
    
    <item>
      <title>AWS: Spinning up a Neo4j instance with APOC installed</title>
      <link>https://markhneedham.com/blog/2017/09/30/aws-spinning-up-a-neo4j-instance-with-apoc-installed/</link>
      <pubDate>Sat, 30 Sep 2017 21:23:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/30/aws-spinning-up-a-neo4j-instance-with-apoc-installed/</guid>
      <description>#!/bin/bash curl -L https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/3.2.0.3/apoc-3.2.0.3-all.jar -O sudo cp apoc-3.2.0.3-all.jar /var/lib/neo4j/plugins/ $ node neo4j-with-apoc.js Creating a Neo4j server Key pair created. Save this to a file - you&amp;#39;ll need to use it if you want to ssh into the Neo4j server -----BEGIN RSA PRIVATE KEY----- &amp;lt;Private key details&amp;gt; -----END RSA PRIVATE KEY----- Created Group Id:&amp;lt;Group Id&amp;gt; Opened Neo4j ports Instance Id: &amp;lt;Instance Id&amp;gt; Your Neo4j server is now ready! You&amp;#39;ll need to login to the server and change the default password: https://ec2-ip-address.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Create Cypher map with dynamic keys</title>
      <link>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</link>
      <pubDate>Tue, 19 Sep 2017 19:30:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/09/19/neo4j-cypher-create-cypher-map-with-dynamic-keys/</guid>
      <description>WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN { dynamicKey: dynamicValue } AS map ╒══════════════════╕ │&amp;quot;map&amp;quot; │ ╞══════════════════╡ │{&amp;quot;dynamicKey&amp;quot;:&amp;quot;b&amp;quot;}│ └──────────────────┘ CALL dbms.functions() yield name, description WHERE name STARTS WITH &amp;quot;apoc.map.from&amp;quot; RETURN name, description ╒═════════════════════╤═════════════════════════════════════════════════════╕ │&amp;quot;name&amp;quot; │&amp;quot;description&amp;quot; │ ╞═════════════════════╪═════════════════════════════════════════════════════╡ │&amp;quot;apoc.map.fromLists&amp;quot; │&amp;quot;apoc.map.fromLists([keys],[values])&amp;quot; │ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromNodes&amp;quot; │&amp;quot;apoc.map.fromNodes(label, property)&amp;quot; │ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromPairs&amp;quot; │&amp;quot;apoc.map.fromPairs([[key,value],[key2,value2],...])&amp;quot;│ ├─────────────────────┼─────────────────────────────────────────────────────┤ │&amp;quot;apoc.map.fromValues&amp;quot;│&amp;quot;apoc.map.fromValues([key1,value1,key2,value2,...])&amp;quot; │ └─────────────────────┴─────────────────────────────────────────────────────┘ WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN apoc.map.fromValues([dynamicKey, dynamicValue]) AS map ╒═════════╕ │&amp;quot;map&amp;quot; │ ╞═════════╡ │{&amp;quot;a&amp;quot;:&amp;quot;b&amp;quot;}│ └─────────┘ WITH &amp;quot;a&amp;quot; as dynamicKey, &amp;quot;b&amp;quot; as dynamicValue RETURN apoc.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding of floating point numbers/BigDecimals</title>
      <link>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</link>
      <pubDate>Sun, 13 Aug 2017 07:23:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/08/13/neo4j-cypher-rounding-of-floating-point-numbersbigdecimals/</guid>
      <description>with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(rawNumeric) * 1000000 AS numeric ╒═════════════════╕ │&amp;quot;numeric&amp;quot; │ ╞═════════════════╡ │8369999.999999999│ └─────────────────┘ $ ls -lh plugins/ total 3664 -rw-r--r--@ 1 markneedham staff 1.8M 9 Aug 09:14 apoc-3.2.0.4-all.jar $ docker run -v $PWD/plugins:/plugins \  -p 7474:7474 \  -p 7687:7687 \  -e NEO4J_AUTH=&amp;#34;none&amp;#34; \  neo4j:3.2.3 with &amp;quot;8.37&amp;quot; as rawNumeric RETURN apoc.number.exact.mul(rawNumeric,&amp;quot;1000000&amp;quot;) AS apocConversion ╒════════════════╕ │&amp;quot;apocConversion&amp;quot;│ ╞════════════════╡ │&amp;quot;8370000.00&amp;quot; │ └────────────────┘ with &amp;quot;8.37&amp;quot; as rawNumeric RETURN toFloat(apoc.</description>
    </item>
    
    <item>
      <title>Docker: Building custom Neo4j images on Mac OS X</title>
      <link>https://markhneedham.com/blog/2017/07/26/docker-building-custom-neo4j-images-on-mac-os-x/</link>
      <pubDate>Wed, 26 Jul 2017 22:20:23 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/07/26/docker-building-custom-neo4j-images-on-mac-os-x/</guid>
      <description>I sometimes needs to create custom Neo4j Docker images to try things out and wanted to share my work flow, mostly for future Mark but also in case it&amp;rsquo;s useful to someone else.
There&amp;rsquo;s already a docker-neo4j repository so we&amp;rsquo;ll just tweak the files in there to achieve what we want.
$ git clone git@github.com:neo4j/docker-neo4j.git $ cd docker-neo4j If we want to build a Docker image for Neo4j Enterprise Edition we can run the following build target:</description>
    </item>
    
    <item>
      <title>Neo4j: apoc.date.parse - java.lang.IllegalArgumentException: Illegal pattern character &#39;T&#39; / java.text.ParseException: Unparseable date: &#34;2012-11-12T08:46:15Z&#34;</title>
      <link>https://markhneedham.com/blog/2017/03/06/neo4j-apoc-date-parse-java-lang-illegalargumentexception-illegal-pattern-character-t-java-text-parseexception-unparseable-date-2012-11-12t084615z/</link>
      <pubDate>Mon, 06 Mar 2017 20:52:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/03/06/neo4j-apoc-date-parse-java-lang-illegalargumentexception-illegal-pattern-character-t-java-text-parseexception-unparseable-date-2012-11-12t084615z/</guid>
      <description>return apoc.date.parse(&amp;quot;2012-11-12T08:46:15Z&amp;quot;,&#39;s&#39;) AS ts Failed to invoke function `apoc.date.parse`: Caused by: java.lang.IllegalArgumentException: java.text.ParseException: Unparseable date: &amp;quot;2012-11-12T08:46:15Z&amp;quot; return apoc.date.parse(&amp;quot;2012-11-12T08:46:15Z&amp;quot;,&#39;s&#39;,&amp;quot;yyyy-MM-ddTHH:mm:ssZ&amp;quot;) AS ts Failed to invoke function `apoc.date.parse`: Caused by: java.lang.IllegalArgumentException: Illegal pattern character &#39;T&#39; return apoc.date.parse(&amp;quot;2012-11-12T08:46:15Z&amp;quot;,&#39;s&#39;,&amp;quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssZ&amp;quot;) AS ts Failed to invoke function `apoc.date.parse`: Caused by: java.lang.IllegalArgumentException: java.text.ParseException: Unparseable date: &amp;quot;2012-11-12T08:46:15Z&amp;quot; return apoc.date.parse(&amp;quot;2012-11-12T08:46:15Z&amp;quot;,&#39;s&#39;,&amp;quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss&#39;Z&#39;&amp;quot;) AS ts ╒══════════╕ │&amp;quot;ts&amp;quot; │ ╞══════════╡ │1352709975│ └──────────┘ return apoc.date.parse(&amp;quot;2012-11-12T08:46:15Z&amp;quot;,&#39;s&#39;,&amp;quot;yyyy-MM-dd&#39;T&#39;HH:mm:ssXXX&amp;quot;) AS ts ╒══════════╕ │&amp;quot;ts&amp;quot; │ ╞══════════╡ │1352709975│ └──────────┘ </description>
    </item>
    
    <item>
      <title>Neo4j: Graphing the &#39;My name is...I work&#39; Twitter meme</title>
      <link>https://markhneedham.com/blog/2017/02/28/neo4j-graphing-name-work-twitter-meme/</link>
      <pubDate>Tue, 28 Feb 2017 15:50:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/02/28/neo4j-graphing-name-work-twitter-meme/</guid>
      <description>:param bearer: &#39;&amp;lt;your-bearer-token-goes-here&amp;gt;&#39; WITH &#39;https://api.twitter.com/1.1/search/tweets.json?count=100&amp;amp;result_type=recent&amp;amp;lang=en&amp;amp;q=&#39; as url, {bearer} as bearer CALL apoc.load.jsonParams(url + &amp;quot;%22my%20name%22%20is%22%20%22I%20work%22&amp;quot;,{Authorization:&amp;quot;Bearer &amp;quot;+bearer},null) yield value UNWIND value.statuses as status WITH status, status.user as u, status.entities as e WHERE status.quoted_status_id is not null // create a node for the original tweet MERGE (t:Tweet {id:status.id}) ON CREATE SET t.text=status.text,t.created_at=status.created_at,t.retweet_count=status.retweet_count, t.favorite_count=status.favorite_count // create a node for the author + a POSTED relationship from the author to the tweet MERGE (p:User {name:u.screen_name}) MERGE (p)-[:POSTED]-&amp;gt;(t) // create a MENTIONED relationship from the tweet to any users mentioned in the tweet FOREACH (m IN e.</description>
    </item>
    
    <item>
      <title>Neo4j: How do null values even work?</title>
      <link>https://markhneedham.com/blog/2017/02/22/neo4j-null-values-even-work/</link>
      <pubDate>Wed, 22 Feb 2017 23:28:23 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/02/22/neo4j-null-values-even-work/</guid>
      <description>WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value = null RETURN value (no changes, no records) WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value &amp;lt;&amp;gt; null RETURN value (no changes, no records) WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value RETURN value = null AS outcome ╒═══════╤═════════╕ │&amp;quot;value&amp;quot;│&amp;quot;outcome&amp;quot;│ ╞═══════╪═════════╡ │null │null │ ├───────┼─────────┤ │&amp;quot;null&amp;quot; │null │ ├───────┼─────────┤ │&amp;quot;&amp;quot; │null │ ├───────┼─────────┤ │&amp;quot;Mark&amp;quot; │null │ └───────┴─────────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value RETURN value = &amp;quot;Mark&amp;quot; AS outcome ╒═══════╤═════════╕ │&amp;quot;value&amp;quot;│&amp;quot;outcome&amp;quot;│ ╞═══════╪═════════╡ │null │null │ ├───────┼─────────┤ │&amp;quot;null&amp;quot; │false │ ├───────┼─────────┤ │&amp;quot;&amp;quot; │false │ ├───────┼─────────┤ │&amp;quot;Mark&amp;quot; │true │ └───────┴─────────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value is null RETURN value ╒═══════╕ │&amp;quot;value&amp;quot;│ ╞═══════╡ │null │ └───────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value is not null RETURN value ╒═══════╕ │&amp;quot;value&amp;quot;│ ╞═══════╡ │&amp;quot;null&amp;quot; │ ├───────┤ │&amp;quot;&amp;quot; │ ├───────┤ │&amp;quot;Mark&amp;quot; │ └───────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value &amp;lt;&amp;gt; &amp;quot;&amp;quot; RETURN value ╒═══════╕ │&amp;quot;value&amp;quot;│ ╞═══════╡ │&amp;quot;null&amp;quot; │ ├───────┤ │&amp;quot;Mark&amp;quot; │ └───────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value WITH value WHERE value = &amp;quot;&amp;quot; RETURN value ╒═══════╕ │&amp;quot;value&amp;quot;│ ╞═══════╡ │&amp;quot;&amp;quot; │ └───────┘ WITH [null, &amp;quot;null&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;Mark&amp;quot;] AS values UNWIND values AS value RETURN value, value = &amp;quot;&amp;quot; AS isEmpty, value &amp;lt;&amp;gt; &amp;quot;&amp;quot; AS isNotEmpty ╒═══════╤═════════╤════════════╕ │&amp;quot;value&amp;quot;│&amp;quot;isEmpty&amp;quot;│&amp;quot;isNotEmpty&amp;quot;│ ╞═══════╪═════════╪════════════╡ │null │null │null │ ├───────┼─────────┼────────────┤ │&amp;quot;null&amp;quot; │false │true │ ├───────┼─────────┼────────────┤ │&amp;quot;&amp;quot; │true │false │ ├───────┼─────────┼────────────┤ │&amp;quot;Mark&amp;quot; │false │true │ └───────┴─────────┴────────────┘ $ cat nulls.</description>
    </item>
    
    <item>
      <title>Neo4j: Analysing a CSV file using LOAD CSV and Cypher</title>
      <link>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</link>
      <pubDate>Sun, 19 Feb 2017 22:39:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2017/02/19/neo4j-analysing-csv-file-using-load-csv-cypher/</guid>
      <description>$ cat ~/Downloads/youtube_stats_pW9boJoUxO0.csv Video IDs:, pW9boJoUxO0, Start time:, Wed Feb 15 08:57:55 2017, End time:, Wed Feb 15 10:03:10 2017 Playbacks, Peak concurrent viewers, Total view time (hours), Average session length (minutes) 348, 112, 97.125, 16.7456896552, Country code, AR, AT, BE, BR, BY, CA, CH, CL, CR, CZ, DE, DK, EC, EE, ES, FI, FR, GB, HU, IE, IL, IN, IT, LB, LU, LV, MY, NL, NO, NZ, PK, PL, QA, RO, RS, RU, SE, TR, US, VN, ZA Playbacks, 2, 2, 1, 14, 1, 10, 2, 1, 1, 1, 27, 1, 1, 1, 3, 1, 25, 54, 1, 4, 6, 8, 1, 1, 1, 1, 1, 23, 1, 1, 1, 1, 1, 1, 2, 6, 22, 1, 114, 1, 1 Peak concurrent viewers, 2, 1, 1, 4, 1, 5, 1, 1, 0, 0, 11, 1, 1, 1, 2, 1, 6, 25, 1, 3, 3, 2, 1, 1, 1, 1, 1, 9, 1, 1, 0, 1, 0, 1, 1, 3, 7, 0, 44, 1, 0 Total view time (hours), 1.</description>
    </item>
    
    <item>
      <title>Neo4j: Graphing the ThoughtWorks Technology Radar</title>
      <link>https://markhneedham.com/blog/2016/12/23/neo4j-graphing-the-thoughtworks-technology-radar/</link>
      <pubDate>Fri, 23 Dec 2016 17:40:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/12/23/neo4j-graphing-the-thoughtworks-technology-radar/</guid>
      <description>|----------------------------------------------+----------+-------------| | technology | date | suggestion | |----------------------------------------------+----------+-------------| | AppHarbor | Mar 2012 | Trial | | Accumulate-only data | Nov 2015 | Assess | | Accumulate-only data | May 2015 | Assess | | Accumulate-only data | Jan 2015 | Assess | | Buying solutions you can only afford one of | Mar 2012 | Hold | |----------------------------------------------+----------+-------------| WITH [&amp;quot;Hold&amp;quot;, &amp;quot;Assess&amp;quot;, &amp;quot;Trial&amp;quot;, &amp;quot;Adopt&amp;quot;] AS positions UNWIND RANGE (0, size(positions) - 2) AS index WITH positions[index] AS pos1, positions[index + 1] AS pos2 MERGE (position1:Position {value: pos1}) MERGE (position2:Position {value: pos2}) MERGE (position1)-[:NEXT]-&amp;gt;(position2); load csv with headers from &amp;quot;file:///blips.</description>
    </item>
    
    <item>
      <title>Kubernetes: Simulating a network partition</title>
      <link>https://markhneedham.com/blog/2016/12/04/kubernetes-simulating-a-network-partition/</link>
      <pubDate>Sun, 04 Dec 2016 12:37:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/12/04/kubernetes-simulating-a-network-partition/</guid>
      <description>$ kubectl get pods NAME READY STATUS RESTARTS AGE neo4j-0 1/1 Running 0 6h neo4j-1 1/1 Running 0 6h neo4j-2 1/1 Running 0 6h $ kubectl exec neo4j-0 -- ls -alh /sbin/route lrwxrwxrwx 1 root root 12 Oct 18 18:58 /sbin/route -&amp;gt; /bin/busybox $ kubectl exec neo4j-0 -- bin/cypher-shell &amp;#34;CALL dbms.cluster.role()&amp;#34; role &amp;#34;FOLLOWER&amp;#34; Bye! $ kubectl exec neo4j-1 -- bin/cypher-shell &amp;#34;CALL dbms.cluster.role()&amp;#34; role &amp;#34;FOLLOWER&amp;#34; Bye! $ kubectl exec neo4j-2 -- bin/cypher-shell &amp;#34;CALL dbms.</description>
    </item>
    
    <item>
      <title>Kubernetes: Spinning up a Neo4j 3.1 Causal Cluster</title>
      <link>https://markhneedham.com/blog/2016/11/25/kubernetes-spinning-up-a-neo4j-3-1-causal-cluster/</link>
      <pubDate>Fri, 25 Nov 2016 16:55:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/11/25/kubernetes-spinning-up-a-neo4j-3-1-causal-cluster/</guid>
      <description>for i in $(seq 0 2); do cat &amp;lt;&amp;lt;EOF | kubectl create -f - kind: PersistentVolume apiVersion: v1 metadata: name: pv${i} labels: type: local app: neo4j spec: capacity: storage: 1Gi accessModes: - ReadWriteOnce hostPath: path: &amp;#34;/tmp/${i}&amp;#34; EOF cat &amp;lt;&amp;lt;EOF | kubectl create -f - kind: PersistentVolumeClaim apiVersion: v1 metadata: name: datadir-neo4j-${i} labels: app: neo4j spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi EOF done; $ kubectl get pv NAME CAPACITY ACCESSMODES STATUS CLAIM REASON AGE pv0 1Gi RWO Bound default/datadir-neo4j-0 7s pv1 1Gi RWO Bound default/datadir-neo4j-1 7s pv2 1Gi RWO Bound default/datadir-neo4j-2 7s $ kubectl get pvc NAME STATUS VOLUME CAPACITY ACCESSMODES AGE datadir-neo4j-0 Bound pv0 1Gi RWO 26s datadir-neo4j-1 Bound pv1 1Gi RWO 26s datadir-neo4j-2 Bound pv2 1Gi RWO 25s # Headless service to provide DNS lookup apiVersion: v1 kind: Service metadata: labels: app: neo4j name: neo4j spec: clusterIP: None ports: - port: 7474 selector: app: neo4j ---- # new API name apiVersion: &amp;#34;apps/v1alpha1&amp;#34; kind: PetSet metadata: name: neo4j spec: serviceName: neo4j replicas: 3 template: metadata: annotations: pod.</description>
    </item>
    
    <item>
      <title>Neo4j 3.1 beta3 &#43; docker: Creating a Causal Cluster</title>
      <link>https://markhneedham.com/blog/2016/11/13/neo4j-3-1-beta3-docker-creating-a-causal-cluster/</link>
      <pubDate>Sun, 13 Nov 2016 12:30:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/11/13/neo4j-3-1-beta3-docker-creating-a-causal-cluster/</guid>
      <description>unsupported.dbms.edition=enterprise dbms.mode=CORE dbms.security.auth_enabled=false dbms.memory.heap.initial_size=512m dbms.memory.heap.max_size=512m dbms.memory.pagecache.size=100M dbms.tx_log.rotation.retention_policy=false dbms.connector.bolt.type=BOLT dbms.connector.bolt.enabled=true dbms.connector.bolt.listen_address=0.0.0.0:7687 dbms.connector.http.type=HTTP dbms.connector.http.enabled=true dbms.connector.http.listen_address=0.0.0.0:7474 dbms.connectors.default_listen_address=0.0.0.0 dbms.connectors.default_advertised_address=instance0 causal_clustering.initial_discovery_members=instance0:5000,instance1:5000,instance2:5000 causal_clustering.leader_election_timeout=2s docker run --name=instance0 --detach \  --publish=7474:7474 \  --publish=7687:7687 \  --net=cluster \  --hostname=instance0 \  --volume /tmp/ce/instance0/conf:/conf \  --volume /tmp/ce/instance0/data:/data \  neo4j/neo4j-experimental:3.1.0-M13-beta3-enterprise docker network create --driver=bridge cluster function config { mkdir -p /tmp/ce/$1/conf cat &amp;gt; /tmp/ce/$1/conf/neo4j.conf &amp;lt;&amp;lt; EOF unsupported.dbms.edition=enterprise dbms.mode=CORE dbms.security.auth_enabled=false dbms.memory.heap.initial_size=512m dbms.memory.heap.max_size=512m dbms.memory.pagecache.size=100M dbms.tx_log.rotation.retention_policy=false dbms.connector.bolt.type=BOLT dbms.connector.bolt.enabled=true dbms.connector.bolt.listen_address=0.0.0.0:7687 dbms.</description>
    </item>
    
    <item>
      <title>Neo4j: Find the intermediate point between two lat/longs</title>
      <link>https://markhneedham.com/blog/2016/11/01/neo4j-find-the-intermediate-point-between-two-latlongs/</link>
      <pubDate>Tue, 01 Nov 2016 22:10:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/11/01/neo4j-find-the-intermediate-point-between-two-latlongs/</guid>
      <description>(a)-[:NEXT {time: 60}]-&amp;gt;(b)-[:NEXT {time: 240}]-&amp;gt;(c) a = sin((1−f)⋅δ) / sin δ b = sin(f⋅δ) / sin δ x = a ⋅ cos φ1 ⋅ cos λ1 + b ⋅ cos φ2 ⋅ cos λ2 y = a ⋅ cos φ1 ⋅ sin λ1 + b ⋅ cos φ2 ⋅ sin λ2 z = a ⋅ sin φ1 + b ⋅ sin φ2 φi = atan2(z, √x² + y²) λi = atan2(y, x) δ is the angular distance d/R between the two points.</description>
    </item>
    
    <item>
      <title>Neo4j: Find the midpoint between two lat/longs</title>
      <link>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</link>
      <pubDate>Mon, 31 Oct 2016 19:31:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/31/neo4j-find-the-midpoint-between-two-latlongs/</guid>
      <description>WITH 51.4931963543 AS lat1, -0.0475185810 AS lon1, 51.47908 AS lat2 , -0.05393950 AS lon2 WITH radians(lat1) AS rlat1, radians(lon1) AS rlon1, radians(lat2) AS rlat2, radians(lon2) AS rlon2, radians(lon2 - lon1) AS dLon WITH rlat1, rlon1, rlat2, rlon2, cos(rlat2) * cos(dLon) AS Bx, cos(rlat2) * sin(dLon) AS By WITH atan2(sin(rlat1) + sin(rlat2), sqrt( (cos(rlat1) + Bx) * (cos(rlat1) + Bx) + By * By )) AS lat3, rlon1 + atan2(By, cos(rlat1) + Bx) AS lon3 RETURN degrees(lat3) AS midLat, degrees(lon3) AS midLon ╒═════════════════╤═════════════════════╕ │midLat │midLon │ ╞═════════════════╪═════════════════════╡ │51.</description>
    </item>
    
    <item>
      <title>Neo4j: Create dynamic relationship type</title>
      <link>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</link>
      <pubDate>Sun, 30 Oct 2016 22:12:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/30/neo4j-create-dynamic-relationship-type/</guid>
      <description>load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row RETURN row ╒═══════════════════════════════════════════════════════╕ │row │ ╞═══════════════════════════════════════════════════════╡ │{node1: Mark, node2: Reshmee, relationship: MARRIED_TO}│ ├───────────────────────────────────────────────────────┤ │{node1: Mark, node2: Alistair, relationship: FRIENDS} │ └───────────────────────────────────────────────────────┘ load csv with headers from &amp;quot;file:///people.csv&amp;quot; AS row MERGE (p1:Person {name: row.node1}) MERGE (p2:Person {name: row.node2}) FOREACH(ignoreMe IN CASE WHEN row.relationship = &amp;quot;MARRIED_TO&amp;quot; THEN [1] ELSE [] END | MERGE (p1)-[:MARRIED_TO]-&amp;gt;(p2)) FOREACH(ignoreMe IN CASE WHEN row.relationship = &amp;quot;FRIENDS&amp;quot; THEN [1] ELSE [] END | MERGE (p1)-[:FRIENDS]-&amp;gt;(p2)) load csv with headers from &amp;quot;file:///people.</description>
    </item>
    
    <item>
      <title>Neo4j: Dynamically add property/Set dynamic property</title>
      <link>https://markhneedham.com/blog/2016/10/27/neo4j-dynamically-add-property/</link>
      <pubDate>Thu, 27 Oct 2016 05:29:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/27/neo4j-dynamically-add-property/</guid>
      <description>CREATE (stop:Stop {arrival: &amp;quot;0802&amp;quot;, departure: &amp;quot;0803H&amp;quot;}) MATCH (stop:Stop) UNWIND [&amp;quot;arrival&amp;quot;, &amp;quot;departure&amp;quot;] AS key WITH key, toInteger(substring(stop[key], 0, 2)) AS hours, toInteger(substring(stop[key], 2, 2)) AS minutes, CASE WHEN substring(stop[key], 4,1) = &amp;quot;H&amp;quot; THEN 30 ELSE 0 END AS seconds WITH key, (hours * 60 * 60) + (minutes * 60) + seconds AS secondsSinceStartOfDay RETURN key + &amp;quot;SecondsSinceStartOfDay&amp;quot; AS newKey, secondsSinceStartOfDay ╒═══════════════════════════════╤══════════════════════╕ │newKey │secondsSinceStartOfDay│ ╞═══════════════════════════════╪══════════════════════╡ │arrivalSecondsSinceStartOfDay │28920 │ ├───────────────────────────────┼──────────────────────┤ │departureSecondsSinceStartOfDay│29010 │ └───────────────────────────────┴──────────────────────┘ MATCH (stop:Stop2) UNWIND [&amp;quot;arrival&amp;quot;, &amp;quot;departure&amp;quot;] AS key WITH stop, key, toInteger(substring(stop[key], 0, 2)) AS hours, toInteger(substring(stop[key], 2, 2)) AS minutes, CASE WHEN substring(stop[key], 4,1) = &amp;quot;H&amp;quot; THEN 30 ELSE 0 END AS seconds WITH stop, key, (hours * 60 * 60) + (minutes * 60) + seconds AS secondsSinceStartOfDay WITH stop, key + &amp;quot;SecondsSinceStartOfDay&amp;quot; AS newKey, secondsSinceStartOfDay SET stop[newKey] = secondsSinceStartOfDay Invalid input &amp;#39;[&amp;#39;: expected an identifier character, whitespace, &amp;#39;{&amp;#39;, node labels, a property map, a relationship pattern, &amp;#39;.</description>
    </item>
    
    <item>
      <title>Neo4j: Detecting rogue spaces in CSV headers with LOAD CSV</title>
      <link>https://markhneedham.com/blog/2016/10/19/neo4j-detecting-rogue-spaces-in-csv-headers-with-load-csv/</link>
      <pubDate>Wed, 19 Oct 2016 05:16:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/19/neo4j-detecting-rogue-spaces-in-csv-headers-with-load-csv/</guid>
      <description>load csv with headers from &amp;quot;file:///foo.csv&amp;quot; as row RETURN row ╒══════════════════════════════════╕ │row │ ╞══════════════════════════════════╡ │{key1: a, key2: (null), key3: c}│ ├──────────────────────────────────┤ │{key1: d, key2: e, key3: f} │ └──────────────────────────────────┘ load csv with headers from &amp;quot;file:///foo.csv&amp;quot; as row WITH row WHERE NOT row.key2 is null RETURN row (no rows) load csv with headers from &amp;quot;file:///foo.csv&amp;quot; as row WITH row LIMIT 1 UNWIND keys(row) AS key RETURN key, SIZE(key) ╒═════╤═════════╕ │key │SIZE(key)│ ╞═════╪═════════╡ │key1 │4 │ ├─────┼─────────┤ │ key2│5 │ ├─────┼─────────┤ │ key3│5 │ └─────┴─────────┘ load csv with headers from &amp;quot;file:///foo.</description>
    </item>
    
    <item>
      <title>Neo4j: requirement failed</title>
      <link>https://markhneedham.com/blog/2016/10/04/neo4j-requirement-failed/</link>
      <pubDate>Tue, 04 Oct 2016 22:33:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/04/neo4j-requirement-failed/</guid>
      <description>MATCH (p:Person)-[:ACTED_IN]-&amp;gt;(movie) RETURN p, COLLECT(movie.title) AS movies ORDER BY COUNT(movies) DESC LIMIT 10 requirement failed 2016-10-03 23:25:07.529+0000 ERROR [o.n.b.v.r.ErrorReporter] Client triggered an unexpected error [UnknownError]: requirement failed, reference to. requirement failed java.lang.IllegalArgumentException: requirement failed at scala.Predef$.require(Predef.scala:212) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.steps.sortSkipAndLimit$.apply(sortSkipAndLimit.scala:38) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanEventHorizon$.apply(PlanEventHorizon.scala:43) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanEventHorizon$.apply(PlanEventHorizon.scala:31) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanWithTail.apply(PlanWithTail.scala:46) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanWithTail.apply(PlanWithTail.scala:29) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanSingleQuery.apply(PlanSingleQuery.scala:47) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.PlanSingleQuery.apply(PlanSingleQuery.scala:30) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.DefaultQueryPlanner$$anonfun$2.apply(QueryPlanner.scala:51) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.DefaultQueryPlanner$$anonfun$2.apply(QueryPlanner.scala:51) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:234) at scala.collection.immutable.List.foreach(List.scala:381) at scala.collection.TraversableLike$class.map(TraversableLike.scala:234) at scala.collection.immutable.List.map(List.scala:285) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.DefaultQueryPlanner.planQueries(QueryPlanner.scala:51) at org.neo4j.cypher.internal.compiler.v3_1.planner.logical.DefaultQueryPlanner.plan(QueryPlanner.scala:36) at org.neo4j.cypher.internal.compiler.v3_1.planner.CostBasedExecutablePlanBuilder.produceLogicalPlan(CostBasedExecutablePlanBuilder.scala:95) at org.</description>
    </item>
    
    <item>
      <title>Neo4j: Procedure call inside a query does not support passing arguments implicitly (pass explicitly after procedure name instead)</title>
      <link>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</link>
      <pubDate>Sun, 02 Oct 2016 10:13:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/10/02/neo4j-procedure-call-inside-a-query-does-not-support-passing-arguments-implicitly-pass-explicitly-after-procedure-name-instead/</guid>
      <description>CALL db.labels ╒══════════╕ │label │ ╞══════════╡ │Airport │ ├──────────┤ │Flight │ ├──────────┤ │Airline │ ├──────────┤ │Movie │ ├──────────┤ │AirportDay│ ├──────────┤ │Person │ ├──────────┤ │Engineer │ └──────────┘ CALL db.labels YIELD label WITH label WHERE tolower(label) contains &amp;quot;a&amp;quot; RETURN label Procedure call inside a query does not support passing arguments implicitly (pass explicitly after procedure name instead) (line 1, column 9 (offset: 8)) &amp;#34;CALL db.labels&amp;#34; ^ CALL db.labels() YIELD label WITH label WHERE tolower(label) contains &amp;quot;a&amp;quot; RETURN label ╒══════════╕ │label │ ╞══════════╡ │Airport │ ├──────────┤ │Airline │ ├──────────┤ │AirportDay│ └──────────┘ </description>
    </item>
    
    <item>
      <title>Neo4j/scikit-learn: Calculating the cosine similarity of Game of Thrones episodes</title>
      <link>https://markhneedham.com/blog/2016/08/22/neo4jscikit-learn-calculating-the-cosine-similarity-of-game-of-thrones-episodes/</link>
      <pubDate>Mon, 22 Aug 2016 21:12:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/08/22/neo4jscikit-learn-calculating-the-cosine-similarity-of-game-of-thrones-episodes/</guid>
      <description>:play http://guides.neo4j.com/got Episode 1 = [1, 1, 0] Episode 2 = [0, 1, 1] &amp;gt;&amp;gt;&amp;gt; from sklearn.metrics.pairwise import cosine_similarity &amp;gt;&amp;gt;&amp;gt; one = [1,1,0] &amp;gt;&amp;gt;&amp;gt; two = [0,1,1] &amp;gt;&amp;gt;&amp;gt; cosine_similarity([one, two]) array([[ 1. , 0.5], [ 0.5, 1. ]]) from neo4j.v1 import GraphDatabase, basic_auth driver = GraphDatabase.driver(&amp;#34;bolt://localhost&amp;#34;, auth=basic_auth(&amp;#34;neo4j&amp;#34;, &amp;#34;neo&amp;#34;)) session = driver.session() rows = session.run(&amp;#34;&amp;#34;&amp;#34; MATCH (c:Character), (e:Episode) OPTIONAL MATCH (c)-[appearance:APPEARED_IN]-&amp;gt;(e) RETURN e, c, appearance ORDER BY e.id, c.id&amp;#34;&amp;#34;&amp;#34;) &amp;gt;&amp;gt;&amp;gt; for row in rows: print row &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5415 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Addam Marbrand&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Addam_Marbrand&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5882 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Adrack Humble&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Adrack_Humble&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=6747 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Aegon V Targaryen&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Aegon_V_Targaryen&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5750 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Aemon&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Aemon&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5928 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Aeron Greyjoy&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Aeron_Greyjoy&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5503 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Aerys II Targaryen&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Aerys_II_Targaryen&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=6753 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Alannys Greyjoy&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Alannys_Greyjoy&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=6750 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Alerie Tyrell&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Alerie_Tyrell&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5753 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Alliser Thorne&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Alliser_Thorne&amp;#39;}&amp;gt; appearance=None&amp;gt; &amp;lt;Record e=&amp;lt;Node id=6780 labels=set([u&amp;#39;Episode&amp;#39;]) properties={u&amp;#39;season&amp;#39;: 1, u&amp;#39;number&amp;#39;: 1, u&amp;#39;id&amp;#39;: 1, u&amp;#39;title&amp;#39;: u&amp;#39;Winter Is Coming&amp;#39;}&amp;gt; c=&amp;lt;Node id=5858 labels=set([u&amp;#39;Character&amp;#39;]) properties={u&amp;#39;name&amp;#39;: u&amp;#39;Alton Lannister&amp;#39;, u&amp;#39;id&amp;#39;: u&amp;#39;/wiki/Alton_Lannister&amp;#39;}&amp;gt; appearance=None&amp;gt; episodes = {} for row in rows: if episodes.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Detecting duplicates using relationships</title>
      <link>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</link>
      <pubDate>Wed, 20 Jul 2016 17:32:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/07/20/neo4j-cypher-detecting-duplicates-using-relationships/</guid>
      <description>MATCH (r:Resource {id: &amp;quot;168640&amp;quot;})-[:REFERENCES]-&amp;gt;(other) WITH r, COLLECT(other) as myReferences UNWIND myReferences AS reference OPTIONAL MATCH path = (other)-[:REFERENCES]-&amp;gt;(reference) WITH other, COUNT(path) AS otherReferences, SIZE(myReferences) AS myReferences WITH other, 1.0 * otherReferences / myReferences AS similarity WHERE similarity &amp;gt; 0.5 RETURN other.id, other.title, similarity ORDER BY similarity DESC LIMIT 10 ╒════════╤═══════════════════════════════════════════╤══════════╕ │other.id│other.title │similarity│ ╞════════╪═══════════════════════════════════════════╪══════════╡ │168640 │Authentication in the Taos operating system│1 │ ├────────┼───────────────────────────────────────────┼──────────┤ │174614 │Authentication in the Taos operating system│1 │ └────────┴───────────────────────────────────────────┴──────────┘ ╒════════╤════════════════════════════════════════════════════════════════╤══════════════════╕ │other.</description>
    </item>
    
    <item>
      <title>Neo4j 3.0 Drivers - Failed to save the server ID and the certificate received from the server</title>
      <link>https://markhneedham.com/blog/2016/07/11/neo4j-3-0-drivers-failed-to-save-the-server-id-and-the-certificate-received-from-the-server/</link>
      <pubDate>Mon, 11 Jul 2016 05:21:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/07/11/neo4j-3-0-drivers-failed-to-save-the-server-id-and-the-certificate-received-from-the-server/</guid>
      <description>org.neo4j.driver.v1.exceptions.ClientException: Unable to process request: General SSLEngine problem at org.neo4j.driver.internal.connector.socket.SocketClient.start(SocketClient.java:88) at org.neo4j.driver.internal.connector.socket.SocketConnection.&amp;lt;init&amp;gt;(SocketConnection.java:63) at org.neo4j.driver.internal.connector.socket.SocketConnector.connect(SocketConnector.java:52) at org.neo4j.driver.internal.pool.InternalConnectionPool.acquire(InternalConnectionPool.java:113) at org.neo4j.driver.internal.InternalDriver.session(InternalDriver.java:53) Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem at sun.security.ssl.Handshaker.checkThrown(Handshaker.java:1431) at sun.security.ssl.SSLEngineImpl.checkTaskThrown(SSLEngineImpl.java:535) at sun.security.ssl.SSLEngineImpl.writeAppRecord(SSLEngineImpl.java:1214) at sun.security.ssl.SSLEngineImpl.wrap(SSLEngineImpl.java:1186) at javax.net.ssl.SSLEngine.wrap(SSLEngine.java:469) at org.neo4j.driver.internal.connector.socket.TLSSocketChannel.wrap(TLSSocketChannel.java:270) at org.neo4j.driver.internal.connector.socket.TLSSocketChannel.runHandshake(TLSSocketChannel.java:131) at org.neo4j.driver.internal.connector.socket.TLSSocketChannel.&amp;lt;init&amp;gt;(TLSSocketChannel.java:95) at org.neo4j.driver.internal.connector.socket.TLSSocketChannel.&amp;lt;init&amp;gt;(TLSSocketChannel.java:77) at org.neo4j.driver.internal.connector.socket.TLSSocketChannel.&amp;lt;init&amp;gt;(TLSSocketChannel.java:70) at org.neo4j.driver.internal.connector.socket.SocketClient$ChannelFactory.create(SocketClient.java:251) at org.neo4j.driver.internal.connector.socket.SocketClient.start(SocketClient.java:75) ... 14 more Caused by: javax.net.ssl.SSLHandshakeException: General SSLEngine problem at sun.security.ssl.Alerts.getSSLException(Alerts.java:192) at sun.security.ssl.SSLEngineImpl.fatal(SSLEngineImpl.java:1728) at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:304) at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:296) at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:1497) at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:212) at sun.</description>
    </item>
    
    <item>
      <title>Neo4j vs Relational: Refactoring - Extracting node/table</title>
      <link>https://markhneedham.com/blog/2016/05/22/neo4j-vs-relational-refactoring-extracting-nodetable/</link>
      <pubDate>Sun, 22 May 2016 09:58:38 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/05/22/neo4j-vs-relational-refactoring-extracting-nodetable/</guid>
      <description>CREATE TABLE countries ( &amp;#34;code&amp;#34; character varying(3) NOT NULL PRIMARY KEY, &amp;#34;name&amp;#34; character varying(50) NOT NULL ); INSERT INTO countries VALUES(&amp;#39;MNE&amp;#39;, &amp;#39;Montenegro&amp;#39;); INSERT INTO countries VALUES(&amp;#39;SWZ&amp;#39;, &amp;#39;Swaziland&amp;#39;); ... ALTER TABLE clubs ADD COLUMN country_id character varying(3) REFERENCES countries(code); UPDATE clubs AS cl SET country_id = c.code FROM clubs INNER JOIN countries AS c ON c.name = clubs.country WHERE cl.id = clubs.id; ALTER TABLE clubs DROP COLUMN country; ALTER TABLE players ADD COLUMN country_id character varying(3) REFERENCES countries(code); UPDATE players AS p SET country_id = c.</description>
    </item>
    
    <item>
      <title>Neo4j vs Relational: Refactoring - Add a new field/property</title>
      <link>https://markhneedham.com/blog/2016/05/22/neo4j-vs-relational-refactoring-add-a-new-fieldproperty/</link>
      <pubDate>Sun, 22 May 2016 09:09:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/05/22/neo4j-vs-relational-refactoring-add-a-new-fieldproperty/</guid>
      <description>RelationalGraphALTER TABLE players ADD COLUMN nationality varying(30); UPDATE players SET nationality = &amp;#39;Brazil&amp;#39; WHERE players.id = &amp;#39;/aldair/profil/spieler/4151&amp;#39;; ... USING PERIODIC COMMIT LOAD CSV WITH HEADERS FROM &amp;quot;file:///transfers.csv&amp;quot; AS row MATCH (player:Player {id: row.playerUri}) SET player.nationality = row.playerNationality ALTER TABLE players ALTER COLUMN nationality SET NOT NULL CREATE CONSTRAINT ON (player:Player) ASSERT exists(player.nationality) </description>
    </item>
    
    <item>
      <title>Neo4j: A procedure for the SLM clustering algorithm</title>
      <link>https://markhneedham.com/blog/2016/02/28/neo4j-a-procedure-for-the-slm-clustering-algorithm/</link>
      <pubDate>Sun, 28 Feb 2016 20:40:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/02/28/neo4j-a-procedure-for-the-slm-clustering-algorithm/</guid>
      <description>LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/slm/karate_club_network.txt&amp;quot; as row FIELDTERMINATOR &amp;quot;\t&amp;quot; MERGE (person1:Person {id: row[0]}) MERGE (person2:Person {id: row[1]}) MERGE (person1)-[:KNOWS]-&amp;gt;(person2) public class ClusterAllTheThings { @Context public org.neo4j.graphdb.GraphDatabaseService db; @Procedure @PerformsWrites public Stream&amp;lt;Cluster&amp;gt; knows() throws IOException { String query = &amp;#34;MATCH (person1:Person)-[r:KNOWS]-&amp;gt;(person2:Person) \n&amp;#34; + &amp;#34;RETURN person1.id AS p1, person2.id AS p2, toFloat(1) AS weight&amp;#34;; Result rows = db.execute( query ); ModularityOptimizer.ModularityFunction modularityFunction = ModularityOptimizer.ModularityFunction.Standard; Network network = Network.create( modularityFunction, rows ); double resolution = 1.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - avoid duplicate calls to NOT patterns</title>
      <link>https://markhneedham.com/blog/2016/01/17/neo4j-cypher-avoid-duplicate-calls-to-not-patterns/</link>
      <pubDate>Sun, 17 Jan 2016 12:19:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2016/01/17/neo4j-cypher-avoid-duplicate-calls-to-not-patterns/</guid>
      <description>MATCH (member:Member {name: &amp;quot;Mark Needham&amp;quot;})-[:MEMBER_OF]-&amp;gt;(group:Group)&amp;lt;-[:MEMBER_OF]-(other:Member)-[:MEMBER_OF]-&amp;gt;(otherGroup:Group) RETURN otherGroup, COUNT(*) AS commonMembers ORDER BY commonMembers DESC LIMIT 5 Cypher version: CYPHER 2.3, planner: COST. 1084378 total db hits in 1103 ms. MATCH (member:Member {name: &amp;quot;Mark Needham&amp;quot;})-[:MEMBER_OF]-&amp;gt;(group:Group)&amp;lt;-[:MEMBER_OF]-(other:Member)-[:MEMBER_OF]-&amp;gt;(otherGroup:Group) WHERE NOT (member)-[:MEMBER_OF]-&amp;gt;(otherGroup) RETURN otherGroup, COUNT(*) AS commonMembers ORDER BY commonMembers DESC LIMIT 5 Cypher version: CYPHER 2.3, planner: COST. 14061442 total db hits in 3364 ms. When following longer paths, you’ll encounter duplicates. If you’re not interested in all the possible paths– but just distinct information from stages of the path – make sure that you eagerly eliminate duplicates, so that later matches don’t have to be executed many multiple times.</description>
    </item>
    
    <item>
      <title>2015: A year in the life of the Neo4j London meetup group</title>
      <link>https://markhneedham.com/blog/2015/12/31/2015-a-year-in-the-life-of-the-neo4j-london-meetup-group/</link>
      <pubDate>Thu, 31 Dec 2015 13:58:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/12/31/2015-a-year-in-the-life-of-the-neo4j-london-meetup-group/</guid>
      <description>library(RNeo4j) library(ggplot2) library(dplyr) library(zoo) graph = startGraph(&amp;#34;http://localhost:7474/db/data/&amp;#34;, username = &amp;#34;neo4j&amp;#34;, password = &amp;#34;myPassword&amp;#34;) query = &amp;#34;MATCH (:Group {name: {name}})&amp;lt;-[membership:MEMBER_OF]-() RETURN membership.joined AS timestamp&amp;#34; joinedDF = cypher(graph, query, name = &amp;#34;Neo4j - London User Group&amp;#34;) joinedDF$joinDate = as.Date(as.POSIXct(joinedDF$timestamp / 1000, origin=&amp;#34;1970-01-01&amp;#34;)) joinedDF$joinDate = as.Date(as.POSIXct(joinedDF$timestamp / 1000, origin=&amp;#34;1970-01-01&amp;#34;)) ggplot(aes(x = year, y = n, label = n), data = joinedDF %&amp;gt;% mutate(year = format(joinDate, &amp;#34;%Y&amp;#34;)) %&amp;gt;% count(year)) + geom_bar(stat = &amp;#34;identity&amp;#34;, fill = &amp;#34;Dark Blue&amp;#34;) + ggtitle(&amp;#34;Number of new members by year&amp;#34;) + geom_text(vjust=-0.</description>
    </item>
    
    <item>
      <title>Neo4j: Specific relationship vs Generic relationship &#43; property</title>
      <link>https://markhneedham.com/blog/2015/12/13/neo4j-specific-relationship-vs-generic-relationship-property/</link>
      <pubDate>Sun, 13 Dec 2015 21:22:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/12/13/neo4j-specific-relationship-vs-generic-relationship-property/</guid>
      <description>MATCH (member:Member {name: &amp;quot;Mark Needham&amp;quot;}) MATCH (futureEvent:Event) WHERE futureEvent.time &amp;gt;= timestamp() MATCH (futureEvent)&amp;lt;-[:HOSTED_EVENT]-(group) OPTIONAL MATCH (member)-[rsvp:RSVPD {response: &amp;quot;yes&amp;quot;}]-&amp;gt;(pastEvent)&amp;lt;-[:HOSTED_EVENT]-(group) WHERE pastEvent.time &amp;lt; timestamp() RETURN group.name, futureEvent.name, COUNT(rsvp) AS previousEvents ORDER BY previousEvents DESC MATCH (member:Member {name: &amp;quot;Mark Needham&amp;quot;}) MATCH (futureEvent:Event) WHERE futureEvent.time &amp;gt;= timestamp() MATCH (futureEvent)&amp;lt;-[:HOSTED_EVENT]-(group) OPTIONAL MATCH (member)-[rsvp:RSVP_YES]-&amp;gt;(pastEvent)&amp;lt;-[:HOSTED_EVENT]-(group) WHERE pastEvent.time &amp;lt; timestamp() RETURN group.name, futureEvent.name, COUNT(rsvp) AS previousEvents ORDER BY previousEvents DESC RSVPD {response: &amp;#34;yes&amp;#34;} Cypher version: CYPHER 2.3, planner: COST.</description>
    </item>
    
    <item>
      <title>Neo4j: Facts as nodes</title>
      <link>https://markhneedham.com/blog/2015/12/04/neo4j-facts-as-nodes/</link>
      <pubDate>Fri, 04 Dec 2015 07:52:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/12/04/neo4j-facts-as-nodes/</guid>
      <description>Modeling an action in terms of its product—that is, in terms of the thing that results from the action—produces a similar structure: an intermediate node that represents the outcome of an interaction between two or more entities.
MATCH (member:Member {name: &amp;quot;Mark Needham&amp;quot;})-[:MEMBER_OF]-&amp;gt;(group)-[:HAS_TOPIC]-&amp;gt;(topic) WITH member, topic, COUNT(*) AS score MATCH (topic)&amp;lt;-[:HAS_TOPIC]-(otherGroup) WHERE NOT (member)-[:MEMBER_OF]-&amp;gt;(otherGroup) RETURN otherGroup.name, COLLECT(topic.name), SUM(score) as score ORDER BY score DESC Cypher version: CYPHER 2.3, planner: COST. 89100 total db hits in 113 ms.</description>
    </item>
    
    <item>
      <title>Neo4j: Summarising neo4j-shell output</title>
      <link>https://markhneedham.com/blog/2015/08/21/neo4j-summarising-neo4j-shell-output/</link>
      <pubDate>Fri, 21 Aug 2015 20:59:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/08/21/neo4j-summarising-neo4j-shell-output/</guid>
      <description>I frequently find myself trying to optimise a set of cypher queries and I tend to group them together in a script that I fed to the Neo4j shell.
import re import sys from tabulate import tabulate lines = sys.stdin.readlines() def search(term, line): m = re.match(term + &amp;#34;: (.*)&amp;#34;, line) return (int(m.group(1)) if m else 0) nodes_created, relationships_created, constraints_added, indexes_added, labels_added, properties_set = 0, 0, 0, 0, 0, 0 for line in lines: nodes_created = nodes_created + search(&amp;#34;Nodes created&amp;#34;, line) relationships_created = relationships_created + search(&amp;#34;Relationships created&amp;#34;, line) constraints_added = constraints_added + search(&amp;#34;Constraints added&amp;#34;, line) indexes_added = indexes_added + search(&amp;#34;Indexes added&amp;#34;, line) labels_added = labels_added + search(&amp;#34;Labels added&amp;#34;, line) properties_set = properties_set + search(&amp;#34;Properties set&amp;#34;, line) time_match = re.</description>
    </item>
    
    <item>
      <title>Neo4j 2.2.3: Unmanaged extensions - Creating gzipped streamed responses with Jetty</title>
      <link>https://markhneedham.com/blog/2015/08/10/neo4j-2-2-3-unmanaged-extensions-creating-gzipped-streamed-responses-with-jetty/</link>
      <pubDate>Mon, 10 Aug 2015 23:57:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/08/10/neo4j-2-2-3-unmanaged-extensions-creating-gzipped-streamed-responses-with-jetty/</guid>
      <description>@Path(&amp;#34;/example&amp;#34;) public class ExampleResource { private final GraphDatabaseService db; private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); public ExampleResource(@Context GraphDatabaseService db) { this.db = db; } @GET @Produces(MediaType.APPLICATION_JSON) @Path(&amp;#34;/people&amp;#34;) public Response allNodes() throws IOException { StreamingOutput stream = streamQueryResponse(&amp;#34;MATCH (n:Person) RETURN n.name AS name&amp;#34;); return Response.ok().entity(stream).type(MediaType.APPLICATION_JSON).build(); } private StreamingOutput streamQueryResponse(final String query) { return new StreamingOutput() { @Override public void write(OutputStream os) throws IOException, WebApplicationException { JsonGenerator jg = OBJECT_MAPPER.getJsonFactory().createJsonGenerator(os, JsonEncoding.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Removing consecutive duplicates</title>
      <link>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</link>
      <pubDate>Thu, 30 Jul 2015 06:23:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/30/neo4j-cypher-removing-consecutive-duplicates/</guid>
      <description>RETURN [1,1,2,3,4,5,6,7,7,8] AS values ==&amp;gt; +-----------------------+ ==&amp;gt; | values | ==&amp;gt; +-----------------------+ ==&amp;gt; | [1,1,2,3,4,5,6,7,7,8] | ==&amp;gt; +-----------------------+ ==&amp;gt; 1 row WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx RETURN idx, idx+1, values[idx], values[idx+1] ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | idx | idx+1 | values[idx] | values[idx+1] | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | 0 | 1 | 1 | 1 | ==&amp;gt; | 1 | 2 | 1 | 2 | ==&amp;gt; | 2 | 3 | 2 | 3 | ==&amp;gt; | 3 | 4 | 3 | 4 | ==&amp;gt; | 4 | 5 | 4 | 5 | ==&amp;gt; | 5 | 6 | 5 | 6 | ==&amp;gt; | 6 | 7 | 6 | 7 | ==&amp;gt; | 7 | 8 | 7 | 7 | ==&amp;gt; | 8 | 9 | 7 | 8 | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; 9 rows WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN a,b ==&amp;gt; +-------+ ==&amp;gt; | a | b | ==&amp;gt; +-------+ ==&amp;gt; | 1 | 2 | ==&amp;gt; | 2 | 3 | ==&amp;gt; | 3 | 4 | ==&amp;gt; | 4 | 5 | ==&amp;gt; | 5 | 6 | ==&amp;gt; | 6 | 7 | ==&amp;gt; | 7 | 8 | ==&amp;gt; +-------+ ==&amp;gt; 7 rows WITH [1,1,2,3,4,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +-------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +-------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8] | ==&amp;gt; +-------------------+ ==&amp;gt; 1 row WITH [1,1,1,2,3,4,5,5,6,7,7,8] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +-------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +-------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8] | ==&amp;gt; +-------------------+ ==&amp;gt; 1 row WITH [1,1,1,2,3,4,5,5,6,7,7,8,1] AS values UNWIND RANGE(0, LENGTH(values) - 2) AS idx WITH values[idx] AS a, values[idx+1] AS b WHERE a &amp;lt;&amp;gt; b RETURN COLLECT(a)[0] + COLLECT(b) AS noDuplicates ==&amp;gt; +---------------------+ ==&amp;gt; | noDuplicates | ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8,1] | ==&amp;gt; +---------------------+ ==&amp;gt; 1 row </description>
    </item>
    
    <item>
      <title>Neo4j: MERGE&#39;ing on super nodes</title>
      <link>https://markhneedham.com/blog/2015/07/28/neo4j-mergeing-on-super-nodes/</link>
      <pubDate>Tue, 28 Jul 2015 21:04:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/28/neo4j-mergeing-on-super-nodes/</guid>
      <description>MATCH (crime:Crime) WITH crime SKIP {skip} LIMIT 10000 MATCH (subCat:SubCategory {code: crime.fbiCode}) MERGE (crime)-[:CATEGORY]-&amp;gt;(subCat) RETURN COUNT(*) AS crimesProcessed MATCH (crime:Crime) WITH crime SKIP {skip} LIMIT 10000 MATCH (subCat:SubCategory {code: crime.fbiCode}) WITH crime, subCat, shortestPath((crime)-[:CATEGORY]-&amp;gt;(subCat)) AS path FOREACH(ignoreMe IN CASE WHEN path is NULL THEN [1] ELSE [] END | CREATE (crime)-[:CATEGORY]-&amp;gt;(subCat)) RETURN COUNT(*) MATCH (crime:Crime) WITH crime SKIP {skip} LIMIT 10000 MATCH (subCat:SubCategory {code: crime.fbiCode}) CREATE UNIQUE (crime)-[:CATEGORY]-&amp;gt;(subCat) RETURN COUNT(*) AS crimesProcessed </description>
    </item>
    
    <item>
      <title>Neo4j: From JSON to CSV to LOAD CSV via jq</title>
      <link>https://markhneedham.com/blog/2015/07/25/neo4j-from-json-to-csv-to-load-csv-via-jq/</link>
      <pubDate>Sat, 25 Jul 2015 23:05:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/25/neo4j-from-json-to-csv-to-load-csv-via-jq/</guid>
      <description>{ &amp;#34;categories&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Index Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01A&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Homicide 1st &amp;amp; 2nd Degree&amp;#34; }, ] }, { &amp;#34;name&amp;#34;: &amp;#34;Non-Index Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01B&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Involuntary Manslaughter&amp;#34; }, ] }, { &amp;#34;name&amp;#34;: &amp;#34;Violent Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01A&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Homicide 1st &amp;amp; 2nd Degree&amp;#34; }, ] } ] } We want to get one row for each sub category which contains three columns - category name, sub category code, sub category description.</description>
    </item>
    
    <item>
      <title>Neo4j: Loading JSON documents with Cypher</title>
      <link>https://markhneedham.com/blog/2015/07/23/neo4j-loading-json-documents-with-cypher/</link>
      <pubDate>Thu, 23 Jul 2015 06:15:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/23/neo4j-loading-json-documents-with-cypher/</guid>
      <description>{ &amp;#34;categories&amp;#34;: [ { &amp;#34;name&amp;#34;: &amp;#34;Index Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01A&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Homicide 1st &amp;amp; 2nd Degree&amp;#34; } ] }, { &amp;#34;name&amp;#34;: &amp;#34;Non-Index Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01B&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Involuntary Manslaughter&amp;#34; } ] }, { &amp;#34;name&amp;#34;: &amp;#34;Violent Crime&amp;#34;, &amp;#34;sub_categories&amp;#34;: [ { &amp;#34;code&amp;#34;: &amp;#34;01A&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Homicide 1st &amp;amp; 2nd Degree&amp;#34; } ] } ] } import json from py2neo import Graph, authenticate # replace &amp;#39;foobar&amp;#39; with your password authenticate(&amp;#34;localhost:7474&amp;#34;, &amp;#34;neo4j&amp;#34;, &amp;#34;foobar&amp;#34;) graph = Graph() with open(&amp;#39;categories.</description>
    </item>
    
    <item>
      <title>Neo4j 2.2.3: neo4j-import - Encoder StringEncoder[2] returned an illegal encoded value 0</title>
      <link>https://markhneedham.com/blog/2015/07/21/neo4j-2-2-3-neo4j-import-encoder-stringencoder2-returned-an-illegal-encoded-value-0/</link>
      <pubDate>Tue, 21 Jul 2015 06:11:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/21/neo4j-2-2-3-neo4j-import-encoder-stringencoder2-returned-an-illegal-encoded-value-0/</guid>
      <description>Importing the contents of these files into tmp/crimes.db: Nodes: /Users/markneedham/projects/neo4j-spark-chicago/tmp/crimes.csv /Users/markneedham/projects/neo4j-spark-chicago/tmp/beats.csv /Users/markneedham/projects/neo4j-spark-chicago/tmp/primaryTypes.csv /Users/markneedham/projects/neo4j-spark-chicago/tmp/locations.csv Relationships: /Users/markneedham/projects/neo4j-spark-chicago/tmp/crimesBeats.csv /Users/markneedham/projects/neo4j-spark-chicago/tmp/crimesPrimaryTypes.csv /Users/markneedham/projects/neo4j-spark-chicago/tmp/crimesLocationsCleaned.csv Available memory: Free machine memory: 263.17 MB Max heap memory : 3.56 GB Nodes [*&amp;gt;:17.41 MB/s-------------------------|PROPERTIES(3)=|NODE:3|LABEL SCAN----|v:36.30 MB/s(2)===] 3MImport error: Panic called, so exiting java.lang.RuntimeException: Panic called, so exiting at org.neo4j.unsafe.impl.batchimport.staging.AbstractStep.assertHealthy(AbstractStep.java:200) at org.neo4j.unsafe.impl.batchimport.staging.AbstractStep.await(AbstractStep.java:191) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep.receive(ProcessorStep.java:98) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep.sendDownstream(ProcessorStep.java:224) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep.access$400(ProcessorStep.java:42) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep$Sender.send(ProcessorStep.java:250) at org.neo4j.unsafe.impl.batchimport.LabelScanStorePopulationStep.process(LabelScanStorePopulationStep.java:60) at org.neo4j.unsafe.impl.batchimport.LabelScanStorePopulationStep.process(LabelScanStorePopulationStep.java:37) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep$4.run(ProcessorStep.java:120) at org.neo4j.unsafe.impl.batchimport.staging.ProcessorStep$4.run(ProcessorStep.java:102) at org.neo4j.unsafe.impl.batchimport.executor.DynamicTaskExecutor$Processor.run(DynamicTaskExecutor.java:237) Caused by: java.</description>
    </item>
    
    <item>
      <title>Neo4j: The football transfers graph</title>
      <link>https://markhneedham.com/blog/2015/07/16/neo4j-the-football-transfers-graph/</link>
      <pubDate>Thu, 16 Jul 2015 06:40:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/07/16/neo4j-the-football-transfers-graph/</guid>
      <description>$ head -n 10 data/transfers.csv player,from_team,from_team_id,to_team,to_team_id,fee,season Martin Keown,Everton,29,Arsenal FC,11,&amp;#34;2,10 Mill. £&amp;#34;,1992-1993 John Jensen,Bröndby IF,206,Arsenal FC,11,&amp;#34;1,12 Mill. £&amp;#34;,1992-1993 Alan Miller,Birmingham,337,Arsenal FC,11,,1992-1993 Jim Will,Sheffield Utd.,350,Arsenal FC,11,,1992-1993 David Rocastle,Arsenal FC,11,Leeds,399,&amp;#34;1,68 Mill. £&amp;#34;,1992-1993 Perry Groves,Arsenal FC,11,Southampton FC,180,595 Th. £,1992-1993 Ty Gooden,Arsenal FC,11,Wycombe Wand.,2805,?,1992-1993 Geraint Williams,Derby,22,Ipswich Town,677,525 Th. £,1992-1993 Jason Winters,Chelsea U21,9250,Ipswich Town,677,?,1992-1993 create index on :Team(id); create index on :Season(name); create index on :Transfer(description); create index on :Player(name); // teams load csv with headers from &amp;quot;file:///Users/markneedham/projects/football-transfers/data/teams.</description>
    </item>
    
    <item>
      <title>Northwind: Finding direct/transitive Reports in SQL and Neo4j&#39;s Cypher</title>
      <link>https://markhneedham.com/blog/2015/06/15/northwind-finding-directtransitive-reports-in-sql-and-neo4js-cypher/</link>
      <pubDate>Mon, 15 Jun 2015 22:53:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/15/northwind-finding-directtransitive-reports-in-sql-and-neo4js-cypher/</guid>
      <description>SELECT e.&amp;#34;EmployeeID&amp;#34;, e.&amp;#34;ReportsTo&amp;#34; FROM employees AS e WHERE e.&amp;#34;ReportsTo&amp;#34; is not null; EmployeeID | ReportsTo ------------+-----------  1 | 2 3 | 2 4 | 2 5 | 2 6 | 5 7 | 5 8 | 2 9 | 5 (8 rows) MATCH (e:Employee)&amp;lt;-[:REPORTS_TO]-(sub) RETURN sub.EmployeeID, e.EmployeeID +-------------------------------+ | sub.EmployeeID | e.EmployeeID | +-------------------------------+ | &amp;quot;4&amp;quot; | &amp;quot;2&amp;quot; | | &amp;quot;5&amp;quot; | &amp;quot;2&amp;quot; | | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | | &amp;quot;3&amp;quot; | &amp;quot;2&amp;quot; | | &amp;quot;8&amp;quot; | &amp;quot;2&amp;quot; | | &amp;quot;9&amp;quot; | &amp;quot;5&amp;quot; | | &amp;quot;6&amp;quot; | &amp;quot;5&amp;quot; | | &amp;quot;7&amp;quot; | &amp;quot;5&amp;quot; | +-------------------------------+ 8 rows SELECT e.</description>
    </item>
    
    <item>
      <title>Neo4j: Using LOAD CSV to help explore CSV files</title>
      <link>https://markhneedham.com/blog/2015/06/11/neo4j-using-load-csv-to-help-explore-csv-files/</link>
      <pubDate>Thu, 11 Jun 2015 23:15:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/11/neo4j-using-load-csv-to-help-explore-csv-files/</guid>
      <description>$ head -n 5 data/import/references.csv ReferencedEpisodeId,ReferencingEpisodeId,ReferenceText 168,184,&amp;#34;Marshall will eventually hear back from the New York State Judicatory Committee in Something New, which will become a main plot point of Season 9.&amp;#34; 168,169,Barney proclaiming to be done with Robin will be the focal point of Lobster Crawl. 58,57,&amp;#34;Barney finally confronts his saboteur (Abby, whom he slept with in Ten Sessions) in Everything Must Go.&amp;#34; 58,63,&amp;#34;Barney finally confronts his saboteur (Abby, whom he slept with in Ten Sessions) in Everything Must Go.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Step by step to creating a linked list of adjacent nodes using UNWIND</title>
      <link>https://markhneedham.com/blog/2015/06/04/neo4j-cypher-step-by-step-to-creating-a-linked-list-of-adjacent-nodes-using-unwind/</link>
      <pubDate>Thu, 04 Jun 2015 22:17:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/06/04/neo4j-cypher-step-by-step-to-creating-a-linked-list-of-adjacent-nodes-using-unwind/</guid>
      <description>CREATE (:Season {name: &amp;quot;2013/2014&amp;quot;, timestamp: 1375315200}) CREATE (:Season {name: &amp;quot;2012/2013&amp;quot;, timestamp: 1343779200}) CREATE (:Season {name: &amp;quot;2011/2012&amp;quot;, timestamp: 1312156800}) CREATE (:Season {name: &amp;quot;2010/2011&amp;quot;, timestamp: 1280620800}) CREATE (:Season {name: &amp;quot;2009/2010&amp;quot;, timestamp: 1249084800}) MATCH (s:Season) WITH s ORDER BY s.timestamp WITH COLLECT(s) AS seasons FOREACH(i in RANGE(0, length(seasons)-2) | FOREACH(si in [seasons[i]] | FOREACH(si2 in [seasons[i+1]] | MERGE (si)-[:NEXT]-&amp;gt;(si2)))) MATCH (s:Season) WITH s ORDER BY s.timestamp RETURN COLLECT(s) AS seasons ==&amp;gt; +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | seasons | ==&amp;gt; +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | [Node[1973]{timestamp:1249084800,name:&amp;quot;2009/2010&amp;quot;},Node[1972]{timestamp:1280620800,name:&amp;quot;2010/2011&amp;quot;},Node[1971]{timestamp:1312156800,name:&amp;quot;2011/2012&amp;quot;},Node[1970]{timestamp:1343779200,name:&amp;quot;2012/2013&amp;quot;},Node[1969]{timestamp:1375315200,name:&amp;quot;2013/2014&amp;quot;}] | ==&amp;gt; +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 2009/2010	2010/2011 2010/2011	2011/2012 2011/2012	2012/2013 2012/2013	2013/2014 &amp;gt;&amp;gt;&amp;gt; seasons = [&amp;#34;2009/2010&amp;#34;, &amp;#34;2010/2011&amp;#34;, &amp;#34;2011/2012&amp;#34;, &amp;#34;2012/2013&amp;#34;, &amp;#34;2013/2014&amp;#34;] &amp;gt;&amp;gt;&amp;gt; zip(seasons, seasons[1:]) [(&amp;#39;2009/2010&amp;#39;, &amp;#39;2010/2011&amp;#39;), (&amp;#39;2010/2011&amp;#39;, &amp;#39;2011/2012&amp;#39;), (&amp;#39;2011/2012&amp;#39;, &amp;#39;2012/2013&amp;#39;), (&amp;#39;2012/2013&amp;#39;, &amp;#39;2013/2014&amp;#39;)] return RANGE(0,4) ==&amp;gt; +-------------+ ==&amp;gt; | RANGE(0,4) | ==&amp;gt; +-------------+ ==&amp;gt; | [0,1,2,3,4] | ==&amp;gt; +-------------+ UNWIND RANGE(0,4) as idx RETURN idx, idx +1; ==&amp;gt; +--------------+ ==&amp;gt; | idx | idx +1 | ==&amp;gt; +--------------+ ==&amp;gt; | 0 | 1 | ==&amp;gt; | 1 | 2 | ==&amp;gt; | 2 | 3 | ==&amp;gt; | 3 | 4 | ==&amp;gt; | 4 | 5 | ==&amp;gt; +--------------+ ==&amp;gt; 5 rows MATCH (s:Season) WITH s ORDER BY s.</description>
    </item>
    
    <item>
      <title>Neo4j: The BBC Champions League graph</title>
      <link>https://markhneedham.com/blog/2015/05/30/neo4j-the-bbc-champions-league-graph/</link>
      <pubDate>Sat, 30 May 2015 21:45:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/30/neo4j-the-bbc-champions-league-graph/</guid>
      <description>from bs4 import BeautifulSoup from soupselect import select import bs4 soup = BeautifulSoup(open(&amp;#34;data/results&amp;#34;, &amp;#34;r&amp;#34;)) matches = select(soup, &amp;#34;a.report&amp;#34;) for match in matches: print &amp;#34;http://www.bbc.co.uk/%s&amp;#34; %(match.get(&amp;#34;href&amp;#34;)) I then piped the output of running this script into wget:
find_all_matches.py | xargs wget -O data/raw match (a:Attempt)&amp;lt;-[:HAD_ATTEMPT]-(app)&amp;lt;-[:MADE_APPEARANCE]-(player), (app)-[:FOR_TEAM]-(team) WITH player, COUNT(*) as times, COLLECT(a) AS attempts, team WITH player, times, LENGTH([a in attempts WHERE a:Goal]) AS goals, team WHERE times &amp;gt; 10 RETURN player.</description>
    </item>
    
    <item>
      <title>Neo4j: The foul revenge graph</title>
      <link>https://markhneedham.com/blog/2015/05/26/neo4j-the-foul-revenge-graph/</link>
      <pubDate>Tue, 26 May 2015 07:03:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/26/neo4j-the-foul-revenge-graph/</guid>
      <description>MATCH (foul:Foul)-[:COMMITTED_IN_MATCH]-&amp;gt;(match) WITH foul,match ORDER BY match.id, foul.sortableTime WITH match, COLLECT(foul) AS fouls FOREACH(i in range(0, length(fouls) -2) | FOREACH(foul1 in [fouls[i]] | FOREACH (foul2 in [fouls[i+1]] | MERGE (foul1)-[:NEXT]-&amp;gt;(foul2) ))); match (foul1:Foul)-[:COMMITTED_AGAINST]-&amp;gt;(app1)-[:COMMITTED_FOUL]-&amp;gt;(foul2)-[:COMMITTED_AGAINST]-&amp;gt;(app2)-[:COMMITTED_FOUL]-&amp;gt;(foul1), (player1)-[:MADE_APPEARANCE]-&amp;gt;(app1), (player2)-[:MADE_APPEARANCE]-&amp;gt;(app2), (foul1)-[:COMMITTED_IN_MATCH]-&amp;gt;(match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:COMMITTED_IN_MATCH]-(foul2) WHERE (foul1)-[:NEXT*]-&amp;gt;(foul2) RETURN player2.name AS firstFouler, player1.name AS revengeFouler, foul1.time, foul1.location, foul2.time, foul2.location match (foul1:Foul)-[:COMMITTED_AGAINST]-&amp;gt;(app1)-[:COMMITTED_FOUL]-&amp;gt;(foul2)-[:COMMITTED_AGAINST]-&amp;gt;(app2)-[:COMMITTED_FOUL]-&amp;gt;(foul1), (player1)-[:MADE_APPEARANCE]-&amp;gt;(app1), (player2)-[:MADE_APPEARANCE]-&amp;gt;(app2), (foul1)-[:COMMITTED_IN_MATCH]-&amp;gt;(match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:COMMITTED_IN_MATCH]-(foul2), (foul1)-[:NEXT*]-&amp;gt;(foul2) RETURN * </description>
    </item>
    
    <item>
      <title>Neo4j: Finding all shortest paths</title>
      <link>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</link>
      <pubDate>Tue, 19 May 2015 22:45:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/19/neo4j-finding-all-shortest-paths/</guid>
      <description>MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;()&amp;lt;-[:ACTED_IN]-(p2:Person) MERGE (p1)-[:KNOWS]-(p2) MATCH (p1:Person {name: &amp;quot;Tom Hanks&amp;quot;}), (p2:Person {name: &amp;quot;Tom Cruise&amp;quot;}), path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path MATCH (p1:Person), (p2:Person), path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;() WITH p1, COUNT(*) AS appearances ORDER BY appearances DESC LIMIT 10 WITH p1 AS p1, p1 AS p2 MATCH path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 MATCH (p1:Person)-[:ACTED_IN]-&amp;gt;() WITH p1, COUNT(*) AS appearances ORDER BY appearances DESC LIMIT 10 WITH COLLECT(p1) AS ps UNWIND ps AS p1 UNWIND ps AS p2 MATCH path = shortestpath((p1)-[:KNOWS*]-(p2)) RETURN path ORDER BY LENGTH(path) DESC LIMIT 1 </description>
    </item>
    
    <item>
      <title>Neo4j: Refactoring the BBC football live text fouls graph</title>
      <link>https://markhneedham.com/blog/2015/05/17/neo4j-refactoring-the-bbc-football-live-text-fouls-graph/</link>
      <pubDate>Sun, 17 May 2015 11:04:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/17/neo4j-refactoring-the-bbc-football-live-text-fouls-graph/</guid>
      <description>First up let&amp;rsquo;s write a query to introduce the new structure.
match (foul:Foul)-[:COMMITTED_AGAINST]-&amp;gt;(fouledPlayer), (foul)&amp;lt;-[:COMMITTED_FOUL]-(foulingPlayer), (foul)-[:COMMITTED_IN_MATCH]-&amp;gt;(match:Match {id: &amp;quot;32683310&amp;quot;}), (foulingPlayer)-[:MADE_APPEARANCE]-(foulingPlayerApp)-[:IN_MATCH]-&amp;gt;(match), (fouledPlayer)-[:MADE_APPEARANCE]-(fouledPlayerApp)-[:IN_MATCH]-&amp;gt;(match) MERGE (foul)&amp;lt;-[:COMMITTED_FOUL]-(foulingPlayerApp) MERGE (foul)-[:COMMITTED_AGAINST]-&amp;gt;(fouledPlayerApp) match (match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:COMMITTED_IN_MATCH]-(foul) RETURN foul.location AS location, COUNT(*) as fouls ORDER BY fouls DESC match (match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:IN_MATCH]-()&amp;lt;-[]-(foul:Foul) RETURN foul.location AS location, COUNT(*) as fouls ORDER BY fouls DESC match (match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:COMMITTED_IN_MATCH]-(foul:Foul)&amp;lt;-[:COMMITTED_FOUL]-(fouler:Player) RETURN fouler.name AS fouler, COUNT(*) as fouls ORDER BY fouls DESC LIMIT 10; match (match:Match {id: &amp;quot;32683310&amp;quot;})&amp;lt;-[:IN_MATCH]-(appearance)-[:COMMITTED_FOUL]-&amp;gt;(foul:Foul), (appearance)&amp;lt;-[:MADE_APPEARANCE]-(fouler) RETURN fouler.</description>
    </item>
    
    <item>
      <title>Neo4j: BBC football live text fouls graph</title>
      <link>https://markhneedham.com/blog/2015/05/16/neo4j-bbc-football-live-text-fouls-graph/</link>
      <pubDate>Sat, 16 May 2015 21:13:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/16/neo4j-bbc-football-live-text-fouls-graph/</guid>
      <description>I find the feedback cycle with this type of work is dramatically improved if we have the source data available locally so the first step was to get the BBC web page downloaded:
$ wget http://www.bbc.co.uk/sport/0/football/32683310 $ head -n 10 data/events.csv matchId,foulId,freeKickId,time,foulLocation,fouledPlayer,fouledPlayerTeam,foulingPlayer,foulingPlayerTeam 32683310,3,2,90:00 +0:40,in the defensive half.,Xabi Alonso,FC Bayern München,Pedro,Barcelona 32683310,9,8,84:38,on the right wing.,Rafinha,FC Bayern München,Pedro,Barcelona 32683310,12,13,83:17,in the attacking half.,Lionel Messi,Barcelona,Sebastian Rode,FC Bayern München 32683310,15,14,82:43,in the defensive half.,Sebastian Rode,FC Bayern München,Neymar,Barcelona 32683310,17,18,80:41,in the attacking half.</description>
    </item>
    
    <item>
      <title>R: ggplot - Displaying multiple charts with a for loop</title>
      <link>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</link>
      <pubDate>Thu, 14 May 2015 00:17:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/14/r-ggplot-displaying-multiple-charts-with-a-for-loop/</guid>
      <description>library(RNeo4j) graph = startGraph(&amp;#34;http://127.0.0.1:7474/db/data/&amp;#34;) eventId = &amp;#34;220750415&amp;#34; query = &amp;#34;match (g:Group {name: &amp;#39;Neo4j - London User Group&amp;#39;})-[:HOSTED_EVENT]-&amp;gt; (e {id: {id}})&amp;lt;-[:TO]-(rsvp {response: &amp;#39;yes&amp;#39;})&amp;lt;-[:RSVPD]-(person) WITH rsvp, person MATCH (person)-[:RSVPD]-&amp;gt;(otherRSVP) WITH person, rsvp, otherRSVP ORDER BY person.id, otherRSVP.time WITH person, rsvp, COLLECT(otherRSVP)[0] AS earliestRSVP return rsvp.time, earliestRSVP.time, person.id&amp;#34; df = cypher(graph, query, id= eventId) &amp;gt; df %&amp;gt;% sample_n(10) rsvp.time earliestRSVP.time person.id 18 1.430819e+12 1.392726e+12 130976662 95 1.430069e+12 1.430069e+12 10286388 79 1.429035e+12 1.429035e+12 38344282 64 1.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - java.io.InputStreamReader there&#39;s a field starting with a quote and whereas it ends that quote there seems  to be character in that field after that ending quote. That isn&#39;t supported.</title>
      <link>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</link>
      <pubDate>Mon, 04 May 2015 09:56:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/05/04/neo4j-load-csv-java-io-inputstreamreader-theres-a-field-starting-with-a-quote-and-whereas-it-ends-that-quote-there-seems-to-be-character-in-that-field-after-that-ending-quote-that-isnt-suppor/</guid>
      <description>LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/neo4j-recommendations/lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv&amp;quot; AS row FIELDTERMINATOR &amp;quot;\t&amp;quot; return COUNT(*) At java.io.InputStreamReader@4d307fda:6484 there&#39;s a field starting with a quote and whereas it ends that quote there seems to be character in that field after that ending quote. That isn&#39;t supported. This is what I read: &#39;weird al&amp;quot;&#39; $ grep &amp;#34;\&amp;#34;weird&amp;#34; lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv | head -n 1 0015371426d2cbef354b2f680340de38d0ebd2f0	7746d775-9550-4360-b8d5-c37bd448ce01	&amp;#34;weird al&amp;#34; yankovic	4099 $ tr &amp;#34;\&amp;#34;&amp;#34; &amp;#34;&amp;#39;&amp;#34; &amp;lt; lastfm-dataset-360K/usersha1-artmbid-artname-plays.tsv &amp;gt; lastfm-dataset-360K/clean.tsv LOAD CSV FROM &amp;quot;file:///Users/markneedham/projects/neo4j-recommendations/lastfm-dataset-360K/clean.</description>
    </item>
    
    <item>
      <title>Neo4j: The learning to cycle dependency graph</title>
      <link>https://markhneedham.com/blog/2015/04/07/neo4j-the-learning-to-cycle-dependency-graph/</link>
      <pubDate>Tue, 07 Apr 2015 20:59:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/07/neo4j-the-learning-to-cycle-dependency-graph/</guid>
      <description>MERGE (:Goal:Task {name: &amp;quot;Be able to cycle through a public park&amp;quot;}) MERGE (task:Task {name: &amp;quot;Take a few steps forward while standing over the bike&amp;quot;}) WITH task MATCH (goal:Goal:Task {name: &amp;quot;Be able to cycle through a public park&amp;quot;}) MERGE (goal)-[:DEPENDS_ON]-&amp;gt;(task) // First let&#39;s get rid of the relationship between our initial task and the goal MATCH (initialTask:Task {name: &amp;quot;Take a few steps forward while standing over the bike&amp;quot;}) MATCH (goal:Goal {name: &amp;quot;Be able to cycle through a public park&amp;quot;}) MATCH (goal)-[rel:DEPENDS_ON]-&amp;gt;(initialTask) DELETE rel WITH initialTask, goal, [&amp;quot;Get bike moving from standing start&amp;quot;, &amp;quot;Cycle forward while standing&amp;quot;, &amp;quot;Cycle forward while sitting&amp;quot;] AS newTasks // Create some nodes for our new tasks UNWIND newTasks AS newTask MERGE (t:Task {name: newTask}) WITH initialTask, goal, COLLECT(t) AS newTasks WITH initialTask, goal, newTasks, newTasks[0] AS firstTask, newTasks[-1] AS lastTask // Connect the last task to the goal MERGE (goal)-[:DEPENDS_ON]-&amp;gt;(lastTask) // And the first task to our initial task MERGE (firstTask)-[:DEPENDS_ON]-&amp;gt;(initialTask) // And all the tasks to each other FOREACH(i in RANGE(0, length(newTasks) - 2) | FOREACH(t1 in [newTasks[i]] | FOREACH(t2 in [newTasks[i+1]] | MERGE (t2)-[:DEPENDS_ON]-&amp;gt;(t1) ))) MATCH (sitting:Task {name: &amp;quot;Cycle forward while sitting&amp;quot;}) MATCH (moving:Task {name: &amp;quot;Get bike moving from standing start&amp;quot;}) MERGE (sitting)-[:DEPENDS_ON]-&amp;gt;(moving) WITH [ {skill: &amp;quot;Controlled stop using brakes/feet&amp;quot;, dependsOn: &amp;quot;Cycle forward while sitting&amp;quot;}, {skill: &amp;quot;Steer around stationary objects&amp;quot;, dependsOn: &amp;quot;Controlled stop using brakes/feet&amp;quot;}, {skill: &amp;quot;Steer around people&amp;quot;, dependsOn: &amp;quot;Steer around stationary objects&amp;quot;}, {skill: &amp;quot;Navigate a small circular circuit&amp;quot;, dependsOn: &amp;quot;Steer around stationary objects&amp;quot;}, {skill: &amp;quot;Navigate a loop of a section of the park&amp;quot;, dependsOn: &amp;quot;Navigate a small circular circuit&amp;quot;}, {skill: &amp;quot;Navigate a loop of a section of the park&amp;quot;, dependsOn: &amp;quot;Steer around people&amp;quot;}, {skill: &amp;quot;Be able to cycle through a public park&amp;quot;, dependsOn: &amp;quot;Navigate a loop of a section of the park&amp;quot;} ] AS newTasks FOREACH(newTask in newTasks | MERGE (t1:Task {name: newTask.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Building the query for a movie&#39;s profile page</title>
      <link>https://markhneedham.com/blog/2015/04/01/neo4j-cypher-building-the-query-for-a-movies-profile-page/</link>
      <pubDate>Wed, 01 Apr 2015 11:54:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/04/01/neo4j-cypher-building-the-query-for-a-movies-profile-page/</guid>
      <description>match (movie:Movie {title: &amp;quot;The Matrix&amp;quot;}) return movie.title ==&amp;gt; +--------------+ ==&amp;gt; | movie.title | ==&amp;gt; +--------------+ ==&amp;gt; | &amp;quot;The Matrix&amp;quot; | ==&amp;gt; +--------------+ ==&amp;gt; 1 row Easy enough. Now let&amp;rsquo;s get back the producers:
match (movie:Movie {title: &amp;quot;The Matrix&amp;quot;}) optional match (producer)-[:PRODUCED]-&amp;gt;(movie) RETURN movie.title, COLLECT(producer.name) AS producers ==&amp;gt; +--------------------------------+ ==&amp;gt; | movie.title | producers | ==&amp;gt; +--------------------------------+ ==&amp;gt; | &amp;quot;The Matrix&amp;quot; | [&amp;quot;Joel Silver&amp;quot;] | ==&amp;gt; +--------------------------------+ ==&amp;gt; 1 row match (movie:Movie {title: &amp;quot;The Matrix&amp;quot;}) optional match (director)-[:DIRECTED]-&amp;gt;(movie) RETURN movie.</description>
    </item>
    
    <item>
      <title>Neo4j: Generating real time recommendations with Cypher</title>
      <link>https://markhneedham.com/blog/2015/03/27/neo4j-generating-real-time-recommendations-with-cypher/</link>
      <pubDate>Fri, 27 Mar 2015 06:59:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/03/27/neo4j-generating-real-time-recommendations-with-cypher/</guid>
      <description>CREATE (m:Person:Male {name:&#39;Michal&#39;, age:30}), (d:Person:Female {name:&#39;Daniela&#39;, age:20}), (v:Person:Male {name:&#39;Vince&#39;, age:40}), (a:Person:Male {name:&#39;Adam&#39;, age:30}), (l:Person:Female {name:&#39;Luanne&#39;, age:25}), (c:Person:Male {name:&#39;Christophe&#39;, age:60}), (lon:City {name:&#39;London&#39;}), (mum:City {name:&#39;Mumbai&#39;}), (m)-[:FRIEND_OF]-&amp;gt;(d), (m)-[:FRIEND_OF]-&amp;gt;(l), (m)-[:FRIEND_OF]-&amp;gt;(a), (m)-[:FRIEND_OF]-&amp;gt;(v), (d)-[:FRIEND_OF]-&amp;gt;(v), (c)-[:FRIEND_OF]-&amp;gt;(v), (d)-[:LIVES_IN]-&amp;gt;(lon), (v)-[:LIVES_IN]-&amp;gt;(lon), (m)-[:LIVES_IN]-&amp;gt;(lon), (l)-[:LIVES_IN]-&amp;gt;(mum); MATCH (me:Person {name: &amp;quot;Adam&amp;quot;}) MATCH (me)-[:FRIEND_OF]-()-[:FRIEND_OF]-(potentialFriend) RETURN me, potentialFriend, COUNT(*) AS friendsInCommon ==&amp;gt; +--------------------------------------------------------------------------------------+ ==&amp;gt; | me | potentialFriend | friendsInCommon | ==&amp;gt; +--------------------------------------------------------------------------------------+ ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1006]{name:&amp;quot;Vince&amp;quot;,age:40} | 1 | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1005]{name:&amp;quot;Daniela&amp;quot;,age:20} | 1 | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1008]{name:&amp;quot;Luanne&amp;quot;,age:25} | 1 | ==&amp;gt; +--------------------------------------------------------------------------------------+ ==&amp;gt; 3 rows MATCH (me:Person {name: &amp;quot;Adam&amp;quot;}) MATCH (me)-[:FRIEND_OF]-()-[:FRIEND_OF]-(potentialFriend) WITH me, potentialFriend, COUNT(*) AS friendsInCommon RETURN me, potentialFriend, SIZE((potentialFriend)-[:LIVES_IN]-&amp;gt;()&amp;lt;-[:LIVES_IN]-(me)) AS sameLocation ==&amp;gt; +-----------------------------------------------------------------------------------+ ==&amp;gt; | me | potentialFriend | sameLocation | ==&amp;gt; +-----------------------------------------------------------------------------------+ ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1006]{name:&amp;quot;Vince&amp;quot;,age:40} | 0 | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1005]{name:&amp;quot;Daniela&amp;quot;,age:20} | 0 | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1008]{name:&amp;quot;Luanne&amp;quot;,age:25} | 0 | ==&amp;gt; +-----------------------------------------------------------------------------------+ ==&amp;gt; 3 rows MATCH (me:Person {name: &amp;quot;Adam&amp;quot;}) MATCH (me)-[:FRIEND_OF]-()-[:FRIEND_OF]-(potentialFriend) WITH me, potentialFriend, COUNT(*) AS friendsInCommon RETURN me, potentialFriend, SIZE((potentialFriend)-[:LIVES_IN]-&amp;gt;()&amp;lt;-[:LIVES_IN]-(me)) AS sameLocation, LABELS(me) = LABELS(potentialFriend) AS gender ==&amp;gt; +--------------------------------------------------------------------------------------------+ ==&amp;gt; | me | potentialFriend | sameLocation | gender | ==&amp;gt; +--------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1006]{name:&amp;quot;Vince&amp;quot;,age:40} | 0 | true | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1005]{name:&amp;quot;Daniela&amp;quot;,age:20} | 0 | false | ==&amp;gt; | Node[1007]{name:&amp;quot;Adam&amp;quot;,age:30} | Node[1008]{name:&amp;quot;Luanne&amp;quot;,age:25} | 0 | false | ==&amp;gt; +--------------------------------------------------------------------------------------------+ ==&amp;gt; 3 rows MATCH (me:Person {name: &amp;quot;Adam&amp;quot;}) MATCH (me)-[:FRIEND_OF]-()-[:FRIEND_OF]-(potentialFriend) WITH me, potentialFriend, COUNT(*) AS friendsInCommon RETURN me, potentialFriend, SIZE((potentialFriend)-[:LIVES_IN]-&amp;gt;()&amp;lt;-[:LIVES_IN]-(me)) AS sameLocation, abs( me.</description>
    </item>
    
    <item>
      <title>Neo4j: Detecting potential typos using EXPLAIN</title>
      <link>https://markhneedham.com/blog/2015/03/17/neo4j-detecting-potential-typos-using-explain/</link>
      <pubDate>Tue, 17 Mar 2015 22:46:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/03/17/neo4j-detecting-potential-typos-using-explain/</guid>
      <description>MATCH (actor:Person)-[:ACTED_IN]-&amp;gt;(movie)&amp;lt;-[:DIRECTED]-(director) RETURN actor.name, director.name, COLLECT(movie.title) AS movies ORDER BY LENGTH(movies) DESC LIMIT 5 ==&amp;gt; +-----------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | actor.name | director.name | movies | ==&amp;gt; +-----------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | &amp;#34;Hugo Weaving&amp;#34; | &amp;#34;Andy Wachowski&amp;#34; | [&amp;#34;Cloud Atlas&amp;#34;,&amp;#34;The Matrix Revolutions&amp;#34;,&amp;#34;The Matrix Reloaded&amp;#34;,&amp;#34;The Matrix&amp;#34;] | ==&amp;gt; | &amp;#34;Hugo Weaving&amp;#34; | &amp;#34;Lana Wachowski&amp;#34; | [&amp;#34;Cloud Atlas&amp;#34;,&amp;#34;The Matrix Revolutions&amp;#34;,&amp;#34;The Matrix Reloaded&amp;#34;,&amp;#34;The Matrix&amp;#34;] | ==&amp;gt; | &amp;#34;Laurence Fishburne&amp;#34; | &amp;#34;Lana Wachowski&amp;#34; | [&amp;#34;The Matrix Revolutions&amp;#34;,&amp;#34;The Matrix Reloaded&amp;#34;,&amp;#34;The Matrix&amp;#34;] | ==&amp;gt; | &amp;#34;Keanu Reeves&amp;#34; | &amp;#34;Lana Wachowski&amp;#34; | [&amp;#34;The Matrix Revolutions&amp;#34;,&amp;#34;The Matrix Reloaded&amp;#34;,&amp;#34;The Matrix&amp;#34;] | ==&amp;gt; | &amp;#34;Carrie-Anne Moss&amp;#34; | &amp;#34;Lana Wachowski&amp;#34; | [&amp;#34;The Matrix Revolutions&amp;#34;,&amp;#34;The Matrix Reloaded&amp;#34;,&amp;#34;The Matrix&amp;#34;] | ==&amp;gt; +-----------------------------------------------------------------------------------------------------------------------+ MATCH (actor:Person)-[:ACTED_IN]-&amp;gt;(movie)&amp;lt;-[:DIRECTED_IN]-(director) RETURN actor.</description>
    </item>
    
    <item>
      <title>Python/Neo4j: Finding interesting computer sciency people to follow on Twitter</title>
      <link>https://markhneedham.com/blog/2015/03/11/pythonneo4j-finding-interesting-computer-sciency-people-to-follow-on-twitter/</link>
      <pubDate>Wed, 11 Mar 2015 21:13:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/03/11/pythonneo4j-finding-interesting-computer-sciency-people-to-follow-on-twitter/</guid>
      <description>import tweepy import csv from collections import Counter, deque auth = tweepy.OAuthHandler(consumer_key, consumer_secret) auth.set_access_token(access_token, access_token_secret) api = tweepy.API(auth, wait_on_rate_limit = True, wait_on_rate_limit_notify = True) counter = Counter() users_to_process = deque() USERS_TO_PROCESS = 50 def extract_tweet(tweet): user_mentions = &amp;#34;,&amp;#34;.join([user[&amp;#34;screen_name&amp;#34;].encode(&amp;#34;utf-8&amp;#34;) for user in tweet.entities[&amp;#34;user_mentions&amp;#34;]]) urls = &amp;#34;,&amp;#34;.join([url[&amp;#34;expanded_url&amp;#34;] for url in tweet.entities[&amp;#34;urls&amp;#34;]]) return [tweet.user.screen_name.encode(&amp;#34;utf-8&amp;#34;), tweet.id, tweet.text.encode(&amp;#34;utf-8&amp;#34;), user_mentions, urls] starting_user = &amp;#34;chvest&amp;#34; with open(&amp;#34;tweets.csv&amp;#34;, &amp;#34;a&amp;#34;) as tweets: writer = csv.writer(tweets, delimiter=&amp;#34;,&amp;#34;, escapechar=&amp;#34;\\&amp;#34;, doublequote = False) for tweet in tweepy.</description>
    </item>
    
    <item>
      <title>Neo4j: TF/IDF (and variants) with cypher</title>
      <link>https://markhneedham.com/blog/2015/03/08/neo4j-tfidf-and-variants-with-cypher/</link>
      <pubDate>Sun, 08 Mar 2015 13:24:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/03/08/neo4j-tfidf-and-variants-with-cypher/</guid>
      <description>WITH 3 as termFrequency, 2 AS numberOfDocuments, 1 as numberOfDocumentsWithTerm WITH termFrequency, log10(numberOfDocuments / numberOfDocumentsWithTerm) AS inverseDocumentFrequency return termFrequency * inverseDocumentFrequency 0.9030899869919435 $ head -n 10 data/import/words_scikit.csv EpisodeId,Phrase,Count 1,2005,1 1,2005 seven,1 1,2005 seven just,1 1,2030,3 1,2030 kids,1 1,2030 kids intently,1 1,2030 narrator,1 1,2030 narrator kids,1 1,2030 son,1 // phrases USING PERIODIC COMMIT 1000 LOAD CSV WITH HEADERS FROM &amp;quot;file:///Users/markneedham/projects/neo4j-himym/data/import/words_scikit.csv&amp;quot; AS row MERGE (phrase:Phrase {value: row.Phrase}); // episode -&amp;gt; phrase USING PERIODIC COMMIT 1000 LOAD CSV WITH HEADERS FROM &amp;quot;file:///Users/markneedham/projects/neo4j-himym/data/import/words_scikit.</description>
    </item>
    
    <item>
      <title>Python&#39;s pandas vs Neo4j&#39;s cypher: Exploring popular phrases in How I met your mother transcripts</title>
      <link>https://markhneedham.com/blog/2015/02/19/pythons-pandas-vs-neo4js-cypher-exploring-popular-phrases-in-how-i-met-your-mother-transcripts/</link>
      <pubDate>Thu, 19 Feb 2015 00:52:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/19/pythons-pandas-vs-neo4js-cypher-exploring-popular-phrases-in-how-i-met-your-mother-transcripts/</guid>
      <description>To do anything with Neo4j we need to first load the CSV file into the database. The easiest way to do that is with Cypher&amp;rsquo;s LOAD CSV command.
First we&amp;rsquo;ll load the phrases in and then we&amp;rsquo;ll connect them to the episodes which were previously loaded:
USING PERIODIC COMMIT 1000 LOAD CSV WITH HEADERS FROM &amp;quot;file:///Users/markneedham/projects/neo4j-himym/data/import/tfidf_scikit.csv&amp;quot; AS row MERGE (phrase:Phrase {value: row.Phrase}); USING PERIODIC COMMIT 1000 LOAD CSV WITH HEADERS FROM &amp;quot;file:///Users/markneedham/projects/neo4j-himym/data/import/tfidf_scikit.</description>
    </item>
    
    <item>
      <title>Neo4j: Building a topic graph with Prismatic Interest Graph API</title>
      <link>https://markhneedham.com/blog/2015/02/13/neo4j-building-a-topic-graph-with-prismatic-interest-graph-api/</link>
      <pubDate>Fri, 13 Feb 2015 23:38:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/02/13/neo4j-building-a-topic-graph-with-prismatic-interest-graph-api/</guid>
      <description>import requests payload = { &amp;#39;title&amp;#39;: &amp;#34;insert title of article here&amp;#34;, &amp;#39;body&amp;#39;: &amp;#34;insert body of text here&amp;#34;), &amp;#39;api-token&amp;#39;: &amp;#34;insert token sent by email here&amp;#34;} r = requests.post(&amp;#34;http://interest-graph.getprismatic.com/text/topic&amp;#34;, data=payload) import time def RateLimited(maxPerSecond): minInterval = 1.0 / float(maxPerSecond) def decorate(func): lastTimeCalled = [0.0] def rateLimitedFunction(*args,**kargs): elapsed = time.clock() - lastTimeCalled[0] leftToWait = minInterval - elapsed if leftToWait&amp;gt;0: time.sleep(leftToWait) ret = func(*args,**kargs) lastTimeCalled[0] = time.clock() return ret return rateLimitedFunction return decorate @RateLimited(0.3) def topics(title, body): payload = { &amp;#39;title&amp;#39;: title, &amp;#39;body&amp;#39;: body, &amp;#39;api-token&amp;#39;: &amp;#34;insert token sent by email here&amp;#34;} r = requests.</description>
    </item>
    
    <item>
      <title>Python NLTK/Neo4j: Analysing the transcripts of How I Met Your Mother</title>
      <link>https://markhneedham.com/blog/2015/01/10/python-nltkneo4j-analysing-the-transcripts-of-how-i-met-your-mother/</link>
      <pubDate>Sat, 10 Jan 2015 01:22:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2015/01/10/python-nltkneo4j-analysing-the-transcripts-of-how-i-met-your-mother/</guid>
      <description>import requests from bs4 import BeautifulSoup from soupselect import select episodes = {} for i in range(1,3): page = open(&amp;#34;data/transcripts/page-&amp;#34; + str(i) + &amp;#34;.html&amp;#34;, &amp;#39;r&amp;#39;) soup = BeautifulSoup(page.read()) for row in select(soup, &amp;#34;td.topic-titles a&amp;#34;): parts = row.text.split(&amp;#34; - &amp;#34;) episodes[parts[0]] = {&amp;#34;title&amp;#34;: parts[1], &amp;#34;link&amp;#34;: row.get(&amp;#34;href&amp;#34;)} for key, value in episodes.iteritems(): parts = key.split(&amp;#34;x&amp;#34;) season = int(parts[0]) episode = int(parts[1]) filename = &amp;#34;data/transcripts/S%d-Ep%d&amp;#34; %(season, episode) print filename with open(filename, &amp;#39;wb&amp;#39;) as handle: headers = {&amp;#39;User-Agent&amp;#39;: &amp;#39;Mozilla/5.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1.6 - Cypher: FOREACH slowness</title>
      <link>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</link>
      <pubDate>Sun, 28 Dec 2014 04:28:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/12/28/neo4j-2-1-6-cypher-foreach-slowness/</guid>
      <description>A common problem that people have when using Neo4j for social network applications is updating a person with their newly imported friends.
 We&amp;#8217;ll have an array of friends that we want to connect to a single Person node. Assuming the following schema&amp;#8230;&amp;#8203;
 $ schema Indexes ON :Person(id) ONLINE No constraints   &amp;#8230;&amp;#8203;a simplified version would look like this:
 WITH range (2,1002) AS friends MERGE (p:Person {id: 1}) FOREACH(f IN friends | MERGE (friend:Person {id: f}) MERGE (friend)-[:FRIENDS]-&amp;gt;p);   If we execute that on an empty database we&amp;#8217;ll see something like this:</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Avoiding the Eager</title>
      <link>https://markhneedham.com/blog/2014/10/23/neo4j-cypher-avoiding-the-eager/</link>
      <pubDate>Thu, 23 Oct 2014 05:56:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/23/neo4j-cypher-avoiding-the-eager/</guid>
      <description>That was not related to commit sizes, so it happened even with PERIODIC COMMIT of small batches.
That is where the “pull in all data” happens.
$ head -n 2 data/customerDb.csv OrderID,CustomerID,EmployeeID,OrderDate,RequiredDate,ShippedDate,ShipVia,Freight,ShipName,ShipAddress,ShipCity,ShipRegion,ShipPostalCode,ShipCountry,CustomerID,CustomerCompanyName,ContactName,ContactTitle,Address,City,Region,PostalCode,Country,Phone,Fax,EmployeeID,LastName,FirstName,Title,TitleOfCourtesy,BirthDate,HireDate,Address,City,Region,PostalCode,Country,HomePhone,Extension,Photo,Notes,ReportsTo,PhotoPath,OrderID,ProductID,UnitPrice,Quantity,Discount,ProductID,ProductName,SupplierID,CategoryID,QuantityPerUnit,UnitPrice,UnitsInStock,UnitsOnOrder,ReorderLevel,Discontinued,SupplierID,SupplierCompanyName,ContactName,ContactTitle,Address,City,Region,PostalCode,Country,Phone,Fax,HomePage,CategoryID,CategoryName,Description,Picture 10248,VINET,5,1996-07-04,1996-08-01,1996-07-16,3,32.38,Vins et alcools Chevalier,59 rue de l&amp;#39;Abbaye,Reims,,51100,France,VINET,Vins et alcools Chevalier,Paul Henriot,Accounting Manager,59 rue de l&amp;#39;Abbaye,Reims,,51100,France,26.47.15.10,26.47.15.11,5,Buchanan,Steven,Sales Manager,Mr.,1955-03-04,1993-10-17,14 Garrett Hill,London,,SW1 8JR,UK,(71) 555-4848,3453,\x,&amp;#34;Steven Buchanan graduated from St. Andrews University, Scotland, with a BSC degree in 1976. Upon joining the company as a sales representative in 1992, he spent 6 months in an orientation program at the Seattle office and then returned to his permanent post in London.</description>
    </item>
    
    <item>
      <title>Neo4j: Modelling sub types</title>
      <link>https://markhneedham.com/blog/2014/10/20/neo4j-modelling-sub-types/</link>
      <pubDate>Mon, 20 Oct 2014 23:08:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/20/neo4j-modelling-sub-types/</guid>
      <description>LOAD CSV WITH HEADERS FROM &amp;quot;file:/Users/markneedham/projects/neo4j-subtypes/data/dogs.csv&amp;quot; AS line MERGE (animalType:AnimalType {name: &amp;quot;Dog&amp;quot;}) MERGE (breedGroup:BreedGroup {name: line.BreedGroup}) MERGE (breed:Breed {name: line.PrimaryBreed}) MERGE (animal:Animal {id: line.TagIdentity, primaryColour: line.PrimaryColour, size: line.Size}) MERGE (animalType)&amp;lt;-[:PARENT]-(breedGroup) MERGE (breedGroup)&amp;lt;-[:PARENT]-(breed) MERGE (breed)&amp;lt;-[:PARENT]-(animal) MATCH (animalType:AnimalType)&amp;lt;-[:PARENT*]-(animal) RETURN animalType, COUNT(*) AS animals ORDER BY animals DESC ==&amp;gt; +--------------------------------+ ==&amp;gt; | animalType | animals | ==&amp;gt; +--------------------------------+ ==&amp;gt; | Node[89]{name:&amp;#34;Dog&amp;#34;} | 131 | ==&amp;gt; +--------------------------------+ ==&amp;gt; 1 row MATCH path = (animalType:AnimalType)&amp;lt;-[:PARENT]-(breedGroup)&amp;lt;-[:PARENT*]-(animal) RETURN [node IN nodes(path) | node.</description>
    </item>
    
    <item>
      <title>Lessons from running Neo4j based &#39;hackathons&#39;</title>
      <link>https://markhneedham.com/blog/2014/10/11/lessons-from-running-neo4j-based-hackathons/</link>
      <pubDate>Sat, 11 Oct 2014 10:52:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/10/11/lessons-from-running-neo4j-based-hackathons/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Neo4j: Generic/Vague relationship names</title>
      <link>https://markhneedham.com/blog/2014/09/30/neo4j-genericvague-relationship-names/</link>
      <pubDate>Tue, 30 Sep 2014 16:47:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/30/neo4j-genericvague-relationship-names/</guid>
      <description>Using a generic relationship type and then filtering by end node label 50%ile: 6.0 75%ile: 6.0 99%ile: 402.60999999999825 Using a generic relationship type and then filtering by relationship property 50%ile: 21.0 75%ile: 22.0 99%ile: 504.85999999999785 Using a generic relationship type and then filtering by end node label 50%ile: 4.0 75%ile: 4.0 99%ile: 145.65999999999931 Using a specific relationship type 50%ile: 0.0 75%ile: 1.0 99%ile: 25.749999999999872 Using a specific relationship typeneo4j-sh (?)$ profile match (n) where id(n) = 0 match (n)-[:HAS_ADDRESS]-&amp;gt;() return count(n); +----------+ | count(n) | +----------+ | 10000 | +----------+ 1 row ColumnFilter | +EagerAggregation | +SimplePatternMatcher | +NodeByIdOrEmpty +----------------------+-------+--------+-----------------------------+-----------------------+ | Operator | Rows | DbHits | Identifiers | Other | +----------------------+-------+--------+-----------------------------+-----------------------+ | ColumnFilter | 1 | 0 | | keep columns count(n) | | EagerAggregation | 1 | 0 | | | | SimplePatternMatcher | 10000 | 10000 | n, UNNAMED53, UNNAMED35 | | | NodeByIdOrEmpty | 1 | 1 | n, n | { AUTOINT0} | +----------------------+-------+--------+-----------------------------+-----------------------+ Total database accesses: 10001 Using a generic relationship type and then filtering by end node labelneo4j-sh (?</description>
    </item>
    
    <item>
      <title>Neo4j: COLLECTing multiple values (Too many parameters for function &#39;collect&#39;)</title>
      <link>https://markhneedham.com/blog/2014/09/26/neo4j-collecting-multiple-values-too-many-parameters-for-function-collect/</link>
      <pubDate>Fri, 26 Sep 2014 20:46:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/26/neo4j-collecting-multiple-values-too-many-parameters-for-function-collect/</guid>
      <description>create (p:Person {name: &amp;quot;Mark&amp;quot;}) create (e1:Event {name: &amp;quot;Event1&amp;quot;, timestamp: 1234}) create (e2:Event {name: &amp;quot;Event2&amp;quot;, timestamp: 4567}) create (p)-[:EVENT]-&amp;gt;(e1) create (p)-[:EVENT]-&amp;gt;(e2) $ MATCH (p:Person)-[:EVENT]-&amp;gt;(e) &amp;gt; RETURN p, COLLECT(e.name); +--------------------------------------------+ | p | COLLECT(e.name) | +--------------------------------------------+ | Node[0]{name:&amp;quot;Mark&amp;quot;} | [&amp;quot;Event1&amp;quot;,&amp;quot;Event2&amp;quot;] | +--------------------------------------------+ 1 row MATCH (p:Person)-[:EVENT]-&amp;gt;(e) RETURN p, COLLECT(e.name, e.timestamp) SyntaxException: Too many parameters for function &amp;#39;collect&amp;#39; (line 2, column 11) &amp;#34;RETURN p, COLLECT(e.name, e.timestamp)&amp;#34; ^ $ MATCH (p:Person)-[:EVENT]-&amp;gt;(e) &amp;gt; RETURN p, COLLECT([e.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Column is null</title>
      <link>https://markhneedham.com/blog/2014/09/24/neo4j-load-csv-column-is-null/</link>
      <pubDate>Wed, 24 Sep 2014 20:21:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/09/24/neo4j-load-csv-column-is-null/</guid>
      <description>$ cat ~/Downloads/dodgy.csv userId,movieId 1,2 $ load csv with headers from &amp;quot;file:/Users/markneedham/Downloads/dodgy.csv&amp;quot; as line return line; +----------------------------------+ | line | +----------------------------------+ | {userId -&amp;gt; &amp;quot;1&amp;quot;, movieId -&amp;gt; &amp;quot;2&amp;quot;} | +----------------------------------+ 1 row $ load csv with headers from &amp;quot;file:/Users/markneedham/Downloads/dodgy.csv&amp;quot; as line return line.userId; +-------------+ | line.userId | +-------------+ | &amp;lt;null&amp;gt; | +-------------+ 1 row $ load csv with headers from &amp;quot;file:/Users/markneedham/Downloads/dodgy.csv&amp;quot; as line return line.movieId; +--------------+ | line.movieId | +--------------+ | &amp;quot;2&amp;quot; | +--------------+ 1 row $ load csv with headers from &amp;quot;file:/Users/markneedham/Downloads/dodgy.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Handling empty columns</title>
      <link>https://markhneedham.com/blog/2014/08/22/neo4j-load-csv-handling-empty-columns/</link>
      <pubDate>Fri, 22 Aug 2014 12:51:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/08/22/neo4j-load-csv-handling-empty-columns/</guid>
      <description>$ cat /tmp/foo.csv a,b,c mark,, load csv with headers from &amp;quot;file:/tmp/foo.csv&amp;quot; as row MERGE (p:Person {a: row.a}) SET p.b = row.b, p.c = row.c RETURN p ==&amp;gt; +-----------------------------+ ==&amp;gt; | p | ==&amp;gt; +-----------------------------+ ==&amp;gt; | Node[5]{a:&amp;quot;mark&amp;quot;,b:&amp;quot;&amp;quot;,c:&amp;quot;&amp;quot;} | ==&amp;gt; +-----------------------------+ ==&amp;gt; 1 row ==&amp;gt; Nodes created: 1 ==&amp;gt; Properties set: 3 ==&amp;gt; Labels added: 1 ==&amp;gt; 26 ms load csv with headers from &amp;quot;file:/tmp/foo.csv&amp;quot; as row MERGE (p:Person {a: row.a}) FOREACH(ignoreMe IN CASE WHEN trim(row.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1.2: Finding where I am in a linked list</title>
      <link>https://markhneedham.com/blog/2014/07/20/neo4j-2-1-2-finding-where-i-am-in-a-linked-list/</link>
      <pubDate>Sun, 20 Jul 2014 15:13:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/20/neo4j-2-1-2-finding-where-i-am-in-a-linked-list/</guid>
      <description>public class Chains { public static void main(String[] args) { String simpleChains = &amp;#34;/tmp/longchains&amp;#34;; populate( simpleChains, 10000 ); } private static void populate( String path, int chainSize ) { GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( path ); try(Transaction tx = db.beginTx()) { Node currentNode = null; for ( int i = 0; i &amp;lt; chainSize; i++ ) { Node node = db.createNode(); if(currentNode != null) { currentNode.createRelationshipTo( node, NEXT ); } currentNode = node; } tx.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Processing hidden arrays in your CSV documents</title>
      <link>https://markhneedham.com/blog/2014/07/10/neo4j-load-csv-processing-hidden-arrays-in-your-csv-documents/</link>
      <pubDate>Thu, 10 Jul 2014 14:54:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/07/10/neo4j-load-csv-processing-hidden-arrays-in-your-csv-documents/</guid>
      <description>name,friends &amp;#34;Mark&amp;#34;,&amp;#34;Michael,Peter&amp;#34; &amp;#34;Michael&amp;#34;,&amp;#34;Peter,Kenny&amp;#34; &amp;#34;Kenny&amp;#34;,&amp;#34;Anders,Michael&amp;#34; $ load csv with headers from &amp;quot;file:/Users/markneedham/Desktop/friends.csv&amp;quot; AS row RETURN row; +------------------------------------------------+ | row | +------------------------------------------------+ | {name -&amp;gt; &amp;quot;Mark&amp;quot;, friends -&amp;gt; &amp;quot;Michael,Peter&amp;quot;} | | {name -&amp;gt; &amp;quot;Michael&amp;quot;, friends -&amp;gt; &amp;quot;Peter,Kenny&amp;quot;} | | {name -&amp;gt; &amp;quot;Kenny&amp;quot;, friends -&amp;gt; &amp;quot;Anders,Michael&amp;quot;} | +------------------------------------------------+ 3 rows $ load csv with headers from &amp;quot;file:/Users/markneedham/Desktop/friends.csv&amp;quot; AS row RETURN row, split(row.friends, &amp;quot;,&amp;quot;) AS friends; +-----------------------------------------------------------------------+ | row | friends | +-----------------------------------------------------------------------+ | {name -&amp;gt; &amp;quot;Mark&amp;quot;, friends -&amp;gt; &amp;quot;Michael,Peter&amp;quot;} | [&amp;quot;Michael&amp;quot;,&amp;quot;Peter&amp;quot;] | | {name -&amp;gt; &amp;quot;Michael&amp;quot;, friends -&amp;gt; &amp;quot;Peter,Kenny&amp;quot;} | [&amp;quot;Peter&amp;quot;,&amp;quot;Kenny&amp;quot;] | | {name -&amp;gt; &amp;quot;Kenny&amp;quot;, friends -&amp;gt; &amp;quot;Anders,Michael&amp;quot;} | [&amp;quot;Anders&amp;quot;,&amp;quot;Michael&amp;quot;] | +-----------------------------------------------------------------------+ 3 rows $ load csv with headers from &amp;quot;file:/Users/markneedham/Desktop/friends.</description>
    </item>
    
    <item>
      <title>Neo4j/R: Grouping meetup members by join timestamp</title>
      <link>https://markhneedham.com/blog/2014/06/30/neo4jr-grouping-meetup-members-by-join-timestamp/</link>
      <pubDate>Mon, 30 Jun 2014 00:06:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/30/neo4jr-grouping-meetup-members-by-join-timestamp/</guid>
      <description>&amp;gt; library(Rneo4j) &amp;gt; query = &amp;#34;match (:Person)-[:HAS_MEETUP_PROFILE]-&amp;gt;()-[:HAS_MEMBERSHIP]-&amp;gt;(membership)-[:OF_GROUP]-&amp;gt;(g:Group {name: \&amp;#34;Neo4j - London User Group\&amp;#34;}) RETURN membership.joined AS joinDate&amp;#34; &amp;gt; meetupMembers = cypher(graph, query) &amp;gt; meetupMembers[1:5,] [1] 1.389107e+12 1.376572e+12 1.379491e+12 1.349454e+12 1.383127e+12 &amp;gt; timestampToDate &amp;lt;- function(x) as.POSIXct(x / 1000, origin=&amp;#34;1970-01-01&amp;#34;) &amp;gt; meetupMembers$joined &amp;lt;- timestampToDate(meetupMembers$joinDate) &amp;gt; meetupMembers[1:5,] joinDate joined 1 1.389107e+12 2014-01-07 15:08:40 2 1.376572e+12 2013-08-15 14:13:40 3 1.379491e+12 2013-09-18 08:55:11 4 1.349454e+12 2012-10-05 17:28:04 5 1.383127e+12 2013-10-30 09:59:03 &amp;gt; dd = aggregate(meetupMembers$joined, by=list(format(meetupMembers$joined, &amp;#34;%m-%Y&amp;#34;)), function(x) length(x)) &amp;gt; colnames(dd) = c(&amp;#34;month&amp;#34;, &amp;#34;count&amp;#34;) &amp;gt; dd month count 1 01-2012 4 2 01-2013 52 3 01-2014 88 4 02-2012 7 5 02-2013 52 6 02-2014 91 7 03-2012 12 8 03-2013 23 9 03-2014 93 10 04-2012 3 11 04-2013 34 12 04-2014 119 13 05-2012 9 14 05-2013 69 15 05-2014 102 16 06-2011 14 17 06-2012 5 18 06-2013 39 19 06-2014 114 20 07-2011 4 21 07-2012 16 22 07-2013 20 23 08-2011 2 24 08-2012 34 25 08-2013 50 26 09-2012 14 27 09-2013 52 28 10-2011 2 29 10-2012 29 30 10-2013 42 31 11-2011 2 32 11-2012 31 33 11-2013 34 34 12-2012 7 35 12-2013 19 groupBy = function(dates, format) { dd = aggregate(dates, by= list(format(dates, format)), function(x) length(x)) colnames(dd) = c(&amp;#34;key&amp;#34;, &amp;#34;count&amp;#34;) dd } &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%Y&amp;#34;) key count 1 2011 24 2 2012 171 3 2013 486 4 2014 607 &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%A&amp;#34;) key count 1 Friday 135 2 Monday 287 3 Saturday 80 4 Sunday 102 5 Thursday 187 6 Tuesday 286 7 Wednesday 211 &amp;gt; groupBy(meetupMembers$joined, &amp;#34;%m&amp;#34;) key count 1 01 144 2 02 150 3 03 128 4 04 156 5 05 180 6 06 172 7 07 40 8 08 86 9 09 66 10 10 73 11 11 67 12 12 26 &amp;gt; groupBy(meetupMembers$joined[format(meetupMembers$joined, &amp;#34;%Y&amp;#34;) !</description>
    </item>
    
    <item>
      <title>Neo4j: Set Based Operations with the experimental Cypher optimiser</title>
      <link>https://markhneedham.com/blog/2014/06/29/neo4j-set-based-operations-with-the-experimental-cypher-optimiser/</link>
      <pubDate>Sun, 29 Jun 2014 08:45:34 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/29/neo4j-set-based-operations-with-the-experimental-cypher-optimiser/</guid>
      <description>MATCH (p:Person {name: &amp;quot;me&amp;quot;})-[:MEMBER_OF]-&amp;gt;(office {name: &amp;quot;London Office&amp;quot;})&amp;lt;-[:MEMBER_OF]-(colleague) WHERE NOT (p-[:COLLEAGUES]-&amp;gt;(colleague)) RETURN COUNT(colleague) MATCH (p:Person {name: &amp;quot;me&amp;quot;})-[:COLLEAGUES]-&amp;gt;(colleague) WITH p, COLLECT(colleague) as marksColleagues MATCH (colleague)-[:MEMBER_OF]-&amp;gt;(office {name: &amp;quot;London Office&amp;quot;})&amp;lt;-[:MEMBER_OF]-(p) WHERE NOT (colleague IN marksColleagues) RETURN COUNT(colleague) cypher 2.1.experimental MATCH (p:Person {name: &amp;quot;me&amp;quot;})-[:MEMBER_OF]-&amp;gt;(office {name: &amp;quot;London Office&amp;quot;})&amp;lt;-[:MEMBER_OF]-(colleague) WHERE NOT (p-[:COLLEAGUES]-&amp;gt;(colleague)) RETURN COUNT(colleague) $ python set-based.py cypher 2.1.experimental MATCH (p:Person {name: &amp;#34;me&amp;#34;})-[:MEMBER_OF]-&amp;gt;(office {name: &amp;#34;London Office&amp;#34;})&amp;lt;-[:MEMBER_OF]-(colleague) WHERE NOT (p-[:COLLEAGUES]-&amp;gt;(colleague)) RETURN COUNT(colleague) Min 0.719580888748 50% 0.723278999329 95% 0.741609430313 Max 0.</description>
    </item>
    
    <item>
      <title>Neo4j&#39;s Cypher vs Clojure - Group by and Sorting</title>
      <link>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</link>
      <pubDate>Sun, 29 Jun 2014 02:56:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/29/neo4j-cypher-vs-clojure-for-group-by-and-sorting/</guid>
      <description>CREATE (event1:Event {name: &amp;quot;Future Event 1&amp;quot;, timestamp: 1414002772427 }) CREATE (event2:Event {name: &amp;quot;Future Event 2&amp;quot;, timestamp: 1424002772427 }) CREATE (event3:Event {name: &amp;quot;Future Event 3&amp;quot;, timestamp: 1416002772427 }) CREATE (event4:Event {name: &amp;quot;Past Event 1&amp;quot;, timestamp: 1403002772427 }) CREATE (event5:Event {name: &amp;quot;Past Event 2&amp;quot;, timestamp: 1402002772427 }) $ MATCH (e:Event) RETURN e; ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | e | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; | Node[15414]{name:&amp;quot;Future Event 1&amp;quot;,timestamp:1414002772427} | ==&amp;gt; | Node[15415]{name:&amp;quot;Future Event 2&amp;quot;,timestamp:1424002772427} | ==&amp;gt; | Node[15416]{name:&amp;quot;Future Event 3&amp;quot;,timestamp:1416002772427} | ==&amp;gt; | Node[15417]{name:&amp;quot;Past Event 1&amp;quot;,timestamp:1403002772427} | ==&amp;gt; | Node[15418]{name:&amp;quot;Past Event 2&amp;quot;,timestamp:1402002772427} | ==&amp;gt; +------------------------------------------------------------+ ==&amp;gt; 5 rows ==&amp;gt; 13 ms (def sorted-query &amp;#34;MATCH (e:Event) WITH COLLECT(e) AS events WITH [e IN events WHERE e.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Finding movies by decade</title>
      <link>https://markhneedham.com/blog/2014/06/28/neo4j-cypher-finding-movies-by-decade/</link>
      <pubDate>Sat, 28 Jun 2014 11:12:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/28/neo4j-cypher-finding-movies-by-decade/</guid>
      <description>:play movies MATCH (movie:Movie) WHERE movie.released &amp;gt;= 1990 and movie.released &amp;lt;= 1999 RETURN 1990 + &amp;quot;-&amp;quot; + 1999 as years, count(movie) AS movies ORDER BY years ==&amp;gt; +----------------------+ ==&amp;gt; | years | movies | ==&amp;gt; +----------------------+ ==&amp;gt; | &amp;#34;1990-1999&amp;#34; | 21 | ==&amp;gt; +----------------------+ ==&amp;gt; 1 row WITH 1990 AS startDecade, 1999 AS endDecade MATCH (movie:Movie) WHERE movie.released &amp;gt;= startDecade and movie.released &amp;lt;= endDecade RETURN startDecade + &amp;quot;-&amp;quot; + endDecade as years, count(movie) ORDER BY years UNWIND [{start: 1970, end: 1979}, {start: 1980, end: 1989}, {start: 1980, end: 1989}, {start: 1990, end: 1999}, {start: 2000, end: 2009}, {start: 2010, end: 2019}] AS row WITH row.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Separation of concerns</title>
      <link>https://markhneedham.com/blog/2014/06/27/neo4j-cypher-separation-of-concerns/</link>
      <pubDate>Fri, 27 Jun 2014 10:51:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/27/neo4j-cypher-separation-of-concerns/</guid>
      <description>MATCH (event:Event {id: {eventId}})-[:HELD_AT]-&amp;gt;(venue) OPTIONAL MATCH (event)&amp;lt;-[:TO]-(rsvp)&amp;lt;-[:RSVPD]-(person) OPTIONAL MATCH (person)-[:INTERESTED_IN]-&amp;gt;(topic) WHERE ()-[:HAS_TOPIC]-&amp;gt;(topic) WITH event, venue, rsvp, person, COLLECT(topic) as topics ORDER BY rsvp.time OPTIONAL MATCH (rsvp)&amp;lt;-[:NEXT]-(initial) WITH event, venue, COLLECT({rsvp: rsvp, initial: initial, person: person, topics: topics}) AS responses WITH event, venue, [response in responses WHERE response.initial is null AND response.rsvp.response = &amp;quot;yes&amp;quot;] as attendees, [response in responses WHERE NOT response.initial is null] as dropouts, responses UNWIND([response in attendees | response.</description>
    </item>
    
    <item>
      <title>Neo4j: LOAD CSV - Handling conditionals</title>
      <link>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</link>
      <pubDate>Tue, 17 Jun 2014 23:41:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/06/17/neo4j-load-csv-handling-conditionals/</guid>
      <description>match_id,player,player_id,time,type &amp;#34;1012&amp;#34;,&amp;#34;Antonin Panenka&amp;#34;,&amp;#34;174835&amp;#34;,21,&amp;#34;penalty&amp;#34; &amp;#34;1012&amp;#34;,&amp;#34;Faisal Al Dakhil&amp;#34;,&amp;#34;2204&amp;#34;,57,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Roger Milla&amp;#34;,&amp;#34;79318&amp;#34;,106,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Roger Milla&amp;#34;,&amp;#34;79318&amp;#34;,108,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Bernardo Redin&amp;#34;,&amp;#34;44555&amp;#34;,115,&amp;#34;goal&amp;#34; &amp;#34;102&amp;#34;,&amp;#34;Andre Kana-biyik&amp;#34;,&amp;#34;174649&amp;#34;,44,&amp;#34;yellow&amp;#34; LOAD CSV WITH HEADERS FROM &amp;quot;https://raw.githubusercontent.com/mneedham/neo4j-worldcup/master/data/import/events.csv&amp;quot; AS csvLine // removed for conciseness // goals FOREACH(n IN (CASE WHEN csvLine.type IN [&amp;quot;penalty&amp;quot;, &amp;quot;goal&amp;quot;, &amp;quot;owngoal&amp;quot;] THEN [1] else [] END) | FOREACH(t IN CASE WHEN team = home THEN [home] ELSE [away] END | MERGE (stats)-[:SCORED_GOAL]-&amp;gt;(penalty:Goal {time: csvLine.time, type: csvLine.type}) )	) // cards FOREACH(n IN (CASE WHEN csvLine.</description>
    </item>
    
    <item>
      <title>Neo4j Meetup Coding Dojo Style</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4j-meetup-coding-dojo-style/</link>
      <pubDate>Sat, 31 May 2014 22:55:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4j-meetup-coding-dojo-style/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - UNWIND vs FOREACH</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</link>
      <pubDate>Sat, 31 May 2014 14:19:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-unwind-vs-foreach/</guid>
      <description>I&amp;#8217;ve written a couple of posts about the new UNWIND clause in Neo4j&amp;#8217;s cypher query language but I forgot about my favourite use of UNWIND, which is to get rid of some uses of FOREACH from our queries.
 Let&amp;#8217;s say we&amp;#8217;ve created a timetree up front and now have a series of events coming in that we want to create in the database and attach to the appropriate part of the timetree.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Neo.ClientError.Statement.ParameterMissing and neo4j-shell</title>
      <link>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-neo-clienterror-statement-parametermissing-and-neo4j-shell/</link>
      <pubDate>Sat, 31 May 2014 12:44:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/31/neo4j-cypher-neo-clienterror-statement-parametermissing-and-neo4j-shell/</guid>
      <description>CREATE (u:User {name: &amp;quot;Mark&amp;quot;}) MATCH (u:User {name: {name}}) RETURN u Expected a parameter named name Neo.ClientError.Statement.ParameterMissing $ MATCH (u:User {name: {name}}) RETURN u; ParameterNotFoundException: Expected a parameter named name $ export name=&amp;quot;Mark&amp;quot; $ MATCH (u:User {name: {name}}) RETURN u; +-------------------------+ | u | +-------------------------+ | Node[1923]{name:&amp;quot;Mark&amp;quot;} | +-------------------------+ 1 row $ export name = &amp;#34;Mark&amp;#34; name is no valid variable name. May only contain alphanumeric characters and underscores. $ export params={ name: &amp;#34;Mark&amp;#34; } $ MATCH (u:User {name: {params}.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Rounding a float value to decimal places</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</link>
      <pubDate>Sun, 25 May 2014 22:17:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-cypher-rounding-a-float-value-to-decimal-places/</guid>
      <description>RETURN toFloat(&amp;quot;12.336666&amp;quot;) AS value WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value RETURN round(100 * value) / 100 AS value 12.34 WITH 2 as precision WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value, 10^precision AS factor RETURN round(factor * value)/factor AS value WITH 4 as precision WITH toFloat(&amp;quot;12.336666&amp;quot;) AS value, 10^precision AS factor RETURN round(factor * value)/factor AS value 12.3367 </description>
    </item>
    
    <item>
      <title>Neo4j 2.1:  Passing around node ids vs UNWIND</title>
      <link>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</link>
      <pubDate>Sun, 25 May 2014 10:48:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/25/neo4j-2-1-passing-around-node-ids-vs-unwind/</guid>
      <description>MATCH (g:Group) WITH g ORDER BY g.name LIMIT 5 WITH COLLECT(id(g)) AS groups MATCH (g1) WHERE id(g1) IN groups MATCH (g2) WHERE id(g2) IN groups OPTIONAL MATCH path = (g1)&amp;lt;-[:MEMBER_OF]-()-[:MEMBER_OF]-&amp;gt;(g2) RETURN g1.name, g2.name, CASE WHEN path is null THEN 0 ELSE COUNT(path) END AS overlap MATCH (g:Group) WITH g ORDER BY g.name LIMIT 5 WITH COLLECT(g) AS groups MATCH (g1) WHERE g1 IN groups MATCH (g2) WHERE g2 IN groups OPTIONAL MATCH path = (g1)&amp;lt;-[:MEMBER_OF]-()-[:MEMBER_OF]-&amp;gt;(g2) RETURN g1.</description>
    </item>
    
    <item>
      <title>Neo4j 2.1: Creating adjacency matrices</title>
      <link>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</link>
      <pubDate>Tue, 20 May 2014 23:14:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/05/20/neo4j-2-0-creating-adjacency-matrices/</guid>
      <description>About 9 months ago I wrote a blog post showing how to export an adjacency matrix from a Neo4j 1.9 database using the cypher query language and I thought it deserves an update to use 2.0 syntax.
 I&amp;#8217;ve been spending some of my free time working on an application that runs on top of meetup.com&amp;#8217;s API and one of the queries I wanted to write was to find the common members between 2 meetup groups.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Flatten a collection</title>
      <link>https://markhneedham.com/blog/2014/04/23/neo4j-cypher-flatten-a-collection/</link>
      <pubDate>Wed, 23 Apr 2014 22:02:19 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/23/neo4j-cypher-flatten-a-collection/</guid>
      <description>$ RETURN [[1,2,3], [4,5,6], [7,8,9]] AS result; ==&amp;gt; +---------------------------+ ==&amp;gt; | result | ==&amp;gt; +---------------------------+ ==&amp;gt; | [[1,2,3],[4,5,6],[7,8,9]] | ==&amp;gt; +---------------------------+ ==&amp;gt; 1 row $ WITH [[1,2,3], [4,5,6], [7,8,9]] AS result RETURN REDUCE(output = [], r IN result | output + r) AS flat; ==&amp;gt; +---------------------+ ==&amp;gt; | flat | ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8,9] | ==&amp;gt; +---------------------+ ==&amp;gt; 1 row ==&amp;gt; SyntaxException: Type mismatch: expected Any, Collection&amp;lt;Any&amp;gt; or Collection&amp;lt;Collection&amp;lt;Any&amp;gt;&amp;gt; but was Integer (line 1, column 148) WITH [[1,2,3], [4,5,6], [7,8,9]] AS result RETURN REDUCE(output = range(0,-1), r IN result | output + r); $ RETURN [[1,2,3], [4], [5, [6, 7]], [8,9]] AS result; ==&amp;gt; +-------------------------------+ ==&amp;gt; | result | ==&amp;gt; +-------------------------------+ ==&amp;gt; | [[1,2,3],[4],[5,[6,7]],[8,9]] | ==&amp;gt; +-------------------------------+ ==&amp;gt; 1 row $ WITH [[1,2,3], [4], [5, [6, 7]], [8,9]] AS result RETURN REDUCE(output = [], r IN result | output + REDUCE(innerOutput = [], innerR in r | innerOutput + innerR)) AS flat; ==&amp;gt; +---------------------+ ==&amp;gt; | flat | ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4,5,6,7,8,9] | ==&amp;gt; +---------------------+ ==&amp;gt; 1 row </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Creating a time tree down to the day</title>
      <link>https://markhneedham.com/blog/2014/04/19/neo4j-cypher-creating-a-time-tree-down-to-the-day/</link>
      <pubDate>Sat, 19 Apr 2014 21:15:21 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/19/neo4j-cypher-creating-a-time-tree-down-to-the-day/</guid>
      <description>WITH range(2011, 2014) AS years, range(1,12) as months FOREACH(year IN years | MERGE (y:Year {year: year}) FOREACH(month IN months | CREATE (m:Month {month: month}) MERGE (y)-[:HAS_MONTH]-&amp;gt;(m) FOREACH(day IN (CASE WHEN month IN [1,3,5,7,8,10,12] THEN range(1,31) WHEN month = 2 THEN CASE WHEN year % 4 &amp;lt;&amp;gt; 0 THEN range(1,28) WHEN year % 100 &amp;lt;&amp;gt; 0 THEN range(1,29) WHEN year % 400 = 0 THEN range(1,29) ELSE range(1,28) END ELSE range(1,30) END) | CREATE (d:Day {day: day}) MERGE (m)-[:HAS_DAY]-&amp;gt;(d)))) (jan31)-[:NEXT]-&amp;gt;(feb1)-[:NEXT]-&amp;gt;(feb2) MATCH (year:Year)-[:HAS_MONTH]-&amp;gt;(month)-[:HAS_DAY]-&amp;gt;(day) WITH year,month,day ORDER BY year.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.1: Cypher - Concatenating an empty collection / Type mismatch: expected Integer, Collection&amp;lt;Integer&amp;gt; or Collection&amp;lt;Collection&amp;lt;Integer&amp;gt;&amp;gt; but was Collection&amp;lt;Any&amp;gt;</title>
      <link>https://markhneedham.com/blog/2014/04/19/neo4j-2-0-1-cypher-concatenating-an-empty-collection-type-mismatch-expected-integer-collection-or-collection-but-was-collection/</link>
      <pubDate>Sat, 19 Apr 2014 19:51:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/19/neo4j-2-0-1-cypher-concatenating-an-empty-collection-type-mismatch-expected-integer-collection-or-collection-but-was-collection/</guid>
      <description>$ RETURN [1,2,3,4] + [5,6,7]; ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4] + [5,6,7] | ==&amp;gt; +---------------------+ ==&amp;gt; | [1,2,3,4,5,6,7] | ==&amp;gt; +---------------------+ ==&amp;gt; 1 row $ RETURN [1,2,3,4] + []; ==&amp;gt; SyntaxException: Type mismatch: expected Integer, Collection&amp;lt;Integer&amp;gt; or Collection&amp;lt;Collection&amp;lt;Integer&amp;gt;&amp;gt; but was Collection&amp;lt;Any&amp;gt; (line 1, column 20) ==&amp;gt; &amp;quot;RETURN [1,2,3,4] + []&amp;quot; ==&amp;gt; ^ $ RETURN [1,2,3,4] + RANGE(0,-1); ==&amp;gt; +-------------------------+ ==&amp;gt; | [1,2,3,4] + RANGE(0,-1) | ==&amp;gt; +-------------------------+ ==&amp;gt; | [1,2,3,4] | ==&amp;gt; +-------------------------+ ==&amp;gt; 1 row $ RETURN [1,2,3,4] + []; ==&amp;gt; +----------------+ ==&amp;gt; | [1,2,3,4] + [] | ==&amp;gt; +----------------+ ==&amp;gt; | [1,2,3,4] | ==&amp;gt; +----------------+ ==&amp;gt; 1 row </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Creating relationships between a collection of nodes / Invalid input &#39;[&#39;:</title>
      <link>https://markhneedham.com/blog/2014/04/19/neo4j-cypher-creating-relationships-between-a-collection-of-nodes-invalid-input/</link>
      <pubDate>Sat, 19 Apr 2014 06:33:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/19/neo4j-cypher-creating-relationships-between-a-collection-of-nodes-invalid-input/</guid>
      <description>MERGE (day1:Day {day:1 }) MERGE (day2:Day {day:2 }) MERGE (day3:Day {day:3 }) RETURN day1, day2, day3 (day1)-[:NEXT]-&amp;gt;(day2)-[:NEXT]-&amp;gt;(day3) MATCH (day:Day) WITH day ORDER BY day.day WITH COLLECT(day) AS days FOREACH(i in RANGE(0, length(days)-2) | CREATE UNIQUE (days[i])-[:NEXT]-&amp;gt;(days[i+1])) Invalid input &amp;#39;[&amp;#39;: expected an identifier character, node labels, a property map, whitespace, &amp;#39;)&amp;#39; or a relationship pattern (line 6, column 32) &amp;#34; CREATE UNIQUE (days[i])-[:NEXT]-&amp;gt;(days[i+1]))&amp;#34; ^ MATCH (day:Day) WITH day ORDER BY day.day WITH COLLECT(day) AS days FOREACH(i in RANGE(0, length(days)-2) | FOREACH(day1 in [days[i]] | FOREACH(day2 in [days[i+1]] | CREATE UNIQUE (day1)-[:NEXT]-&amp;gt;(day2)))) </description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0: Query not prepared correctly / Type mismatch: expected Map</title>
      <link>https://markhneedham.com/blog/2014/04/13/neo4j-2-0-0-query-not-prepared-correctly-type-mismatch-expected-map/</link>
      <pubDate>Sun, 13 Apr 2014 17:40:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/04/13/neo4j-2-0-0-query-not-prepared-correctly-type-mismatch-expected-map/</guid>
      <description>WITH {person: {id: 1}} AS params MERGE (p:Person {id: params.person.id}) RETURN p ==&amp;gt; SyntaxException: Type mismatch: expected Map but was Boolean, Number, String or Collection&amp;lt;Any&amp;gt; (line 1, column 62) ==&amp;gt; &amp;#34;WITH {person: {id: 1}} AS params MERGE (p:Person {id: params.person.id}) RETURN p&amp;#34; ==&amp;gt; +---------------+ ==&amp;gt; | p | ==&amp;gt; +---------------+ ==&amp;gt; | Node[1]{id:} | ==&amp;gt; +---------------+ ==&amp;gt; 1 row ==&amp;gt; Nodes created: 1 ==&amp;gt; Properties set: 1 ==&amp;gt; Labels added: 1 ==&amp;gt; 47 ms WITH {topics: [{name: &amp;quot;Java&amp;quot;}, {name: &amp;quot;Neo4j&amp;quot;}]} AS params MERGE (p:Person {id: 2}) FOREACH(t IN params.</description>
    </item>
    
    <item>
      <title>Remote profiling Neo4j using yourkit</title>
      <link>https://markhneedham.com/blog/2014/03/24/remote-profiling-neo4j-using-yourkit/</link>
      <pubDate>Mon, 24 Mar 2014 23:44:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/03/24/remote-profiling-neo4j-using-yourkit/</guid>
      <description>wrapper.java.additional=-agentpath:/Users/markhneedham/Downloads/YourKit_Java_Profiler_2013_build_13074.app/bin/mac/libyjpagent.jnilib=port=8888 java 4388 markhneedham 20u IPv6 0x901df453b4e9a125 0t0 TCP *:8888 (LISTEN) ... </description>
    </item>
    
    <item>
      <title>Neo4j 2.1.0-M01: LOAD CSV with Rik Van Bruggen&#39;s Tube Graph</title>
      <link>https://markhneedham.com/blog/2014/03/03/neo4j-2-1-0-m01-load-csv-with-rik-van-bruggens-tube-graph/</link>
      <pubDate>Mon, 03 Mar 2014 16:34:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/03/03/neo4j-2-1-0-m01-load-csv-with-rik-van-bruggens-tube-graph/</guid>
      <description>CREATE INDEX on :Station(stationName) LOAD CSV FROM &amp;quot;file:/Users/markhneedham/code/tube/runtimes.csv&amp;quot; AS csvLine WITH csvLine[0] AS lineName, csvLine[1] AS direction, csvLine[2] AS startStationName, csvLine[3] AS destinationStationName, toFloat(csvLine[4]) AS distance, toFloat(csvLine[5]) AS runningTime MERGE (start:Station { stationName: startStationName}) MERGE (destination:Station { stationName: destinationStationName}) MERGE (line:Line { lineName: lineName}) MERGE (line) - [:DIRECTION] -&amp;gt; (dir:Direction { direction: direction}) CREATE (inPlatform:InPlatform {name: &amp;quot;In: &amp;quot; + destinationStationName + &amp;quot; &amp;quot; + lineName + &amp;quot; &amp;quot; + direction}) CREATE (outPlatform:OutPlatform {name: &amp;quot;Out: &amp;quot; + startStationName + &amp;quot; &amp;quot; + lineName + &amp;quot; &amp;quot; + direction}) CREATE (inPlatform) - [:AT] -&amp;gt; (destination) CREATE (outPlatform) - [:AT] -&amp;gt; (start) CREATE (inPlatform) - [:ON] -&amp;gt; (dir) CREATE (outPlatform) - [:ON] -&amp;gt; (dir) CREATE (outPlatform) - [r:TRAIN {distance: distance, runningTime: runningTime}] -&amp;gt; (inPlatform) MATCH (station:Station) &amp;lt;-[:AT]- (platformIn:InPlatform), (station:Station) &amp;lt;-[:AT]- (platformOut:OutPlatform), (direction:Direction) &amp;lt;-[:ON]- (platformIn:InPlatform), (direction:Direction) &amp;lt;-[:ON]- (platformOut:OutPlatform) CREATE (platformIn) -[:WAIT {runningTime: 0.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Finding directors who acted in their own movie</title>
      <link>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</link>
      <pubDate>Fri, 28 Feb 2014 22:57:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/28/neo4j-cypher-finding-directors-who-acted-in-their-own-movie/</guid>
      <description>MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(d) WHERE a.name = d.name RETURN a MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(d) WHERE a = d RETURN a MATCH (a)-[:ACTED_IN]-&amp;gt;(m)&amp;lt;-[:DIRECTED]-(a) RETURN a </description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Set Based Operations</title>
      <link>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</link>
      <pubDate>Thu, 20 Feb 2014 18:22:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/20/neo4j-cypher-set-based-operations/</guid>
      <description>public class SetBasedOperations { private static final Label PERSON = DynamicLabel.label( &amp;#34;Person&amp;#34; ); private static final Label OFFICE = DynamicLabel.label( &amp;#34;Office&amp;#34; ); private static final DynamicRelationshipType COLLEAGUES = DynamicRelationshipType.withName( &amp;#34;COLLEAGUES&amp;#34; ); private static final DynamicRelationshipType MEMBER_OF = DynamicRelationshipType.withName( &amp;#34;MEMBER_OF&amp;#34; ); public static void main( String[] args ) throws IOException { Random random = new Random(); String path = &amp;#34;/tmp/set-based-operations&amp;#34;; FileUtils.deleteRecursively( new File( path ) ); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( path ); Transaction tx = db.</description>
    </item>
    
    <item>
      <title>Neo4j: Creating nodes and relationships from a list of maps</title>
      <link>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</link>
      <pubDate>Mon, 17 Feb 2014 14:11:07 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/17/neo4j-creating-nodes-and-relationships-from-a-list-of-maps/</guid>
      <description>MERGE (me:User {userId: 1} ) SET me.name = &amp;quot;Mark&amp;quot; FOREACH (f IN [{userId: 2, name: &amp;quot;Michael&amp;quot;}, {userId: 3, name: &amp;quot;Peter&amp;quot;}] | MERGE (u:User {userId: f.userId}) SET u = f MERGE (me)-[:FRIENDS_WITH]-&amp;gt;(u)) MERGE (me:User { userId: {userId} }) SET me.name = {name} FOREACH(f IN {friends} | MERGE (u:User {userId: f.userId }) SET u = f MERGE (me)-[:FRIENDS_WITH]-&amp;gt;(u)) public class ListsOfMapsCypher { public static void main( String[] args ) { ObjectNode request = JsonNodeFactory.</description>
    </item>
    
    <item>
      <title>Neo4j: Value in relationships, but value in nodes too!</title>
      <link>https://markhneedham.com/blog/2014/02/13/neo4j-value-in-relationships-but-value-in-nodes-too/</link>
      <pubDate>Thu, 13 Feb 2014 00:10:37 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/13/neo4j-value-in-relationships-but-value-in-nodes-too/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Jython/Neo4j: java.lang.ExceptionInInitializerError: java.lang.ExceptionInInitializerError</title>
      <link>https://markhneedham.com/blog/2014/02/05/jythonneo4j-java-lang-exceptionininitializererror-java-lang-exceptionininitializererror/</link>
      <pubDate>Wed, 05 Feb 2014 12:21:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/02/05/jythonneo4j-java-lang-exceptionininitializererror-java-lang-exceptionininitializererror/</guid>
      <description>$ jython -Dpython.path /path/to/neo4j.jar Jython 2.5.3 (2.5:c56500f08d34+, Aug 13 2012, 14:48:36) [Java HotSpot(TM) 64-Bit Server VM (Oracle Corporation)] on java1.7.0_45 Type &amp;#34;help&amp;#34;, &amp;#34;copyright&amp;#34;, &amp;#34;credits&amp;#34; or &amp;#34;license&amp;#34; for more information. &amp;gt;&amp;gt;&amp;gt; import org.neo4j.graphdb.factory &amp;gt;&amp;gt;&amp;gt; org.neo4j.graphdb.factory.GraphDatabaseFactory().newEmbeddedDatabase(&amp;#34;/tmp/foo&amp;#34;) Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; at org.neo4j.graphdb.factory.GraphDatabaseFactory$1.newDatabase(GraphDatabaseFactory.java:83) at org.neo4j.graphdb.factory.GraphDatabaseBuilder.newGraphDatabase(GraphDatabaseBuilder.java:198) at org.neo4j.graphdb.factory.GraphDatabaseFactory.newEmbeddedDatabase(GraphDatabaseFactory.java:69) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) java.lang.ExceptionInInitializerError: java.lang.ExceptionInInitializerError &amp;gt;&amp;gt;&amp;gt; import org.neo4j.graphdb.factory.GraphDatabaseSettings Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; java.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0: Optimising a football query</title>
      <link>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-optimising-a-football-query/</link>
      <pubDate>Fri, 31 Jan 2014 22:41:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-optimising-a-football-query/</guid>
      <description>MATCH (game)&amp;lt;-[:contains_match]-(season:Season), (team)&amp;lt;-[:away_team]-(game), (stats)-[:in]-&amp;gt;(game), (team)&amp;lt;-[:for]-(stats)&amp;lt;-[:played]-(player) WHERE season.name = &amp;quot;2012-2013&amp;quot; RETURN player.name, COLLECT(DISTINCT team.name), SUM(stats.goals) as goals ORDER BY goals DESC LIMIT 10 MATCH (game)&amp;lt;-[:contains_match]-(season:Season) MATCH (team)&amp;lt;-[:away_team]-(game) MATCH (stats)-[:in]-&amp;gt;(game) MATCH (team)&amp;lt;-[:for]-(stats)&amp;lt;-[:played]-(player) WHERE season.name = &amp;quot;2012-2013&amp;quot; RETURN player.name, COLLECT(DISTINCT team.name), SUM(stats.goals) as goals ORDER BY goals DESC LIMIT 10 MATCH (game)&amp;lt;-[:contains_match]-(season:Season) WHERE season.name = &amp;quot;2012-2013&amp;quot; MATCH (team)&amp;lt;-[:away_team]-(game) MATCH (stats)-[:in]-&amp;gt;(game) MATCH (team)&amp;lt;-[:for]-(stats)&amp;lt;-[:played]-(player) RETURN player.name, COLLECT(DISTINCT team.name), SUM(stats.goals) as goals ORDER BY goals DESC LIMIT 10 MATCH (team)&amp;lt;-[:away_team]-(game) MATCH (game)&amp;lt;-[:contains_match]-(season:Season) WHERE season.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0: Cypher - Index Hints and Neo.ClientError.Schema.NoSuchIndex</title>
      <link>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</link>
      <pubDate>Fri, 31 Jan 2014 07:14:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/31/neo4j-2-0-0-cypher-index-hints-and-neo-clienterror-schema-nosuchindex/</guid>
      <description>CREATE INDEX ON :Player(name) MATCH p USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; RETURN p Cannot use index hint in this context. The label and property comparison must be specified on a non-optional node Label: `Player` Property name: `name` Neo.ClientError.Schema.NoSuchIndex MATCH (p:Player) USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; RETURN p MATCH (p:Player) USING INDEX p:Player(name) WHERE p.name = &amp;quot;Wayne Rooney&amp;quot; OR p.name = &amp;quot;Robin Van Persie&amp;quot; RETURN p Cannot use index hint in this context.</description>
    </item>
    
    <item>
      <title>Neo4j: org.eclipse.jetty.io.EofException - Caused by: java.io.IOException: Broken pipe</title>
      <link>https://markhneedham.com/blog/2014/01/27/neo4j-org-eclipse-jetty-io-eofexception-caused-by-java-io-ioexception-broken-pipe/</link>
      <pubDate>Mon, 27 Jan 2014 11:32:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/27/neo4j-org-eclipse-jetty-io-eofexception-caused-by-java-io-ioexception-broken-pipe/</guid>
      <description>SEVERE: The response of the WebApplicationException cannot be utilized as the response is already committed. Re-throwing to the HTTP container javax.ws.rs.WebApplicationException: javax.ws.rs.WebApplicationException: org.eclipse.jetty.io.EofException at org.neo4j.server.rest.repr.OutputFormat$1.write(OutputFormat.java:174) at com.sun.jersey.core.impl.provider.entity.StreamingOutputProvider.writeTo(StreamingOutputProvider.java:71) at com.sun.jersey.core.impl.provider.entity.StreamingOutputProvider.writeTo(StreamingOutputProvider.java:57) at com.sun.jersey.spi.container.ContainerResponse.write(ContainerResponse.java:306) at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1437) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1349) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1339) at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:416) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:537) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:699) at javax.servlet.http.HttpServlet.service(HttpServlet.java:848) at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:698) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1506) at org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1477) at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:503) at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:211) at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1096) at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:432) at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:175) at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1030) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:136) at org.eclipse.jetty.server.handler.HandlerList.handle(HandlerList.java:52) at org.</description>
    </item>
    
    <item>
      <title>Neo4j HA: org.neo4j.graphdb.TransactionFailureException: Timeout waiting for database to allow new transactions. Blocking components (1): []</title>
      <link>https://markhneedham.com/blog/2014/01/27/neo4j-ha-org-neo4j-graphdb-transactionfailureexception-timeout-waiting-for-database-to-allow-new-transactions-blocking-components-1/</link>
      <pubDate>Mon, 27 Jan 2014 09:42:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/27/neo4j-ha-org-neo4j-graphdb-transactionfailureexception-timeout-waiting-for-database-to-allow-new-transactions-blocking-components-1/</guid>
      <description>org.neo4j.graphdb.TransactionFailureException: Timeout waiting for database to allow new transactions. Blocking components (1): [] at org.neo4j.kernel.ha.HighlyAvailableGraphDatabase.beginTx(HighlyAvailableGraphDatabase.java:199) at org.neo4j.kernel.TransactionBuilderImpl.begin(TransactionBuilderImpl.java:43) at org.neo4j.kernel.InternalAbstractGraphDatabase.beginTx(InternalAbstractGraphDatabase.java:949) at org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:52) at com.sun.jersey.server.impl.uri.rules.HttpMethodRule.accept(HttpMethodRule.java:288) at com.sun.jersey.server.impl.uri.rules.ResourceClassRule.accept(ResourceClassRule.java:108) at com.sun.jersey.server.impl.uri.rules.RightHandPathRule.accept(RightHandPathRule.java:147) at com.sun.jersey.server.impl.uri.rules.RootResourceClassesRule.accept(RootResourceClassesRule.java:84) at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1469) at com.sun.jersey.server.impl.application.WebApplicationImpl._handleRequest(WebApplicationImpl.java:1400) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1349) at com.sun.jersey.server.impl.application.WebApplicationImpl.handleRequest(WebApplicationImpl.java:1339) at com.sun.jersey.spi.container.servlet.WebComponent.service(WebComponent.java:416) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:537) at com.sun.jersey.spi.container.servlet.ServletContainer.service(ServletContainer.java:699) at javax.servlet.http.HttpServlet.service(HttpServlet.java:848) at org.eclipse.jetty.servlet.ServletHolder.handle(ServletHolder.java:698) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1506) at org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112) at org.eclipse.jetty.servlet.ServletHandler$CachedChain.doFilter(ServletHandler.java:1477) at org.eclipse.jetty.servlet.ServletHandler.doHandle(ServletHandler.java:503) at org.eclipse.jetty.server.session.SessionHandler.doHandle(SessionHandler.java:211) at org.eclipse.jetty.server.handler.ContextHandler.doHandle(ContextHandler.java:1096) at org.eclipse.jetty.servlet.ServletHandler.doScope(ServletHandler.java:432) at org.eclipse.jetty.server.session.SessionHandler.doScope(SessionHandler.java:175) at org.eclipse.jetty.server.handler.ContextHandler.doScope(ContextHandler.java:1030) at org.eclipse.jetty.server.handler.ScopedHandler.handle(ScopedHandler.java:136) at org.eclipse.jetty.server.handler.HandlerList.handle(HandlerList.java:52) at org.</description>
    </item>
    
    <item>
      <title>Neo4j HA: Election could not pick a winner</title>
      <link>https://markhneedham.com/blog/2014/01/24/neo4j-ha-election-could-not-pick-a-winner/</link>
      <pubDate>Fri, 24 Jan 2014 10:30:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/24/neo4j-ha-election-could-not-pick-a-winner/</guid>
      <description>2014-01-23 11:17:24.510+0000 INFO [o.n.c.p.a.m.MultiPaxosContext$ElectionContextImpl]: Doing elections for role coordinator 2014-01-23 11:17:24.510+0000 DEBUG [o.n.c.p.e.ElectionState$2]: ElectionState: election-[performRoleElections]-&amp;gt;election from:cluster://10.239.8.251:5001 conversation-id:3/13# 2014-01-23 11:17:24.513+0000 DEBUG [o.n.c.p.e.ElectionState$2]: ElectionState: election-[vote:coordinator]-&amp;gt;election from:cluster://10.151.24.237:5001 conversation-id:3/13# 2014-01-23 11:17:24.515+0000 DEBUG [o.n.c.p.e.ElectionState$2]: ElectionState: election-[voted]-&amp;gt;election from:cluster://10.138.29.197:5001 conversation-id:3/13# 2014-01-23 11:17:24.516+0000 DEBUG [o.n.c.p.e.ElectionState$2]: ElectionState: election-[voted]-&amp;gt;election from:cluster://10.151.24.237:5001 conversation-id:3/13# 2014-01-23 11:17:24.519+0000 DEBUG [o.n.c.p.a.m.MultiPaxosContext$ElectionContextImpl$2]: Elections ended up with list [] 2014-01-23 11:17:24.519+0000 WARN [o.n.c.p.e.ElectionState]: Election could not pick a winner </description>
    </item>
    
    <item>
      <title>Neo4j Backup: Store copy and consistency check</title>
      <link>https://markhneedham.com/blog/2014/01/22/neo4j-backup-store-copy-and-consistency-check/</link>
      <pubDate>Wed, 22 Jan 2014 17:36:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/22/neo4j-backup-store-copy-and-consistency-check/</guid>
      <description>$ pwd /Users/markneedham/Downloads/neo4j-enterprise-2.0.0 $ ./bin/neo4j-backup -from single://127.0.0.1 -to /tmp/foo -verify false Performing full backup from &amp;#39;single://127.0.0.1&amp;#39; Files copied ................ done Done $ ./bin/neo4j-backup -from single://127.0.0.1 -to /tmp/foo Performing full backup from &amp;#39;single://127.0.0.1&amp;#39; Files copied ................ done Full consistency check .................... 10% .................... 20% .................... 30% .................... 40% .................... 50% .................... 60% .................... 70% .................... 80% .................... 90% .................... 100% Done $ java -cp &amp;#39;lib/*:system/lib/*&amp;#39; org.neo4j.consistency.ConsistencyCheckTool /tmp/foo Full consistency check .................... 10% .</description>
    </item>
    
    <item>
      <title>Neo4j Backup: java.lang.ClassCastException: org.jboss.netty.buffer.BigEndianHeapChannelBuffer cannot be cast to org.neo4j.cluster.com.message.Message</title>
      <link>https://markhneedham.com/blog/2014/01/19/neo4j-backup-java-lang-classcastexception-org-jboss-netty-buffer-bigendianheapchannelbuffer-cannot-be-cast-to-org-neo4j-cluster-com-message-message/</link>
      <pubDate>Sun, 19 Jan 2014 19:29:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2014/01/19/neo4j-backup-java-lang-classcastexception-org-jboss-netty-buffer-bigendianheapchannelbuffer-cannot-be-cast-to-org-neo4j-cluster-com-message-message/</guid>
      <description>./neo4j-backup -from single://192.168.1.34 -to /mnt/backup/neo4j-backup online_backup_server=192.168.1.34:6363 ./neo4j-backup -from single://192.168.1.34:6363 -to /mnt/backup/neo4j-backup ./neo4j-backup -from ha://192.168.1.34 -to /mnt/backup/neo4j-backup ha.cluster_server=192.168.1.34:5002 ./neo4j-backup -from ha://192.168.1.34:5002 -to /mnt/backup/neo4j-backup ./neo4j-backup -from ha://192.168.1.34:6362 -to /mnt/backup/neo4j-backup 2014-01-19 19:24:30.842+0000 ERROR [o.n.c.c.NetworkSender]: Receive exception: java.lang.ClassCastException: org.jboss.netty.buffer.BigEndianHeapChannelBuffer cannot be cast to org.neo4j.cluster.com.message.Message at org.neo4j.cluster.com.NetworkSender$NetworkMessageSender.messageReceived(NetworkSender.java:409) ~[neo4j-cluster-2.0.0.jar:2.0.0] at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:107) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:312) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:88) ~[netty-3.6.3.Final.jar:na] at org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178) ~[netty-3.6.3.Final.jar:na] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145) [na:1.7.0_45] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615) [na:1.7.0_45] at java.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Using MERGE with schema indexes/constraints</title>
      <link>https://markhneedham.com/blog/2013/12/23/neo4j-cypher-using-merge-with-schema-indexesconstraints/</link>
      <pubDate>Mon, 23 Dec 2013 13:30:38 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/12/23/neo4j-cypher-using-merge-with-schema-indexesconstraints/</guid>
      <description>MERGE (u:User {id: {userId}}) MERGE (e:Event {id: {eventId}}) MERGE (u)-[:CREATED_EVENT]-&amp;gt;(m) RETURN u, e import org.neo4j.cypher.javacompat.ExecutionEngine; import org.neo4j.cypher.javacompat.ExecutionResult; import org.neo4j.graphdb.GraphDatabaseService; import org.neo4j.graphdb.factory.GraphDatabaseFactory; import org.neo4j.helpers.collection.MapUtil; import org.neo4j.kernel.impl.util.FileUtils; ... public class MergeTime { public static void main(String[] args) throws Exception { String pathToDb = &amp;#34;/tmp/foo&amp;#34;; FileUtils.deleteRecursively(new File(pathToDb)); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase( pathToDb ); final ExecutionEngine engine = new ExecutionEngine( db ); ExecutorService executor = Executors.newFixedThreadPool( 50 ); final Random random = new Random(); final int numberOfUsers = 10; final int numberOfEvents = 50; int iterations = 100; final List&amp;lt;Integer&amp;gt; userIds = generateIds( numberOfUsers ); final List&amp;lt;Integer&amp;gt; eventIds = generateIds( numberOfEvents ); List&amp;lt;Future&amp;gt; merges = new ArrayList&amp;lt;&amp;gt;( ); for ( int i = 0; i &amp;lt; iterations; i++ ) { Integer userId = userIds.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Getting the hang of MERGE</title>
      <link>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</link>
      <pubDate>Tue, 10 Dec 2013 23:46:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/12/10/neo4j-cypher-getting-the-hang-of-merge/</guid>
      <description>public class Merge { private static Label PERSON = DynamicLabel.label(&amp;#34;Person&amp;#34;); public static void main(String[] args) throws IOException { File dbFile = new File(&amp;#34;/tmp/test-db&amp;#34;); FileUtils.deleteRecursively(dbFile); Faker faker = new Faker(); Random random = new Random(); GraphDatabaseService db = new GraphDatabaseFactory().newEmbeddedDatabase(dbFile.getPath()); Transaction tx = db.beginTx(); for (int i = 0; i &amp;lt; 100000; i++) { Node person = db.createNode(PERSON); person.setProperty(&amp;#34;name&amp;#34;, faker.name()); person.setProperty(&amp;#34;firstName&amp;#34;, faker.firstName()); person.setProperty(&amp;#34;lastName&amp;#34;, faker.lastName()); person.setProperty(&amp;#34;country&amp;#34;, faker.country()); person.setProperty(&amp;#34;age&amp;#34;, random.nextInt(50)); } tx.success(); tx.close(); } } $ MATCH (p:Person) RETURN p LIMIT 5; ==&amp;gt; +------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | p | ==&amp;gt; +------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[1344]{name:&amp;quot;Benton Swaniawski&amp;quot;,firstName:&amp;quot;Rossie&amp;quot;,lastName:&amp;quot;Ankunding&amp;quot;,country:&amp;quot;Guadeloupe&amp;quot;,age:30} | ==&amp;gt; | Node[1345]{name:&amp;quot;Dagmar Bartell&amp;quot;,firstName:&amp;quot;Ashlynn&amp;quot;,lastName:&amp;quot;Watsica&amp;quot;,country:&amp;quot;French Guiana&amp;quot;,age:35} | ==&amp;gt; | Node[1346]{name:&amp;quot;Ms.</description>
    </item>
    
    <item>
      <title>Neo4j: What is a node?</title>
      <link>https://markhneedham.com/blog/2013/11/29/neo4j-what-is-a-node/</link>
      <pubDate>Fri, 29 Nov 2013 19:50:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/29/neo4j-what-is-a-node/</guid>
      <description>&amp;gt;&amp;gt;&amp;gt; nltk.pos_tag(nltk.word_tokenize(&amp;#34;Female friends of friends that somebody could go out with&amp;#34;)) [(&amp;#39;Female&amp;#39;, &amp;#39;NNP&amp;#39;), (&amp;#39;friends&amp;#39;, &amp;#39;NNS&amp;#39;), (&amp;#39;of&amp;#39;, &amp;#39;IN&amp;#39;), (&amp;#39;friends&amp;#39;, &amp;#39;NNS&amp;#39;), (&amp;#39;that&amp;#39;, &amp;#39;WDT&amp;#39;), (&amp;#39;somebody&amp;#39;, &amp;#39;NN&amp;#39;), (&amp;#39;could&amp;#39;, &amp;#39;MD&amp;#39;), (&amp;#39;go&amp;#39;, &amp;#39;VB&amp;#39;), (&amp;#39;out&amp;#39;, &amp;#39;RP&amp;#39;), (&amp;#39;with&amp;#39;, &amp;#39;IN&amp;#39;)] &amp;gt;&amp;gt;&amp;gt; nouns = [&amp;#39;NNS&amp;#39;, &amp;#39;NN&amp;#39;, &amp;#39;NP&amp;#39;, &amp;#39;NNP&amp;#39;] &amp;gt;&amp;gt;&amp;gt; [(word, grammar) for (word, grammar) in nltk.pos_tag(nltk.word_tokenize(&amp;#34;Female friends of friends that somebody could go out with&amp;#34;)) if grammar in nouns] [(&amp;#39;Female&amp;#39;, &amp;#39;NNP&amp;#39;), (&amp;#39;friends&amp;#39;, &amp;#39;NNS&amp;#39;), (&amp;#39;friends&amp;#39;, &amp;#39;NNS&amp;#39;), (&amp;#39;somebody&amp;#39;, &amp;#39;NN&amp;#39;)] &amp;gt;&amp;gt;&amp;gt; sentence = &amp;#34;Goals scored by Arsenal players in a particular season&amp;#34; &amp;gt;&amp;gt;&amp;gt; [(word, grammar) for (word, grammar) in nltk.</description>
    </item>
    
    <item>
      <title>Neo4j: The case of neo4j-shell and the invisible text ft. Windows and the neo4j-desktop </title>
      <link>https://markhneedham.com/blog/2013/11/29/neo4j-the-case-of-windows-neo4j-desktop-and-the-invisible-text/</link>
      <pubDate>Fri, 29 Nov 2013 17:08:49 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/29/neo4j-the-case-of-windows-neo4j-desktop-and-the-invisible-text/</guid>
      <description>C:\Users\Mark&amp;gt; cd &amp;#34;C:\Program Files\Neo4j Community&amp;#34; C:\Program Files\Neo4j Community&amp;gt;jre\bin\java -cp bin\neo4j-desktop-2.0.0-RC1.jar org.neo4j.shell.StartClient Welcome to the Neo4j Shell! Enter &amp;#39;help&amp;#39; for a list of commands NOTE: Remote Neo4j graph database service &amp;#39;shell&amp;#39; at port 1337 Want bash-like features? throw in jLine (http://jline.sourceforge.net) on the classpath START n = node(*) RETURN COUNT(n); </description>
    </item>
    
    <item>
      <title>Neo4j: Modelling &#39;series&#39; of events</title>
      <link>https://markhneedham.com/blog/2013/11/29/neo4j-modelling-series-of-events/</link>
      <pubDate>Fri, 29 Nov 2013 00:51:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/29/neo4j-modelling-series-of-events/</guid>
      <description>MATCH (g:Game)&amp;lt;-[:in]-(playerInMatch)&amp;lt;-[:played]-(player) WHERE g.name = &amp;quot;Match 4&amp;quot; AND player.name = &amp;quot;Robin Van Persie&amp;quot; WITH playerInMatch MATCH (playerInMatch)&amp;lt;-[:NEXT*1..2]-(previousPlayerInMatch)-[:in]-&amp;gt;(previousGame) RETURN previousGame, previousPlayerInMatch MATCH (g:Game)&amp;lt;-[:in]-(playerInMatch)&amp;lt;-[:played]-(player) WHERE g.name = &amp;quot;Match 4&amp;quot; AND player.name = &amp;quot;Robin Van Persie&amp;quot; WITH playerInMatch MATCH (playerInMatch)&amp;lt;-[n:NEXT*1..2]-(previousPlayerInMatch)-[:in]-&amp;gt;(previousGame) WHERE n.series = &amp;quot;CL&amp;quot; RETURN previousGame, previousPlayerInMatch CREATE (robin:Player {name: &amp;quot;Robin Van Persie&amp;quot;}) CREATE (manUtd:Team {name: &amp;quot;Man Utd&amp;quot;}) CREATE (arsenal:Team {name: &amp;quot;Arsenal&amp;quot;}) CREATE (realSociedad:Team {name: &amp;quot;Real Sociedad&amp;quot;}) CREATE (fulham:Team {name: &amp;quot;Fulham&amp;quot;}) CREATE (stoke:Team {name: &amp;quot;Stoke&amp;quot;}) CREATE (southampton:Team {name: &amp;quot;Southampton&amp;quot;}) CREATE (netherlands:Team {name: &amp;quot;Netherlands&amp;quot;}) CREATE (turkey:Team {name: &amp;quot;Turkey&amp;quot;}) CREATE (hungary:Team {name: &amp;quot;Hungary&amp;quot;}) CREATE (sunderland:Team {name: &amp;quot;Sunderland&amp;quot;}) CREATE (shakhtar:Team {name: &amp;quot;Shakhtar Donetsk&amp;quot;}) CREATE (westBrom:Team {name: &amp;quot;West Brom&amp;quot;}) CREATE (leverkusen:Team {name: &amp;quot;Bayer Leverkusen&amp;quot;}) CREATE (estonia:Team {name: &amp;quot;Estonia&amp;quot;}) CREATE (andorra:Team {name: &amp;quot;Andorra&amp;quot;}) CREATE (premierLeague:Competition {name: &amp;quot;Barclays Premier League&amp;quot;}) CREATE (championsLeague:Competition {name: &amp;quot;Champions League&amp;quot;}) CREATE (worldCupQualifiers:Competition {name: &amp;quot;World Cup Qualifiers&amp;quot;}) CREATE (manUtdVsArsenal:Game {name: &amp;quot;Man Utd vs Arsenal&amp;quot;, date: 1384041600, home_goals: 1, away_goals: 0}) CREATE (robinManUtdVsArsenal {name: &amp;quot;RVP in Man Utd vs Arsenal&amp;quot;, goals: 1}) CREATE UNIQUE (manUtdVsArsenal)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsArsenal)-[:in]-&amp;gt;(manUtdVsArsenal) CREATE UNIQUE (robinManUtdVsArsenal)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (arsenal)&amp;lt;-[:away_team]-(manUtdVsArsenal)-[:home_team]-&amp;gt;(manUtd) CREATE (realSociedadVsManUtd:Game {name: &amp;quot;Real Sociedad vs Man Utd&amp;quot;, date: 1383609600, home_goals: 0, away_goals: 0}) CREATE (robinRealSociedadVsManUtd {name: &amp;quot;RVP in Real Sociedad vs Man Utd&amp;quot;, goals: 0}) CREATE UNIQUE (realSociedadVsManUtd)-[:in_competition]-&amp;gt;(championsLeague) CREATE UNIQUE (robin)-[:played]-(robinRealSociedadVsManUtd)-[:in]-&amp;gt;(realSociedadVsManUtd) CREATE UNIQUE (robinRealSociedadVsManUtd)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (manUtd)&amp;lt;-[:away_team]-(realSociedadVsManUtd)-[:home_team]-&amp;gt;(realSociedad) CREATE (fulhamVsManUtd:Game {name: &amp;quot;Fulham vs Man Utd&amp;quot;, date: 1383350400, home_goals: 1, away_goals: 3}) CREATE (robinFulhamVsManUtd {name: &amp;quot;RVP in Fulham vs Man Utd&amp;quot;, goals: 1}) CREATE UNIQUE (fulhamVsManUtd)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinFulhamVsManUtd)-[:in]-&amp;gt;(fulhamVsManUtd) CREATE UNIQUE (fulhamVsManUtd)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (manUtd)&amp;lt;-[:away_team]-(fulhamVsManUtd)-[:home_team]-&amp;gt;(fulham) CREATE (manUtdVsStoke:Game {name: &amp;quot;Man Utd vs Stoke&amp;quot;, date: 1382745600, home_goals: 3, away_goals: 2}) CREATE (robinManUtdVsStoke {name: &amp;quot;RVP in Man Utd vs Stoke&amp;quot;, goals: 1}) CREATE UNIQUE (manUtdVsStoke)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsStoke)-[:in]-&amp;gt;(manUtdVsStoke) CREATE UNIQUE (manUtdVsStoke)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (stoke)&amp;lt;-[:away_team]-(manUtdVsStoke)-[:home_team]-&amp;gt;(manUtd) CREATE (manUtdVsSouthampton:Game {name: &amp;quot;Man Utd vs Southampton&amp;quot;, date: 1382140800, home_goals: 1, away_goals: 1}) CREATE (robinManUtdVsSouthampton {name: &amp;quot;RVP in Man Utd vs Southampton&amp;quot;, goals: 1}) CREATE UNIQUE (manUtdVsSouthampton)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsSouthampton)-[:in]-&amp;gt;(manUtdVsSouthampton) CREATE UNIQUE (manUtdVsSouthampton)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (southampton)&amp;lt;-[:away_team]-(manUtdVsSouthampton)-[:home_team]-&amp;gt;(manUtd) CREATE (turkeyVsNetherlands:Game {name: &amp;quot;Turkey vs Netherlands&amp;quot;, date: 1381795200, home_goals: 0, away_goals: 2}) CREATE (robinTurkeyVsNetherlands {name: &amp;quot;RVP in Turkey vs Netherlands&amp;quot;, goals: 0}) CREATE UNIQUE (turkeyVsNetherlands)-[:in_competition]-&amp;gt;(worldCupQualifiers) CREATE UNIQUE (robin)-[:played]-(robinTurkeyVsNetherlands)-[:in]-&amp;gt;(turkeyVsNetherlands) CREATE UNIQUE (turkeyVsNetherlands)-[:for]-&amp;gt;(netherlands) CREATE UNIQUE (netherlands)&amp;lt;-[:away_team]-(turkeyVsNetherlands)-[:home_team]-&amp;gt;(turkey) CREATE (netherlandsVsHungary:Game {name: &amp;quot;Netherlands vs Hungary&amp;quot;, date: 1381449600, home_goals: 8, away_goals: 1}) CREATE (robinNetherlandsVsHungary {name: &amp;quot;RVP in Netherlands vs Hungary&amp;quot;, goals: 3}) CREATE UNIQUE (netherlandsVsHungary)-[:in_competition]-&amp;gt;(worldCupQualifiers) CREATE UNIQUE (robin)-[:played]-(robinNetherlandsVsHungary)-[:in]-&amp;gt;(netherlandsVsHungary) CREATE UNIQUE (netherlandsVsHungary)-[:for]-&amp;gt;(netherlands) CREATE UNIQUE (hungary)&amp;lt;-[:away_team]-(netherlandsVsHungary)-[:home_team]-&amp;gt;(netherlands) CREATE (sunderlandVsManUtd:Game {name: &amp;quot;Sunderland vs Man Utd&amp;quot;, date: 1380931200, home_goals: 1, away_goals: 2}) CREATE (robinSunderlandVsManUtd {name: &amp;quot;RVP in Sunderland vs Man Utd&amp;quot;, goals: 0}) CREATE UNIQUE (sunderlandVsManUtd)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinSunderlandVsManUtd)-[:in]-&amp;gt;(sunderlandVsManUtd) CREATE UNIQUE (sunderlandVsManUtd)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (manUtd)&amp;lt;-[:away_team]-(sunderlandVsManUtd)-[:home_team]-&amp;gt;(sunderland) CREATE (shakhtarVsManUtd:Game {name: &amp;quot;Shaktar Donetsk vs Man Utd&amp;quot;, date: 1380672000, home_goals: 1, away_goals: 1}) CREATE (robinShaktarVsManUtd {name: &amp;quot;RVP in Shaktar Donetsk vs Man Utd&amp;quot;, goals: 0}) CREATE UNIQUE (shakhtarVsManUtd)-[:in_competition]-&amp;gt;(championsLeague) CREATE UNIQUE (robin)-[:played]-(robinShaktarVsManUtd)-[:in]-&amp;gt;(shakhtarVsManUtd) CREATE UNIQUE (shakhtarVsManUtd)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (manUtd)&amp;lt;-[:away_team]-(shakhtarVsManUtd)-[:home_team]-&amp;gt;(shakhtar) CREATE (manUtdVsWestBrom:Game {name: &amp;quot;Man Utd vs West Brom&amp;quot;, date: 1380326400, home_goals: 1, away_goals: 2}) CREATE (robinManUtdVsWestBrom {name: &amp;quot;RVP in Man Utd vs West Brom&amp;quot;, goals: 0}) CREATE UNIQUE (manUtdVsWestBrom)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsWestBrom)-[:in]-&amp;gt;(manUtdVsWestBrom) CREATE UNIQUE (manUtdVsWestBrom)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (westBrom)&amp;lt;-[:away_team]-(manUtdVsWestBrom)-[:home_team]-&amp;gt;(manUtd) CREATE (manUtdVsLeverkusen:Game {name: &amp;quot;Man Utd vs Bayer Leverkusen&amp;quot;, date: 1379376000, home_goals: 4, away_goals: 2}) CREATE (robinManUtdVsLeverkusen {name: &amp;quot;RVP in Man Utd vs Bayer Leverkusen&amp;quot;, goals: 1}) CREATE UNIQUE (manUtdVsLeverkusen)-[:in_competition]-&amp;gt;(championsLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsLeverkusen)-[:in]-&amp;gt;(manUtdVsLeverkusen) CREATE UNIQUE (robinManUtdVsLeverkusen)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (leverkusen)&amp;lt;-[:away_team]-(manUtdVsLeverkusen)-[:home_team]-&amp;gt;(manUtd) CREATE (manUtdVsPalace:Game {name: &amp;quot;Man Utd vs Crystal Palace&amp;quot;, date: 1379116800, home_goals: 2, away_goals: 0}) CREATE (robinManUtdVsPalace {name: &amp;quot;RVP in Man Utd vs Crystal Palace&amp;quot;, goals: 1}) CREATE UNIQUE (manUtdVsPalace)-[:in_competition]-&amp;gt;(premierLeague) CREATE UNIQUE (robin)-[:played]-(robinManUtdVsPalace)-[:in]-&amp;gt;(manUtdVsPalace) CREATE UNIQUE (manUtdVsPalace)-[:for]-&amp;gt;(manUtd) CREATE UNIQUE (palace)&amp;lt;-[:away_team]-(manUtdVsPalace)-[:home_team]-&amp;gt;(manUtd) CREATE (andorraVsNetherlands:Game {name: &amp;quot;Andorra vs Netherlands&amp;quot;, date: 1378771200, home_goals: 0, away_goals: 2}) CREATE (robinAndorraVsNetherlands {name: &amp;quot;RVP in Andorra vs Netherlands&amp;quot;, goals: 2}) CREATE UNIQUE (andorraVsNetherlands)-[:in_competition]-&amp;gt;(worldCupQualifiers) CREATE UNIQUE (robin)-[:played]-(robinAndorraVsNetherlands)-[:in]-&amp;gt;(andorraVsNetherlands) CREATE UNIQUE (andorraVsNetherlands)-[:for]-&amp;gt;(netherlands) CREATE UNIQUE (netherlands)&amp;lt;-[:away_team]-(andorraVsNetherlands)-[:home_team]-&amp;gt;(andorra) CREATE (netherlandsVsEstonia:Game {name: &amp;quot;Netherlands vs Estonia&amp;quot;, date: 1378425600, home_goals: 2, away_goals: 2}) CREATE (robinNetherlandsVsEstonia {name: &amp;quot;RVP in Netherlands vs Estonia&amp;quot;, goals: 1}) CREATE UNIQUE (netherlandsVsEstonia)-[:in_competition]-&amp;gt;(worldCupQualifiers) CREATE UNIQUE (robin)-[:played]-(robinNetherlandsVsEstonia)-[:in]-&amp;gt;(netherlandsVsEstonia) CREATE UNIQUE (netherlandsVsEstonia)-[:for]-&amp;gt;(netherlands) CREATE UNIQUE (estonia)&amp;lt;-[:away_team]-(netherlandsVsEstonia)-[:home_team]-&amp;gt;(netherlands) MATCH (p:Player)-[:played]-&amp;gt;(stats)-[:in]-&amp;gt;(game)-[:in_competition]-&amp;gt;(c) WHERE p.</description>
    </item>
    
    <item>
      <title>Neo4j: The &#39;thinking in graphs&#39; curve</title>
      <link>https://markhneedham.com/blog/2013/11/27/neo4j-the-thinking-in-graphs-curve/</link>
      <pubDate>Wed, 27 Nov 2013 23:09:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/27/neo4j-the-thinking-in-graphs-curve/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Neo4j: Using aliases to handle messy data</title>
      <link>https://markhneedham.com/blog/2013/11/26/neo4j-using-aliases-to-handle-messy-data/</link>
      <pubDate>Tue, 26 Nov 2013 00:12:56 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/26/neo4j-using-aliases-to-handle-messy-data/</guid>
      <description>MATCH (stadium:Stadium)&amp;lt;-[:in_stadium]-(game) RETURN stadium.name, count(game) AS games ORDER BY games DESC ==&amp;gt; +-------------------------------+ ==&amp;gt; | stadium.name | games | ==&amp;gt; +-------------------------------+ ==&amp;gt; | &amp;#34;Craven Cottage&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Villa Park&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Anfield&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Stamford Bridge&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Britannia Stadium&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Emirates Stadium&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Etihad Stadium&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Stadium of Light&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Old Trafford&amp;#34; | 57 | ==&amp;gt; | &amp;#34;The Hawthorns&amp;#34; | 57 | ==&amp;gt; | &amp;#34;White Hart Lane&amp;#34; | 57 | ==&amp;gt; | &amp;#34;Goodison Park&amp;#34; | 57 | ==&amp;gt; | &amp;#34;DW Stadium&amp;#34; | 39 | ==&amp;gt; | &amp;#34;Molineux Stadium&amp;#34; | 38 | ==&amp;gt; | &amp;#34;Liberty Stadium&amp;#34; | 38 | ==&amp;gt; | &amp;#34;Ewood Park&amp;#34; | 38 | ==&amp;gt; | &amp;#34;Carrow Road&amp;#34; | 38 | ==&amp;gt; | &amp;#34;Reebok Stadium&amp;#34; | 38 | ==&amp;gt; | &amp;#34;Loftus Road Stadium&amp;#34; | 37 | ==&amp;gt; | &amp;#34;St James&amp;#39; Park&amp;#34; | 34 | ==&amp;gt; | &amp;#34;Upton Park&amp;#34; | 33 | ==&amp;gt; | &amp;#34;Bloomfield Road&amp;#34; | 19 | ==&amp;gt; | &amp;#34;Madejski Stadium&amp;#34; | 19 | ==&amp;gt; | &amp;#34;St.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Optional relationships with OPTIONAL MATCH</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</link>
      <pubDate>Sat, 23 Nov 2013 22:54:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-optional-relationships-with-optional-match/</guid>
      <description>CREATE (steve:Person {name: &amp;quot;Steve&amp;quot;}) CREATE (john:Person {name: &amp;quot;John&amp;quot;}) CREATE (david:Person {name: &amp;quot;David&amp;quot;}) CREATE (paul:Person {name: &amp;quot;Paul&amp;quot;}) CREATE (sam:Person {name: &amp;quot;Sam&amp;quot;}) CREATE (londonOffice:Office {name: &amp;quot;London Office&amp;quot;}) CREATE UNIQUE (steve)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (john)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (david)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (paul)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (sam)-[:WORKS_IN]-&amp;gt;(londonOffice) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(john) CREATE UNIQUE (steve)-[:COLLEAGUES_WITH]-&amp;gt;(david) MATCH (person:Person)-[:WORKS_IN]-&amp;gt;(office)&amp;lt;-[:WORKS_IN]-(potentialColleague) WHERE person.name = &amp;quot;Steve&amp;quot; AND office.name = &amp;quot;London Office&amp;quot; WITH person, potentialColleague MATCH (potentialColleague)-[c?:COLLEAGUES_WITH]-(person) WHERE c IS null RETURN potentialColleague ==&amp;gt; +----------------------+ ==&amp;gt; | potentialColleague | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[4]{name:&amp;#34;Paul&amp;#34;} | ==&amp;gt; | Node[5]{name:&amp;#34;Sam&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; SyntaxException: Question mark is no longer used for optional patterns - use OPTIONAL MATCH instead (line 1, column 199) ==&amp;gt; &amp;#34;MATCH (person:Person)-[:WORKS_IN]-&amp;gt;(office)&amp;lt;-[:WORKS_IN]-(potentialColleague) WHERE person.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06 -&gt; 2.0.0-RC1: Working with path expressions</title>
      <link>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</link>
      <pubDate>Sat, 23 Nov 2013 10:30:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/23/neo4j-2-0-0-m06-2-0-0-rc1-working-with-path-expressions/</guid>
      <description>MATCH (player:Player)-[:played|subbed_on]-&amp;gt;stats WITH stats.goals AS goals, player, stats-[:in]-&amp;gt;()-[:on_tv]-() as onTv RETURN player.name, SUM(CASE WHEN onTv = FALSE THEN goals ELSE 0 END) as nonTvGoals, SUM(CASE WHEN onTv = TRUE THEN goals ELSE 0 END) as tvGoals, SUM(goals) as allGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; | player.name | nonTvGoals | tvGoals | allGoals | ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; | &amp;#34;Robin Van Persie&amp;#34; | 11 | 15 | 26 | ==&amp;gt; | &amp;#34;Gareth Bale&amp;#34; | 8 | 13 | 21 | ==&amp;gt; | &amp;#34;Luis Suárez&amp;#34; | 12 | 11 | 23 | ==&amp;gt; | &amp;#34;Theo Walcott&amp;#34; | 5 | 9 | 14 | ==&amp;gt; | &amp;#34;Demba Ba&amp;#34; | 7 | 8 | 15 | ==&amp;gt; | &amp;#34;Santi Cazorla&amp;#34; | 5 | 7 | 12 | ==&amp;gt; | &amp;#34;Edin Dzeko&amp;#34; | 7 | 7 | 14 | ==&amp;gt; | &amp;#34;Carlos Tevez&amp;#34; | 5 | 6 | 11 | ==&amp;gt; | &amp;#34;Juan Mata&amp;#34; | 6 | 6 | 12 | ==&amp;gt; | &amp;#34;Steven Gerrard&amp;#34; | 3 | 6 | 9 | ==&amp;gt; +------------------------------------------------------+ ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Creating relationships between nodes from adjacent rows in a query</title>
      <link>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</link>
      <pubDate>Fri, 22 Nov 2013 22:45:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/22/neo4j-cypher-creating-relationships-between-nodes-from-adjacent-rows-in-a-query/</guid>
      <description>CREATE (:Season {name: &amp;quot;2013/2014&amp;quot;, timestamp: 1375315200}) CREATE (:Season {name: &amp;quot;2012/2013&amp;quot;, timestamp: 1343779200}) CREATE (:Season {name: &amp;quot;2011/2012&amp;quot;, timestamp: 1312156800}) CREATE (:Season {name: &amp;quot;2010/2011&amp;quot;, timestamp: 1280620800}) CREATE (:Season {name: &amp;quot;2009/2010&amp;quot;, timestamp: 1249084800}) // return all the matches for 2010/2011, 2011/2012, 2012/2013 MATCH (base:Season)&amp;lt;-[:NEXT*0..2]-(s) WHERE base.name = &amp;quot;2012/2013&amp;quot; MATCH s-[:contains]-&amp;gt;game RETURN game MATCH (s:Season) WITH s ORDER BY s.timestamp RETURN s ==&amp;gt; +------------------------------------------------+ ==&amp;gt; | s | ==&amp;gt; +------------------------------------------------+ ==&amp;gt; | Node[0]{name:&amp;#34;2009/2010&amp;#34;,timestamp:1249084800} | ==&amp;gt; | Node[1]{name:&amp;#34;2010/2011&amp;#34;,timestamp:1280620800} | ==&amp;gt; | Node[2]{name:&amp;#34;2011/2012&amp;#34;,timestamp:1312156800} | ==&amp;gt; | Node[3]{name:&amp;#34;2012/2013&amp;#34;,timestamp:1343779200} | ==&amp;gt; | Node[4]{name:&amp;#34;2013/2014&amp;#34;,timestamp:1375315200} | ==&amp;gt; +------------------------------------------------+ MATCH (s:Season) WITH s ORDER BY s.</description>
    </item>
    
    <item>
      <title>Neo4j 2.0.0-M06: Applying Wes Freeman&#39;s Cypher Optimisation tricks</title>
      <link>https://markhneedham.com/blog/2013/11/08/neo4j-2-0-0-m06-applying-wes-freemans-cypher-optimisation-tricks/</link>
      <pubDate>Fri, 08 Nov 2013 09:40:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/08/neo4j-2-0-0-m06-applying-wes-freemans-cypher-optimisation-tricks/</guid>
      <description>MATCH (player:Player)-[:played]-&amp;gt;stats-[:in]-&amp;gt;game, stats-[:for]-&amp;gt;team WHERE game&amp;lt;-[:away_team]-team RETURN player.name, SUM(stats.goals) AS goals ORDER BY goals DESC LIMIT 10 import query_profiler as qp attempts = [ {&amp;#34;query&amp;#34;: &amp;#39;&amp;#39;&amp;#39;MATCH (player:Player)-[:played]-&amp;gt;stats-[:in]-&amp;gt;game, stats-[:for]-&amp;gt;team WHERE game&amp;lt;-[:away_team]-team RETURN player.name, SUM(stats.goals) AS goals ORDER BY goals DESC LIMIT 10&amp;#39;&amp;#39;&amp;#39;} ] qp.profile(attempts, iterations=5, runs=3) $ python top-away-scorers.py MATCH (player:Player)-[:played]-&amp;gt;stats-[:in]-&amp;gt;game, stats-[:for]-&amp;gt;team WHERE game&amp;lt;-[:away_team]-team RETURN player.name, SUM(stats.goals) AS goals ORDER BY goals DESC LIMIT 10 Min 0.682677030563 Mean 0.689069747925 95% 0.697918820381 Max 0.</description>
    </item>
    
    <item>
      <title>Neo4j: A first attempt at retail product substitution</title>
      <link>https://markhneedham.com/blog/2013/11/01/neo4j-a-first-attempt-at-retail-product-substitution/</link>
      <pubDate>Fri, 01 Nov 2013 20:41:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/11/01/neo4j-a-first-attempt-at-retail-product-substitution/</guid>
      <description>CREATE (bakedBeans :Category {name: &amp;quot;Baked Beans&amp;quot;} ) CREATE (fruit :Category {name: &amp;quot;Fruit&amp;quot;} ) CREATE (hbb :Product {name: &amp;quot;Heinz Baked Beans&amp;quot;, type: &amp;quot;brand&amp;quot;} ) CREATE (bbb :Product {name: &amp;quot;Branstone Baked Beans&amp;quot;, type: &amp;quot;brand&amp;quot;} ) CREATE (sbb :Product {name: &amp;quot;Sainsbury&#39;s Baked Beans&amp;quot;, type: &amp;quot;own&amp;quot;} ) CREATE (apple :Product {name: &amp;quot;Bag of Apples&amp;quot;} ) CREATE UNIQUE (hbb)-[:HAS_CATEGORY]-&amp;gt;(bakedBeans) CREATE UNIQUE (bbb)-[:HAS_CATEGORY]-&amp;gt;(bakedBeans) CREATE UNIQUE (sbb)-[:HAS_CATEGORY]-&amp;gt;(bakedBeans) CREATE (southwark :Store {name: &amp;quot;Southwark&amp;quot;}) CREATE UNIQUE (southwark)-[:HAS_IN_STOCK {availability: 0}]-&amp;gt;(hbb) CREATE UNIQUE (southwark)-[:HAS_IN_STOCK {availability: 2}]-&amp;gt;(bbb) CREATE UNIQUE (southwark)-[:HAS_IN_STOCK {availability: 10}]-&amp;gt;(sbb) CREATE UNIQUE (southwark)-[:HAS_IN_STOCK {availability: 10}]-&amp;gt;(apple) CREATE (mark :Person {name: &amp;quot;Mark&amp;quot;}) CREATE (order1 :Order {id: 1, date: 1380884632}) CREATE UNIQUE (order1)-[:CONTAINS {count: 1}]-&amp;gt;(hbb) CREATE UNIQUE (order1)-[:CONTAINS {count: 5}]-&amp;gt;(apple) CREATE UNIQUE (mark)-[:PLACED_ORDER]-&amp;gt;(order1) CREATE (order2 :Order {id: 2, date: 1380885051}) CREATE UNIQUE (order2)-[:CONTAINS {count: 1}]-&amp;gt;bbb CREATE UNIQUE (mark)-[:PLACED_ORDER]-&amp;gt;(order2) // Create the order CREATE (order3:Order {id: 3, date: 1380895051}) WITH order3 // Assign the order to Mark MATCH (p:Person) WHERE p.</description>
    </item>
    
    <item>
      <title>Neo4j: Cypher - Profiling ORDER BY LIMIT vs LIMIT</title>
      <link>https://markhneedham.com/blog/2013/10/27/neo4j-cypher-profiling-order-by-limit-vs-limit/</link>
      <pubDate>Sun, 27 Oct 2013 00:33:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/27/neo4j-cypher-profiling-order-by-limit-vs-limit/</guid>
      <description>$ MATCH n RETURN COUNT(n); ==&amp;gt; +----------+ ==&amp;gt; | COUNT(n) | ==&amp;gt; +----------+ ==&amp;gt; | 11442 | ==&amp;gt; +----------+ ==&amp;gt; 1 row ==&amp;gt; 1384 ms $ MATCH n RETURN n LIMIT 5; ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | n | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | Node[0]{} | ==&amp;gt; | Node[1]{name:&amp;#34;Africa&amp;#34;,node_id:&amp;#34;1&amp;#34;} | ==&amp;gt; | Node[2]{name:&amp;#34;Asia&amp;#34;,node_id:&amp;#34;2&amp;#34;} | ==&amp;gt; | Node[3]{name:&amp;#34;Europe&amp;#34;,node_id:&amp;#34;3&amp;#34;} | ==&amp;gt; | Node[4]{name:&amp;#34;North America&amp;#34;,node_id:&amp;#34;4&amp;#34;} | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; 5 rows ==&amp;gt; 38 ms $ MATCH n RETURN n ORDER BY ID(n) LIMIT 5; ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | n | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; | Node[0]{} | ==&amp;gt; | Node[1]{name:&amp;#34;Africa&amp;#34;,node_id:&amp;#34;1&amp;#34;} | ==&amp;gt; | Node[2]{name:&amp;#34;Asia&amp;#34;,node_id:&amp;#34;2&amp;#34;} | ==&amp;gt; | Node[3]{name:&amp;#34;Europe&amp;#34;,node_id:&amp;#34;3&amp;#34;} | ==&amp;gt; | Node[4]{name:&amp;#34;North America&amp;#34;,node_id:&amp;#34;4&amp;#34;} | ==&amp;gt; +-------------------------------------------+ ==&amp;gt; 5 rows ==&amp;gt; 157 ms $ PROFILE MATCH n RETURN n ORDER BY ID(n) LIMIT 5; ==&amp;gt; ColumnFilter(symKeys=[&amp;#34;n&amp;#34;, &amp;#34; UNNAMEDS1215244997&amp;#34;], returnItemNames=[&amp;#34;n&amp;#34;], _rows=5, _db_hits=0) ==&amp;gt; Top(orderBy=[&amp;#34;SortItem(Cached( UNNAMEDS1215244997 of type Long),true)&amp;#34;], limit=&amp;#34;Literal(5)&amp;#34;, _rows=5, _db_hits=0) ==&amp;gt; Extract(symKeys=[&amp;#34;n&amp;#34;], exprKeys=[&amp;#34; UNNAMEDS1215244997&amp;#34;], _rows=11442, _db_hits=0) ==&amp;gt; AllNodes(identifier=&amp;#34;n&amp;#34;, _rows=11442, _db_hits=11442) if (input.</description>
    </item>
    
    <item>
      <title>Neo4j: Making implicit relationships explicit &amp; bidirectional relationships</title>
      <link>https://markhneedham.com/blog/2013/10/25/neo4j-making-implicit-relationships-explicit-bidirectional-relationships/</link>
      <pubDate>Fri, 25 Oct 2013 16:03:48 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/25/neo4j-making-implicit-relationships-explicit-bidirectional-relationships/</guid>
      <description>CREATE (mark:Person {name: &amp;quot;Mark&amp;quot;}) CREATE (dave:Person {name: &amp;quot;Dave&amp;quot;}) CREATE (john:Person {name: &amp;quot;John&amp;quot;}) CREATE (projectA:Project {name: &amp;quot;Project A&amp;quot;}) CREATE (projectB:Project {name: &amp;quot;Project B&amp;quot;}) CREATE (projectC:Project {name: &amp;quot;Project C&amp;quot;}) CREATE (mark)-[:WORKED_ON]-&amp;gt;(projectA) CREATE (mark)-[:WORKED_ON]-&amp;gt;(projectB) CREATE (dave)-[:WORKED_ON]-&amp;gt;(projectA) CREATE (dave)-[:WORKED_ON]-&amp;gt;(projectC) CREATE (john)-[:WORKED_ON]-&amp;gt;(projectC) CREATE (john)-[:WORKED_ON]-&amp;gt;(projectB) MATCH (person1:Person)-[:WORKED_ON]-()&amp;lt;-[:WORKED_ON]-(person2) RETURN person1, person2 ==&amp;gt; +-------------------------------------------------------+ ==&amp;gt; | person1 | person2 | ==&amp;gt; +-------------------------------------------------------+ ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | ==&amp;gt; +-------------------------------------------------------+ ==&amp;gt; 6 rows MATCH (person1:Person)-[:WORKED_ON]-()&amp;lt;-[:WORKED_ON]-(person2) CREATE UNIQUE (person1)-[:KNOWS]-&amp;gt;(person2) RETURN person1, person2 MATCH path=(person1:Person)-[:KNOWS]-(person2) RETURN person1, person2, path ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | person1 | person2 | path | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | [Node[500363]{name:&amp;#34;Mark&amp;#34;},:KNOWS[528536]{},Node[500364]{name:&amp;#34;Dave&amp;#34;}] | ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | [Node[500363]{name:&amp;#34;Mark&amp;#34;},:KNOWS[528537]{},Node[500365]{name:&amp;#34;John&amp;#34;}] | ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | [Node[500363]{name:&amp;#34;Mark&amp;#34;},:KNOWS[528538]{},Node[500364]{name:&amp;#34;Dave&amp;#34;}] | ==&amp;gt; | Node[500363]{name:&amp;#34;Mark&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | [Node[500363]{name:&amp;#34;Mark&amp;#34;},:KNOWS[528541]{},Node[500365]{name:&amp;#34;John&amp;#34;}] | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | [Node[500364]{name:&amp;#34;Dave&amp;#34;},:KNOWS[528538]{},Node[500363]{name:&amp;#34;Mark&amp;#34;}] | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | [Node[500364]{name:&amp;#34;Dave&amp;#34;},:KNOWS[528539]{},Node[500365]{name:&amp;#34;John&amp;#34;}] | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | [Node[500364]{name:&amp;#34;Dave&amp;#34;},:KNOWS[528536]{},Node[500363]{name:&amp;#34;Mark&amp;#34;}] | ==&amp;gt; | Node[500364]{name:&amp;#34;Dave&amp;#34;} | Node[500365]{name:&amp;#34;John&amp;#34;} | [Node[500364]{name:&amp;#34;Dave&amp;#34;},:KNOWS[528540]{},Node[500365]{name:&amp;#34;John&amp;#34;}] | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | [Node[500365]{name:&amp;#34;John&amp;#34;},:KNOWS[528540]{},Node[500364]{name:&amp;#34;Dave&amp;#34;}] | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | [Node[500365]{name:&amp;#34;John&amp;#34;},:KNOWS[528541]{},Node[500363]{name:&amp;#34;Mark&amp;#34;}] | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500363]{name:&amp;#34;Mark&amp;#34;} | [Node[500365]{name:&amp;#34;John&amp;#34;},:KNOWS[528537]{},Node[500363]{name:&amp;#34;Mark&amp;#34;}] | ==&amp;gt; | Node[500365]{name:&amp;#34;John&amp;#34;} | Node[500364]{name:&amp;#34;Dave&amp;#34;} | [Node[500365]{name:&amp;#34;John&amp;#34;},:KNOWS[528539]{},Node[500364]{name:&amp;#34;Dave&amp;#34;}] | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; 12 rows MATCH path=(person1:Person)-[:KNOWS]-(person2) WHERE person1.</description>
    </item>
    
    <item>
      <title>Neo4j: Modelling hyper edges in a property graph</title>
      <link>https://markhneedham.com/blog/2013/10/22/neo4j-modelling-hyper-edges-in-a-property-graph/</link>
      <pubDate>Tue, 22 Oct 2013 22:02:14 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/22/neo4j-modelling-hyper-edges-in-a-property-graph/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Neo4j 2.0: Labels, indexes and the like</title>
      <link>https://markhneedham.com/blog/2013/10/22/neo4j-2-0-labels-indexes-and-the-like/</link>
      <pubDate>Tue, 22 Oct 2013 20:20:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/22/neo4j-2-0-labels-indexes-and-the-like/</guid>
      <description>CREATE (randomPlayer:Player {name: &amp;quot;Random Player&amp;quot;}) MATCH (p:Player) WHERE p.name = &amp;quot;Random Player&amp;quot; RETURN p $ PROFILE MATCH (p:Player) WHERE p.name = &amp;quot;Random Player&amp;quot; RETURN p; ==&amp;gt; +-----------------------------------+ ==&amp;gt; | p | ==&amp;gt; +-----------------------------------+ ==&amp;gt; | Node[31382]{name:&amp;quot;Random Player&amp;quot;} | ==&amp;gt; +-----------------------------------+ ==&amp;gt; 1 row ==&amp;gt; ==&amp;gt; Filter(pred=&amp;quot;(Product(p,name(0),true) == Literal(Random Player) AND hasLabel(p:Player(8)))&amp;quot;, _rows=1, _db_hits=524) ==&amp;gt; NodeByLabel(label=&amp;quot;Player&amp;quot;, identifier=&amp;quot;p&amp;quot;, _rows=524, _db_hits=0) $ PROFILE MATCH p WHERE &amp;quot;Player&amp;quot; IN LABELS(p) AND p.name = &amp;quot;Random Player&amp;quot; RETURN p; ==&amp;gt; +-----------------------------------+ ==&amp;gt; | p | ==&amp;gt; +-----------------------------------+ ==&amp;gt; | Node[31382]{name:&amp;quot;Random Player&amp;quot;} | ==&amp;gt; +-----------------------------------+ ==&amp;gt; 1 row ==&amp;gt; ==&amp;gt; Filter(pred=&amp;quot;(any(-_-INNER-_- in LabelsFunction(p) where Literal(Player) == -_-INNER-_-) AND Product(p,name(0),true) == Literal(Random Player))&amp;quot;, _rows=1, _db_hits=524) ==&amp;gt; AllNodes(identifier=&amp;quot;p&amp;quot;, _rows=11443, _db_hits=11443) $ CREATE INDEX ON :Player(name); ==&amp;gt; +-------------------+ ==&amp;gt; | No data returned.</description>
    </item>
    
    <item>
      <title>Neo4j: Testing an unmanaged extension using CommunityServerBuilder</title>
      <link>https://markhneedham.com/blog/2013/10/20/neo4j-testing-an-unmanaged-extension-using-communitserverbuilder/</link>
      <pubDate>Sun, 20 Oct 2013 21:46:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/20/neo4j-testing-an-unmanaged-extension-using-communitserverbuilder/</guid>
      <description>package org.neo4j.unmanaged; @Path(&amp;#34;/dummy&amp;#34;) public class DummyResource { private final ExecutionEngine executionEngine; private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper(); public DummyResource( @Context GraphDatabaseService database ) { this.executionEngine = new ExecutionEngine(database); } @GET @Produces(MediaType.APPLICATION_JSON) @Path(&amp;#34;/all-nodes&amp;#34;) public Response uploadNodesFile( ) throws IOException { ExecutionResult result = executionEngine.execute(&amp;#34;START n = node(*) RETURN n.name ORDER BY n.name&amp;#34;); ObjectNode root = JsonNodeFactory.instance.objectNode(); for (String column : result.columns()) { ResourceIterator&amp;lt;Object&amp;gt; rows = result.columnAs(column); ArrayNode resultRows = JsonNodeFactory.</description>
    </item>
    
    <item>
      <title>Neo4j: Accessing JMX beans via HTTP</title>
      <link>https://markhneedham.com/blog/2013/10/20/neo4j-accessing-jmx-beans-via-http/</link>
      <pubDate>Sun, 20 Oct 2013 11:13:54 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/20/neo4j-accessing-jmx-beans-via-http/</guid>
      <description>$ curl -H &amp;#34;Content-Type:application/json&amp;#34; http://localhost:7474/db/manage/server/jmx/ { &amp;#34;resources&amp;#34; : { &amp;#34;kernelquery&amp;#34; : &amp;#34;http://localhost:7474/db/manage/server/jmx/kernelquery&amp;#34;, &amp;#34;bean&amp;#34; : &amp;#34;http://localhost:7474/db/manage/server/jmx/domain/{domain}/{objectName}&amp;#34;, &amp;#34;query&amp;#34; : &amp;#34;http://localhost:7474/db/manage/server/jmx/query&amp;#34;, &amp;#34;domains&amp;#34; : &amp;#34;http://localhost:7474/db/manage/server/jmx/domain&amp;#34;, &amp;#34;domain&amp;#34; : &amp;#34;http://localhost:7474/db/manage/server/jmx/domain/{domain}&amp;#34; } } $ curl -H &amp;#34;Content-Type:application/json&amp;#34; http://localhost:7474/db/manage/server/jmx/domain/*/* // cut for verbosity ... { &amp;#34;description&amp;#34; : &amp;#34;Estimates of the numbers of different kinds of Neo4j primitives&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;org.neo4j:instance=kernel#0,name=Primitive count&amp;#34;, &amp;#34;attributes&amp;#34; : [ { &amp;#34;description&amp;#34; : &amp;#34;An estimation of the number of nodes used in this Neo4j instance&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;NumberOfNodeIdsInUse&amp;#34;, &amp;#34;value&amp;#34; : 24117, &amp;#34;isReadable&amp;#34; : &amp;#34;true&amp;#34;, &amp;#34;type&amp;#34; : &amp;#34;long&amp;#34;, &amp;#34;isWriteable&amp;#34; : &amp;#34;false &amp;#34;, &amp;#34;isIs&amp;#34; : &amp;#34;false &amp;#34; }, { &amp;#34;description&amp;#34; : &amp;#34;An estimation of the number of relationships used in this Neo4j instance&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;NumberOfRelationshipIdsInUse&amp;#34;, &amp;#34;value&amp;#34; : 1, &amp;#34;isReadable&amp;#34; : &amp;#34;true&amp;#34;, &amp;#34;type&amp;#34; : &amp;#34;long&amp;#34;, &amp;#34;isWriteable&amp;#34; : &amp;#34;false &amp;#34;, &amp;#34;isIs&amp;#34; : &amp;#34;false &amp;#34; }, { &amp;#34;description&amp;#34; : &amp;#34;An estimation of the number of properties used in this Neo4j instance&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;NumberOfPropertyIdsInUse&amp;#34;, &amp;#34;value&amp;#34; : 19078, &amp;#34;isReadable&amp;#34; : &amp;#34;true&amp;#34;, &amp;#34;type&amp;#34; : &amp;#34;long&amp;#34;, &amp;#34;isWriteable&amp;#34; : &amp;#34;false &amp;#34;, &amp;#34;isIs&amp;#34; : &amp;#34;false &amp;#34; }, { &amp;#34;description&amp;#34; : &amp;#34;The number of relationship types used in this Neo4j instance&amp;#34;, &amp;#34;name&amp;#34; : &amp;#34;NumberOfRelationshipTypeIdsInUse&amp;#34;, &amp;#34;value&amp;#34; : 0, &amp;#34;isReadable&amp;#34; : &amp;#34;true&amp;#34;, &amp;#34;type&amp;#34; : &amp;#34;long&amp;#34;, &amp;#34;isWriteable&amp;#34; : &amp;#34;false &amp;#34;, &amp;#34;isIs&amp;#34; : &amp;#34;false &amp;#34; } ], &amp;#34;url&amp;#34; : &amp;#34;org.</description>
    </item>
    
    <item>
      <title>Neo4j: Exploring new data sets with help from Neo4j browser</title>
      <link>https://markhneedham.com/blog/2013/10/18/neo4j-exploring-new-data-sets-with-help-from-neo4j-browser/</link>
      <pubDate>Fri, 18 Oct 2013 11:43:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/18/neo4j-exploring-new-data-sets-with-help-from-neo4j-browser/</guid>
      <description></description>
    </item>
    
    <item>
      <title>neo4j: Setting query timeout</title>
      <link>https://markhneedham.com/blog/2013/10/17/neo4j-setting-query-timeout/</link>
      <pubDate>Thu, 17 Oct 2013 06:47:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/17/neo4j-setting-query-timeout/</guid>
      <description># timeout in milliseconds org.neo4j.server.webserver.limit.executiontime=1000 execution_guard_enabled=true $ start n = node(*) return n; ==&amp;gt; GuardTimeoutException: timeout occured (overtime=1718) $ curl -H &amp;#34;Content-Type:application/json&amp;#34; -H &amp;#34;max-execution-time: 500&amp;#34; -X POST -d &amp;#39;{&amp;#34;query&amp;#34; : &amp;#34;start n = node(*) return n&amp;#34;}&amp;#39; http://localhost:7474/db/data/cypher { &amp;#34;message&amp;#34; : &amp;#34;timeout occured (overtime=1)&amp;#34;, &amp;#34;exception&amp;#34; : &amp;#34;BadInputException&amp;#34;, &amp;#34;fullname&amp;#34; : &amp;#34;org.neo4j.server.rest.repr.BadInputException&amp;#34;, &amp;#34;stacktrace&amp;#34; : [ &amp;#34;org.neo4j.server.rest.repr.RepresentationExceptionHandlingIterable.exceptionOnNext(RepresentationExceptionHandlingIterable.java:39)&amp;#34;, &amp;#34;org.neo4j.helpers.collection.ExceptionHandlingIterable$1.next(ExceptionHandlingIterable.java:55)&amp;#34;, &amp;#34;org.neo4j.helpers.collection.IteratorWrapper.next(IteratorWrapper.java:47)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.ListRepresentation.serialize(ListRepresentation.java:58)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.Serializer.serialize(Serializer.java:75)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.MappingSerializer.putList(MappingSerializer.java:61)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.CypherResultRepresentation.serialize(CypherResultRepresentation.java:83)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.MappingRepresentation.serialize(MappingRepresentation.java:41)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.OutputFormat.assemble(OutputFormat.java:215)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.OutputFormat.formatRepresentation(OutputFormat.java:147)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.OutputFormat.response(OutputFormat.java:130)&amp;#34;, &amp;#34;org.neo4j.server.rest.repr.OutputFormat.ok(OutputFormat.java:67)&amp;#34;, &amp;#34;org.neo4j.server.rest.web.CypherService.cypher(CypherService.java:101)&amp;#34;, &amp;#34;java.lang.reflect.Method.invoke(Method.java:601)&amp;#34;, &amp;#34;org.neo4j.server.rest.transactional.TransactionalRequestDispatcher.dispatch(TransactionalRequestDispatcher.java:132)&amp;#34;, &amp;#34;org.neo4j.server.rest.security.SecurityFilter.doFilter(SecurityFilter.java:112)&amp;#34;, &amp;#34;org.neo4j.server.guard.GuardingRequestFilter.doFilter(GuardingRequestFilter.java:68)&amp;#34;, &amp;#34;java.lang.Thread.run(Thread.java:722)&amp;#34; ], &amp;#34;cause&amp;#34; : { &amp;#34;message&amp;#34; : &amp;#34;timeout occured (overtime=1)&amp;#34;, &amp;#34;exception&amp;#34; : &amp;#34;GuardTimeoutException&amp;#34;, &amp;#34;stacktrace&amp;#34; : [ &amp;#34;org.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting rid of an optional match</title>
      <link>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</link>
      <pubDate>Sun, 13 Oct 2013 21:59:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/13/neo4jcypher-getting-rid-of-an-optional-match/</guid>
      <description>MATCH (player:Player) WITH player MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT({goals: stats.goals, type: TYPE(t)}) AS games, player RETURN player.name, REDUCE(goals = 0, h IN [g IN games WHERE g.type IS NULL] | goals + h.goals) AS nonTvGoals, REDUCE(goals = 0, h IN [g IN games WHERE g.type &amp;lt;&amp;gt; NULL] | goals + h.goals) AS tvGoals, REDUCE(goals = 0, h in games | goals + h.goals) AS totalGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Converting queries from 1.9 to 2.0 -  &#39;Can&#39;t use optional patterns without explicit START clause&#39;</title>
      <link>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</link>
      <pubDate>Thu, 03 Oct 2013 16:16:02 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/10/03/neo4jcypher-converting-queries-from-1-9-to-2-0-cant-use-optional-patterns-without-explicit-start-clause/</guid>
      <description>START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?:on_tv]-&amp;gt;channel WITH COLLECT([stats.goals, TYPE(t)]) AS games, player RETURN player.name, REDUCE(goals = 0, g&#39; IN FILTER(g IN games WHERE HEAD(TAIL(g)) IS NULL)| goals + HEAD(g&#39;)) AS nonTvGoals, REDUCE(goals = 0, g&#39; IN FILTER(g IN games WHERE HEAD(TAIL(g)) &amp;lt;&amp;gt; NULL)| goals + HEAD(g&#39;)) AS tvGoals, REDUCE(goals = 0, g&#39; in games | goals + HEAD(g&#39;)) AS totalGoals ORDER BY tvGoals DESC LIMIT 10 ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | player.name | nonTvGoals | tvGoals | totalGoals | ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; | &amp;#34;Robin Van Persie&amp;#34; | 11 | 15 | 26 | ==&amp;gt; | &amp;#34;Gareth Bale&amp;#34; | 8 | 13 | 21 | ==&amp;gt; | &amp;#34;Luis Suárez&amp;#34; | 12 | 11 | 23 | ==&amp;gt; | &amp;#34;Theo Walcott&amp;#34; | 5 | 9 | 14 | ==&amp;gt; | &amp;#34;Demba Ba&amp;#34; | 7 | 8 | 15 | ==&amp;gt; | &amp;#34;Edin Dzeko&amp;#34; | 7 | 7 | 14 | ==&amp;gt; | &amp;#34;Santi Cazorla&amp;#34; | 5 | 7 | 12 | ==&amp;gt; | &amp;#34;Juan Mata&amp;#34; | 6 | 6 | 12 | ==&amp;gt; | &amp;#34;Steven Gerrard&amp;#34; | 3 | 6 | 9 | ==&amp;gt; | &amp;#34;Carlos Tevez&amp;#34; | 5 | 6 | 11 | ==&amp;gt; +--------------------------------------------------------+ ==&amp;gt; 10 rows START player = node:players(&#39;name:*&#39;) SET player :Player RETURN player CREATE INDEX on :Player(name) MATCH (player:Player)-[:played|subbed_on]-&amp;gt;stats-[:in]-&amp;gt;game-[t?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Translating 1.9 FILTER queries to use 2.0 list comprehensions</title>
      <link>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</link>
      <pubDate>Mon, 30 Sep 2013 21:34:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/09/30/neo4jcypher-translating-1-9-filter-queries-to-use-2-0-list-comprehensions/</guid>
      <description>START team = node:teams(&#39;name:*&#39;) MATCH team&amp;lt;-[:for]-like_this&amp;lt;-[:started|as_sub]-player-[r?:sent_off_in|booked_in]-&amp;gt;game&amp;lt;-[:in]-like_this WITH team, COLLECT(r) AS cards WITH team, FILTER(x IN cards: TYPE(x) = &amp;quot;sent_off_in&amp;quot;) AS reds, FILTER(x IN cards: TYPE(x) = &amp;quot;booked_in&amp;quot;) AS yellows RETURN team.name, LENGTH(reds) AS redCards, LENGTH(yellows) AS yellowCards ORDER BY (yellowCards*1 + redCards*3) DESC ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; | team.name | redCards | yellowCards | ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; | &amp;#34;Stoke City&amp;#34; | 4 | 81 | ==&amp;gt; | &amp;#34;Newcastle United&amp;#34; | 4 | 74 | ==&amp;gt; | &amp;#34;Aston Villa&amp;#34; | 3 | 74 | ==&amp;gt; | &amp;#34;West Ham United&amp;#34; | 1 | 74 | ==&amp;gt; | &amp;#34;West Bromwich Albion&amp;#34; | 4 | 63 | ==&amp;gt; | &amp;#34;Sunderland&amp;#34; | 3 | 63 | ==&amp;gt; | &amp;#34;Wigan Athletic&amp;#34; | 2 | 66 | ==&amp;gt; | &amp;#34;Manchester City&amp;#34; | 3 | 62 | ==&amp;gt; | &amp;#34;Everton&amp;#34; | 3 | 62 | ==&amp;gt; | &amp;#34;Queens Park Rangers&amp;#34; | 3 | 60 | ==&amp;gt; | &amp;#34;Swansea City&amp;#34; | 2 | 59 | ==&amp;gt; | &amp;#34;Norwich City&amp;#34; | 1 | 60 | ==&amp;gt; | &amp;#34;Chelsea&amp;#34; | 3 | 53 | ==&amp;gt; | &amp;#34;Liverpool&amp;#34; | 2 | 54 | ==&amp;gt; | &amp;#34;Manchester United&amp;#34; | 1 | 57 | ==&amp;gt; | &amp;#34;Tottenham Hotspur&amp;#34; | 2 | 54 | ==&amp;gt; | &amp;#34;Arsenal&amp;#34; | 5 | 44 | ==&amp;gt; | &amp;#34;Fulham&amp;#34; | 3 | 48 | ==&amp;gt; | &amp;#34;Southampton&amp;#34; | 2 | 44 | ==&amp;gt; | &amp;#34;Reading&amp;#34; | 1 | 45 | ==&amp;gt; +-------------------------------------------------+ ==&amp;gt; 20 rows ==&amp;gt; SyntaxException: Invalid input &amp;#39;(&amp;#39;: expected an identifier character, whitespace, NodeLabel, &amp;#39;.</description>
    </item>
    
    <item>
      <title>Neo4j&#39;s Graph Café London - 28th August 2013</title>
      <link>https://markhneedham.com/blog/2013/08/31/neo4js-graph-cafe-london-28th-august-2013/</link>
      <pubDate>Sat, 31 Aug 2013 10:52:14 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/31/neo4js-graph-cafe-london-28th-august-2013/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Model to answer your questions rather than modelling reality</title>
      <link>https://markhneedham.com/blog/2013/08/22/model-to-answer-your-questions-rather-than-modelling-reality/</link>
      <pubDate>Thu, 22 Aug 2013 21:26:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/22/model-to-answer-your-questions-rather-than-modelling-reality/</guid>
      <description></description>
    </item>
    
    <item>
      <title>neo4j: Extracting a subgraph as an adjacency matrix and calculating eigenvector centrality with JBLAS</title>
      <link>https://markhneedham.com/blog/2013/08/11/neo4j-extracting-a-subgraph-as-an-adjacency-matrix-and-calculating-eigenvector-centrality-with-jblas/</link>
      <pubDate>Sun, 11 Aug 2013 07:23:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/08/11/neo4j-extracting-a-subgraph-as-an-adjacency-matrix-and-calculating-eigenvector-centrality-with-jblas/</guid>
      <description>There were 3 steps involved in doing this:
MATCH p1:Person, p2:Person WHERE p1.name = &amp;quot;Paul Revere&amp;quot; WITH p1, p2 MATCH p = p1-[?:MEMBER_OF]-&amp;gt;()&amp;lt;-[?:MEMBER_OF]-p2 WITH p1.name AS p1, p2.name AS p2, COUNT(p) AS links ORDER BY p2 RETURN p1, COLLECT(links) AS row +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | p1 | row | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Paul Revere&amp;#34; | [2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,1,1,1,1,1,1,3,3,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,3,2,1,1,2,1,2,1,1,1,1,1,0,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,2,1,3,1,3,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,0,1,0,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,4,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,3,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,1,2,1,1,1,1,1,1,1,1,3,1,1,1,1,3,1,1,1,1,0,1,2,1,1,1,1,1,1,1] | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ MATCH p1:Person, p2:Person WITH p1, p2 MATCH p = p1-[?:MEMBER_OF]-&amp;gt;()&amp;lt;-[?:MEMBER_OF]-p2 WITH p1.name AS p1, p2.name AS p2, COUNT(p) AS links ORDER BY p2 RETURN p1, COLLECT(links) AS row ORDER BY p1 +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | p1 | row | +---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Abiel Ruddock&amp;#34; | [0,1,1,1,0,1,0,1,0,0,1,1,1,0,1,2,0,1,0,1,1,1,2,2,1,0,0,1,1,0,1,1,1,1,1,0,0,0,0,1,1,0,0,2,2,0,0,1,1,2,1,1,1,0,1,0,1,1,0,0,2,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,0,2,1,2,1,0,0,0,0,1,1,0,1,0,0,1,0,2,0,0,1,0,0,0,1,0,0,2,0,1,0,1,1,1,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,1,1,0,1,1,1,2,0,0,1,1,0,0,2,0,1,2,1,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,1,2,1,0,1,1,1,1,1,0,0,1,1,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,1,0,2,1,1,0,0,2,0,1,0,0,0,0,1,0,1,0,1,0,1,0] | | &amp;#34;Abraham Hunt&amp;#34; | [1,0,1,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,0,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0] | .</description>
    </item>
    
    <item>
      <title>Graph Processing: Betweeness Centrality - neo4j&#39;s cypher vs graphstream</title>
      <link>https://markhneedham.com/blog/2013/07/27/graph-processing-betweeness-centrality-neo4js-cypher-vs-graphstream/</link>
      <pubDate>Sat, 27 Jul 2013 11:21:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/07/27/graph-processing-betweeness-centrality-neo4js-cypher-vs-graphstream/</guid>
      <description>A -&amp;gt; B: Direct Path Exists A -&amp;gt; C: B A -&amp;gt; D: E A -&amp;gt; E: Direct Path Exists B -&amp;gt; A: No Path Exists B -&amp;gt; C: Direct Path Exists B -&amp;gt; D: E or C B -&amp;gt; E: Direct Path Exists C -&amp;gt; A: No Path Exists C -&amp;gt; B: No Path Exists C -&amp;gt; D: Direct Path Exists C -&amp;gt; E: No Path Exists D -&amp;gt; A: No Path Exists D -&amp;gt; B: No Path Exists D -&amp;gt; C: No Path Exists D -&amp;gt; E: No Path Exists E -&amp;gt; A: No Path Exists E -&amp;gt; B: No Path Exists E -&amp;gt; C: No Path Exists E -&amp;gt; D: Direct Path Exists A: 0 B: 1 C: 0.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of query parameters</title>
      <link>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</link>
      <pubDate>Sat, 27 Jul 2013 09:30:26 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/07/27/neo4jcypher-getting-the-hang-of-query-parameters/</guid>
      <description>require &amp;#39;open-uri&amp;#39; open(&amp;#34;data/people.cyp&amp;#34;, &amp;#39;w&amp;#39;) { |f| (1..500).each do |value| f.puts(&amp;#34;CREATE (p:Person{name: \&amp;#34;#{value}\&amp;#34;})&amp;#34;) end } CREATE (:Person{name: &amp;quot;person1&amp;quot;}) CREATE (:Person{name: &amp;quot;person2&amp;quot;}) CREATE (:Person{name: &amp;quot;person3&amp;quot;}) CREATE (:Person{name: &amp;quot;person4&amp;quot;}) CREATE (:Person{name: &amp;quot;person5&amp;quot;}) ... ==&amp;gt; +-------------------+ ==&amp;gt; | No data returned. | ==&amp;gt; +-------------------+ ==&amp;gt; Nodes created: 500 ==&amp;gt; Properties set: 500 ==&amp;gt; Labels added: 500 ==&amp;gt; 27706 ms require &amp;#39;neography&amp;#39; params = { :name =&amp;gt; &amp;#34;Mark&amp;#34; } Neography::Rest.new.execute_query(&amp;#34;CREATE (:Person {name: {name} })&amp;#34;, params) neo4j-sh (0)$ match p:Person return p; ==&amp;gt; +----------------------+ ==&amp;gt; | p | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[1]{name:&amp;#34;Mark&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; 1 row ==&amp;gt; 175 ms require &amp;#39;neography&amp;#39; params = { :name =&amp;gt; [] } (1.</description>
    </item>
    
    <item>
      <title>neo4j Unmanaged Extension: Creating gzipped streamed responses with Jetty</title>
      <link>https://markhneedham.com/blog/2013/07/08/neo4j-unmanaged-extension-creating-gzipped-streamed-responses-with-jetty/</link>
      <pubDate>Mon, 08 Jul 2013 23:48:23 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/07/08/neo4j-unmanaged-extension-creating-gzipped-streamed-responses-with-jetty/</guid>
      <description>package com.markandjim; public class GZipInitialiser implements SPIPluginLifecycle { private WebServer webServer; @Override public Collection&amp;lt;Injectable&amp;lt;?&amp;gt;&amp;gt; start(NeoServer neoServer) { webServer = getWebServer(neoServer); GzipFilter filter = new GzipFilter(); webServer.addFilter(filter, &amp;#34;/*&amp;#34;); return Collections.emptyList(); } private WebServer getWebServer(final NeoServer neoServer) { if (neoServer instanceof AbstractNeoServer) { return ((AbstractNeoServer) neoServer).getWebServer(); } throw new IllegalArgumentException(&amp;#34;expected AbstractNeoServer&amp;#34;); } @Override public Collection&amp;lt;Injectable&amp;lt;?&amp;gt;&amp;gt; start(GraphDatabaseService graphDatabaseService, Configuration configuration) { throw new IllegalAccessError(); } @Override public void stop() { } } com.markandjim.GZipInitialiser $ curl -H &amp;#34;Accept-Encoding:gzip,deflate&amp;#34; -v http://localhost:7474/unmanaged/subgraph/1000/1 * About to connect() to localhost port 7474 (#0) * Trying ::1.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Aggregating relationships within a path</title>
      <link>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</link>
      <pubDate>Thu, 27 Jun 2013 10:32:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/27/neo4jcypher-aggregating-relationships-within-a-path/</guid>
      <description>CREATE (email1 { name: &#39;Email 1&#39;, title: &#39;Some stuff&#39; }) CREATE (email2 { name: &#39;Email 2&#39;, title: &amp;quot;Absolutely irrelevant&amp;quot; }) CREATE (email3 { name: &#39;Email 3&#39;, title: &amp;quot;Something else&amp;quot; }) CREATE (person1 { name: &#39;Mark&#39; }) CREATE (person2 { name: &#39;Jim&#39; }) CREATE (person3 { name: &#39;Alistair&#39; }) CREATE (person1)-[:SENT]-&amp;gt;(email1) CREATE (person2)-[:RECEIVED]-&amp;gt;(email1) CREATE (person3)-[:RECEIVED]-&amp;gt;(email1) CREATE (person1)-[:SENT]-&amp;gt;(email2) CREATE (person2)-[:RECEIVED]-&amp;gt;(email2) CREATE (person2)-[:SENT]-&amp;gt;(email3) CREATE (person1)-[:RECEIVED]-&amp;gt;(email3) +-------------------------------------------+ | Person 1 | Person 2 | P1 -&amp;gt; P2 | P2 -&amp;gt; P1 | |-------------------------------------------| | Alistair | Mark | 0 | 1 | | Jim | Mark | 1 | 2 | +-------------------------------------------+ START email = node:node_auto_index(&#39;name:&amp;quot;Email 1&amp;quot; name:&amp;quot;Email 2&amp;quot; name: &amp;quot;Email 3&amp;quot;&#39;) MATCH sender-[:SENT]-&amp;gt;email&amp;lt;-[:RECEIVED]-receiver RETURN sender.</description>
    </item>
    
    <item>
      <title>neo4j Spatial: Indexing football stadiums using the REST API</title>
      <link>https://markhneedham.com/blog/2013/06/24/neo4j-spatial-indexing-football-stadiums-using-the-rest-api/</link>
      <pubDate>Mon, 24 Jun 2013 07:17:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/24/neo4j-spatial-indexing-football-stadiums-using-the-rest-api/</guid>
      <description>Name,Team,Capacity,Latitude,Longitude &amp;#34;Adams Park&amp;#34;,&amp;#34;Wycombe Wanderers&amp;#34;,10284,51.6306,-0.800299 &amp;#34;Almondvale Stadium&amp;#34;,&amp;#34;Livingston&amp;#34;,10122,55.8864,-3.52207 &amp;#34;Amex Stadium&amp;#34;,&amp;#34;Brighton and Hove Albion&amp;#34;,22374,50.8609,-0.08014 require &amp;#39;csv&amp;#39; require &amp;#39;httparty&amp;#39; require &amp;#39;json&amp;#39; HTTParty.post(&amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addSimplePointLayer&amp;#34;, :body =&amp;gt; { :layer =&amp;gt; &amp;#39;geom&amp;#39;, :lat =&amp;gt; &amp;#39;lat&amp;#39;, :lon =&amp;gt; &amp;#39;lon&amp;#39; }.to_json, :headers =&amp;gt; { &amp;#39;Content-Type&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39; } ) HTTParty.post(&amp;#34;http://localhost:7474/db/data/index/node&amp;#34;, :body =&amp;gt; { :name =&amp;gt; &amp;#39;geom&amp;#39;, :config =&amp;gt; { :provider =&amp;gt; &amp;#39;spatial&amp;#39;, :geometry_type =&amp;gt; &amp;#39;point&amp;#39;, :lat =&amp;gt; &amp;#39;lat&amp;#39;, :lon =&amp;gt; &amp;#39;lon&amp;#39; } }.to_json, :headers =&amp;gt; { &amp;#39;Content-Type&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39; } ) contents = CSV.</description>
    </item>
    
    <item>
      <title>neo4j: A simple example using the JDBC driver</title>
      <link>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</link>
      <pubDate>Thu, 20 Jun 2013 07:21:46 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/20/neo4j-a-simple-example-using-the-jdbc-driver/</guid>
      <description>&amp;lt;dependencies&amp;gt; ... &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.neo4j&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;neo4j-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; &amp;lt;repositories&amp;gt; &amp;lt;repository&amp;gt; &amp;lt;id&amp;gt;neo4j-maven&amp;lt;/id&amp;gt; &amp;lt;name&amp;gt;neo4j maven&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://m2.neo4j.org&amp;lt;/url&amp;gt; &amp;lt;/repository&amp;gt; &amp;lt;/repositories&amp;gt; Neo4jConnection connect = new Driver(). connect(&amp;#34;jdbc:neo4j://localhost:7474&amp;#34;, new Properties()); Exception in thread &amp;#34;main&amp;#34; java.lang.NoClassDefFoundError: org/neo4j/cypherdsl/grammar/Execute at org.neo4j.jdbc.Driver.&amp;lt;init&amp;gt;(Driver.java:52) at org.neo4j.jdbc.Driver.&amp;lt;clinit&amp;gt;(Driver.java:43) at com.centrica.bigquery.JDBCTest.main(JDBCTest.java:17) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:601) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120) Caused by: java.lang.ClassNotFoundException: org.neo4j.cypherdsl.grammar.Execute at java.net.URLClassLoader$1.run(URLClassLoader.java:366) at java.net.URLClassLoader$1.run(URLClassLoader.java:355) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:354) at java.lang.ClassLoader.loadClass(ClassLoader.java:423) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308) at java.lang.ClassLoader.loadClass(ClassLoader.java:356) ... 8 more &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CREATE with optional properties</title>
      <link>https://markhneedham.com/blog/2013/06/20/neo4jcypher-create-with-optional-properties/</link>
      <pubDate>Thu, 20 Jun 2013 06:31:11 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/20/neo4jcypher-create-with-optional-properties/</guid>
      <description>CREATE (person1 { personId: 1, started: 1361708546 }) CREATE (person2 { personId: 2, started: 1361708546, left: 1371708646 }) CREATE (company { companyId: 1 }) START person = node:node_auto_index(&#39;personId:1 personId:2&#39;), company = node:node_auto_index(&#39;companyId:1&#39;) CREATE person-[:TENURE_AT { started: person.started, left: person.left }]-company RETURN person, company Error: org.neo4j.cypher.EntityNotFoundException: The property &amp;#39;left&amp;#39; does not exist on Node[1] START person = node:node_auto_index(&#39;personId:1 personId:2&#39;), company = node:node_auto_index(&#39;companyId:1&#39;) CREATE person-[:TENURE_AT { started: person.started, left: person.left? }]-company RETURN person, company Error: java.</description>
    </item>
    
    <item>
      <title>neo4j: WrappingNeoServerBootstrapper and the case of the /webadmin 404</title>
      <link>https://markhneedham.com/blog/2013/06/19/neo4j-wrappingneoserverbootstrapper-and-the-case-of-the-webadmin-404/</link>
      <pubDate>Wed, 19 Jun 2013 05:32:50 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/19/neo4j-wrappingneoserverbootstrapper-and-the-case-of-the-webadmin-404/</guid>
      <description>public class GraphMeUp { public static void main(String[] args) { GraphDatabaseService graphDb = new EmbeddedGraphDatabase(&amp;#34;/path/to/data/graph.db&amp;#34;); } } public class GraphMeUp { public static void main(String[] args) { GraphDatabaseService graphDb = new GraphDatabaseFactory(). newEmbeddedDatabaseBuilder(&amp;#34;/path/to/data/graph.db&amp;#34;). newGraphDatabase(); } } &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.neo4j.app&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;neo4j-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; public class GraphMeUp { public static void main(String[] args) { GraphDatabaseService graphDb = new GraphDatabaseFactory(). newEmbeddedDatabaseBuilder(&amp;#34;/path/to/data/graph.db&amp;#34;). newGraphDatabase(); new WrappingNeoServerBootstrapper((GraphDatabaseAPI)graphDb).start(); } } HTTP ERROR 404 Problem accessing /webadmin/. Reason: Not Found Powered by Jetty:// &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding single hop paths</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</link>
      <pubDate>Sat, 15 Jun 2013 13:04:53 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypher-finding-single-hop-paths/</guid>
      <description>CREATE (ranieri {name: &amp;quot;Claudio Ranieri&amp;quot;}) CREATE (mourinho {name: &amp;quot;Jose Mourinho&amp;quot;}) CREATE (grant {name: &amp;quot;Avram Grant&amp;quot;}) CREATE (scolari {name: &amp;quot;Luiz Felipe Scolari&amp;quot;}) CREATE (wilkins {name: &amp;quot;Ray Wilkins&amp;quot;}) CREATE (hiddink {name: &amp;quot;Guus Hiddink&amp;quot;}) CREATE (ancelotti {name: &amp;quot;Carlo Ancelotti&amp;quot;}) CREATE (villasBoas {name: &amp;quot;Andre Villas Boas&amp;quot;}) CREATE (diMatteo {name: &amp;quot;Roberto Di Matteo&amp;quot;}) CREATE (benitez {name: &amp;quot;Rafael Benitez&amp;quot;}) CREATE (ranieri)-[:SUCCEEDED_BY]-&amp;gt;(mourinho) CREATE (mourinho)-[:SUCCEEDED_BY]-&amp;gt;(grant) CREATE (grant)-[:SUCCEEDED_BY]-&amp;gt;(scolari) CREATE (scolari)-[:SUCCEEDED_BY]-&amp;gt;(wilkins) CREATE (wilkins)-[:SUCCEEDED_BY]-&amp;gt;(hiddink) CREATE (hiddink)-[:SUCCEEDED_BY]-&amp;gt;(ancelotti) CREATE (ancelotti)-[:SUCCEEDED_BY]-&amp;gt;(villasBoas) CREATE (villasBoas)-[:SUCCEEDED_BY]-&amp;gt;(diMatteo) CREATE (diMatteo)-[:SUCCEEDED_BY]-&amp;gt;(benitez) CREATE (benitez)-[:SUCCEEDED_BY]-&amp;gt;(mourinho) START m = node:node_auto_index(name=&amp;quot;Claudio Ranieri&amp;quot;) MATCH path = (m)-[rel:SUCCEEDED_BY*]-&amp;gt;(successor) RETURN EXTRACT(n IN NODES(path): n.</description>
    </item>
    
    <item>
      <title>neo4j/cypher/Lucene: Dealing with special characters</title>
      <link>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</link>
      <pubDate>Sat, 15 Jun 2013 09:53:15 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/15/neo4jcypherlucene-dealing-with-special-characters/</guid>
      <description>CREATE ({name: &amp;quot;-one&amp;quot;}) CREATE ({name: &amp;quot;-two&amp;quot;}) CREATE ({name: &amp;quot;-three&amp;quot;}) CREATE ({name: &amp;quot;four&amp;quot;}) START p = node:node_auto_index(&amp;quot;name:-*&amp;quot;) RETURN p; ==&amp;gt; RuntimeException: org.apache.lucene.queryParser.ParseException: Cannot parse &amp;#39;name:-*&amp;#39;: Encountered &amp;#34; &amp;#34;-&amp;#34; &amp;#34;- &amp;#34;&amp;#34; at line 1, column 5. ==&amp;gt; Was expecting one of: ==&amp;gt; &amp;lt;BAREOPER&amp;gt; ... ==&amp;gt; &amp;#34;(&amp;#34; ... ==&amp;gt; &amp;#34;*&amp;#34; ... ==&amp;gt; &amp;lt;QUOTED&amp;gt; ... ==&amp;gt; &amp;lt;TERM&amp;gt; ... ==&amp;gt; &amp;lt;PREFIXTERM&amp;gt; ... ==&amp;gt; &amp;lt;WILDTERM&amp;gt; ... ==&amp;gt; &amp;#34;[&amp;#34; ... ==&amp;gt; &amp;#34;{&amp;#34; ... ==&amp;gt; &amp;lt;NUMBER&amp;gt; ... ==&amp;gt; START p = node:node_auto_index(&amp;quot;name:\-*&amp;quot;) RETURN p; ==&amp;gt; SyntaxException: invalid escape sequence ==&amp;gt; ==&amp;gt; Think we should have better error message here?</description>
    </item>
    
    <item>
      <title>neo4j.rb HA: NameError: cannot load Java class org.neo4j.graphdb.factory.HighlyAvailableGraphDatabaseFactory</title>
      <link>https://markhneedham.com/blog/2013/06/09/neo4j-rb-ha-nameerror-cannot-load-java-class-org-neo4j-graphdb-factory-highlyavailablegraphdatabasefactory/</link>
      <pubDate>Sun, 09 Jun 2013 16:57:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/09/neo4j-rb-ha-nameerror-cannot-load-java-class-org-neo4j-graphdb-factory-highlyavailablegraphdatabasefactory/</guid>
      <description>source &amp;#39;http://rubygems.org&amp;#39; gem &amp;#39;neo4j&amp;#39;, &amp;#39;2.2.4&amp;#39; gem &amp;#39;neo4j-community&amp;#39;, &amp;#39;1.8.2&amp;#39; gem &amp;#39;neo4j-advanced&amp;#39;, &amp;#39;1.8.2&amp;#39; gem &amp;#39;neo4j-enterprise&amp;#39;, &amp;#39;1.8.2&amp;#39; require &amp;#34;rubygems&amp;#34; require &amp;#34;bundler&amp;#34; require &amp;#39;fileutils&amp;#39; require &amp;#39;neo4j&amp;#39; def start(machine_id) # override this default config with this machine configuration Neo4j.config[&amp;#39;enable_ha&amp;#39;] = true Neo4j.config[&amp;#39;ha.server_id&amp;#39;] = machine_id Neo4j.config[&amp;#39;ha.server&amp;#39;] = &amp;#34;localhost:600#{machine_id}&amp;#34; Neo4j.config[&amp;#39;ha.pull_interval&amp;#39;] = &amp;#39;500ms&amp;#39; Neo4j.config[&amp;#39;ha.discovery.enabled&amp;#39;] = false other_machines = [1,2,3].map{|id| &amp;#34;localhost:500#{id}&amp;#34;}.join(&amp;#39;,&amp;#39;) puts &amp;#34;ha.initial_hosts: #{other_machines}&amp;#34; Neo4j.config[&amp;#39;ha.initial_hosts&amp;#39;] = other_machines Neo4j.config[&amp;#39;ha.cluster_server&amp;#39;] = &amp;#34;localhost:500#{machine_id}&amp;#34; Neo4j.config[:storage_path] = &amp;#34;db/neo#{machine_id}&amp;#34; Neo4j.start end $ bundle exec install $ bundle exec irb irb(main):001:0&amp;gt; require &amp;#39;myapp&amp;#39; =&amp;gt; true irb(main):002:0&amp;gt; start 1 ha.</description>
    </item>
    
    <item>
      <title>neo4j/cypher 2.0: The CASE statement</title>
      <link>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</link>
      <pubDate>Sun, 09 Jun 2013 14:02:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/06/09/neo4jcypher-2-0-the-case-statement/</guid>
      <description>CREATE (year2013 { name: &amp;quot;2013&amp;quot; }) CREATE (january2013 { name: &amp;quot;January&amp;quot; }) CREATE (january012013 { name: &amp;quot;1st&amp;quot; }) CREATE (january022013 { name: &amp;quot;2nd&amp;quot; }) CREATE (january032013 { name: &amp;quot;3rd&amp;quot; }) CREATE (january042013 { name: &amp;quot;4th&amp;quot; }) CREATE (january052013 { name: &amp;quot;5th&amp;quot; }) CREATE (chelsea { name: &amp;quot;Chelsea&amp;quot;, type: &amp;quot;team&amp;quot; }) CREATE (joseMourinho { name: &amp;quot;Jose Mourinho&amp;quot;}) CREATE (mourinhoChelsea { name: &amp;quot;Mourinho tenure at Chelsea&amp;quot; }) CREATE (manUtd { name: &amp;quot;Manchester United&amp;quot;, type: &amp;quot;team&amp;quot; }) CREATE (davidMoyes { name: &amp;quot;David Moyes&amp;quot;}) CREATE (davidMoyesUnited { name: &amp;quot;Moyes tenure at Manchester United&amp;quot; }) CREATE (year2013)-[:`January`]-(january2013) CREATE (january2013)-[:`01`]-(january012013) CREATE (january2013)-[:`02`]-(january022013) CREATE (january2013)-[:`03`]-(january032013) CREATE (january2013)-[:`04`]-(january042013) CREATE (january2013)-[:`05`]-(january052013) CREATE (january012013)-[:NEXT]-(january022013) CREATE (january022013)-[:NEXT]-(january032013) CREATE (january032013)-[:NEXT]-(january042013) CREATE (january042013)-[:NEXT]-(january052013) CREATE (mourinhoChelsea)-[:HIRED_ON {date: &amp;quot;January 1st 2013&amp;quot;}]-&amp;gt;(january012013) CREATE (mourinhoChelsea)-[:MANAGER]-&amp;gt;(joseMourinho) CREATE (mourinhoChelsea)-[:TEAM]-&amp;gt;(chelsea) CREATE (mourinhoChelsea)-[:FIRED_ON]-&amp;gt;(january032013) CREATE (davidMoyesUnited)-[:HIRED_ON {date: &amp;quot;January 2nd 2013&amp;quot;}]-&amp;gt;(january022013) CREATE (davidMoyesUnited)-[:MANAGER]-&amp;gt;(davidMoyes) CREATE (davidMoyesUnited)-[:TEAM]-&amp;gt;(manUtd) START team = node:node_auto_index(&#39;name:&amp;quot;Chelsea&amp;quot; name:&amp;quot;Manchester United&amp;quot;&#39;), date = node:node_auto_index(name=&amp;quot;5th&amp;quot;) MATCH date&amp;lt;-[:NEXT*0.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: 400 response - Paths can&#39;t be created inside of foreach</title>
      <link>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</link>
      <pubDate>Fri, 31 May 2013 00:37:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/31/neo4jcypher-400-response-paths-cant-be-created-inside-of-foreach/</guid>
      <description>require &amp;#39;neography&amp;#39; neo = Neography::Rest.new neo.execute_query(&amp;#34;create (me {name: &amp;#39;Mark&amp;#39;})&amp;#34;) query = &amp;#34; START n=node:node_auto_index(name={name})&amp;#34; query &amp;lt;&amp;lt; &amp;#34; FOREACH (friend in {friends} : CREATE f=friend, n-[:FRIEND]-&amp;gt;f)&amp;#34; neo.execute_query(query, {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Mark&amp;#34;, &amp;#34;friends&amp;#34; =&amp;gt; [{ &amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Will&amp;#34;}, {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Paul&amp;#34;}]}) START p = node:node_auto_index(name=&amp;quot;Mark&amp;quot;) MATCH p-[:FRIEND]-f RETURN f ==&amp;gt; +----------------------+ ==&amp;gt; | f | ==&amp;gt; +----------------------+ ==&amp;gt; | Node[2]{name:&amp;#34;Will&amp;#34;} | ==&amp;gt; | Node[3]{name:&amp;#34;Paul&amp;#34;} | ==&amp;gt; +----------------------+ ==&amp;gt; 2 rows ==&amp;gt; 37 ms /Users/markhneedham/.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Properties or relationships? It&#39;s easy to switch</title>
      <link>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</link>
      <pubDate>Sat, 25 May 2013 12:21:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/25/neo4jcypher-properties-or-relationships-its-easy-to-switch/</guid>
      <description>CREATE (frenchConnection { name: &amp;quot;French Connection&amp;quot; }) CREATE (dress1 { name: &amp;quot;Halter Dress&amp;quot;, colour: &amp;quot;Blue&amp;quot;})-[:BRAND]-(frenchConnection) CREATE (dress2 { name: &amp;quot;Another Dress&amp;quot;, colour: &amp;quot;Yellow&amp;quot;})-[:BRAND]-(frenchConnection) CREATE (dress3 { name: &amp;quot;Different Dress&amp;quot;, colour: &amp;quot;Blue&amp;quot;})-[:BRAND]-(frenchConnection) RETURN dress1, dress2, dress3 ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | dress1 | dress2 | dress3 | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; | Node[2]{name:&amp;#34;Halter Dress&amp;#34;,colour:&amp;#34;Blue&amp;#34;} | Node[3]{name:&amp;#34;Another Dress&amp;#34;,colour:&amp;#34;Yellow&amp;#34;} | Node[4]{name:&amp;#34;Different Dress&amp;#34;,colour:&amp;#34;Blue&amp;#34;} | ==&amp;gt; +--------------------------------------------------------------------------------------------------------------------------------------------+ ==&amp;gt; 1 row ==&amp;gt; Nodes created: 4 ==&amp;gt; Relationships created: 3 ==&amp;gt; Properties set: 7 ==&amp;gt; 179 ms START brand = node:node_auto_index(name=&amp;quot;French Connection&amp;quot;) MATCH brand&amp;lt;-[:BRAND]-product WHERE product.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Keep longest path when finding taxonomy</title>
      <link>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</link>
      <pubDate>Sun, 19 May 2013 22:15:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/19/neo4jcypher-keep-longest-path-when-finding-taxonomy/</guid>
      <description>CREATE (cat { name: &amp;quot;Cat&amp;quot; }) CREATE (subcat1 { name: &amp;quot;SubCat1&amp;quot; }) CREATE (subcat2 { name: &amp;quot;SubCat2&amp;quot; }) CREATE (subsubcat1 { name: &amp;quot;SubSubCat1&amp;quot; }) CREATE (product1 { name: &amp;quot;Product1&amp;quot; }) CREATE (cat)-[:CHILD]-subcat1-[:CHILD]-subsubcat1 CREATE (product1)-[:HAS_CATEGORY]-(subsubcat1) START product=node:node_auto_index(name=&amp;quot;Product1&amp;quot;) MATCH product-[:HAS_CATEGORY]-category, taxonomy=category&amp;lt;-[:CHILD*1..]-parent RETURN product, EXTRACT(n IN NODES(taxonomy): n.name) ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; | product | EXTRACT(n IN NODES(taxonomy): n.name) | ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; | Node[888]{name:&amp;#34;Product1&amp;#34;} | [&amp;#34;SubSubCat1&amp;#34;,&amp;#34;SubCat1&amp;#34;] | ==&amp;gt; | Node[888]{name:&amp;#34;Product1&amp;#34;} | [&amp;#34;SubSubCat1&amp;#34;,&amp;#34;SubCat1&amp;#34;,&amp;#34;Cat&amp;#34;] | ==&amp;gt; +--------------------------------------------------------------------+ ==&amp;gt; 2 rows START product=node:node_auto_index(name=&amp;quot;Product1&amp;quot;) MATCH product-[:HAS_CATEGORY]-category, taxonomy=category&amp;lt;-[:CHILD*1.</description>
    </item>
    
    <item>
      <title>neo4j: When the web console returns nothing…use the data browser!</title>
      <link>https://markhneedham.com/blog/2013/05/17/neo4j-when-the-web-console-returns-nothinguse-the-data-browser/</link>
      <pubDate>Fri, 17 May 2013 00:00:16 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/05/17/neo4j-when-the-web-console-returns-nothinguse-the-data-browser/</guid>
      <description>require &amp;#39;neography&amp;#39; @neo = Neography::Rest.new @neo.create_node_index(&amp;#34;Id_Index&amp;#34;, &amp;#34;exact&amp;#34;, &amp;#34;lucene&amp;#34;) node1 = @neo.create_node(&amp;#34;Hour&amp;#34; =&amp;gt; 1, &amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Max&amp;#34;) node2 = @neo.create_node(&amp;#34;Hour&amp;#34; =&amp;gt; 2, &amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Mark&amp;#34;) node3 = @neo.create_node(&amp;#34;Hour&amp;#34; =&amp;gt; 3, &amp;#34;name&amp;#34; =&amp;gt; &amp;#34;Rickard&amp;#34;) @neo.add_node_to_index(&amp;#34;Id_Index&amp;#34;, &amp;#34;Hour&amp;#34;, 1, node1) @neo.add_node_to_index(&amp;#34;Id_Index&amp;#34;, &amp;#34;Hour&amp;#34;, 2, node2) @neo.add_node_to_index(&amp;#34;Id_Index&amp;#34;, &amp;#34;Hour&amp;#34;, 3, node3) start hour=node:Id_Index(&amp;quot;Hour:[00 TO 02] or Hour:[03 TO 05]&amp;quot;) RETURN hour BadInputException StackTrace: org.neo4j.server.rest.repr.RepresentationExceptionHandlingIterable.exceptionOnHasNext(RepresentationExceptionHandlingIterable.java:50) org.neo4j.helpers.collection.ExceptionHandlingIterable$1.hasNext(ExceptionHandlingIterable.java:60) org.neo4j.helpers.collection.IteratorWrapper.hasNext(IteratorWrapper.java:42) org.neo4j.server.rest.repr.ListRepresentation.serialize(ListRepresentation.java:58) org.neo4j.server.rest.repr.Serializer.serialize(Serializer.java:75) org.neo4j.server.rest.repr.MappingSerializer.putList(MappingSerializer.java:61) org.neo4j.server.rest.repr.CypherResultRepresentation.serialize(CypherResultRepresentation.java:57) org.neo4j.server.rest.repr.MappingRepresentation.serialize(MappingRepresentation.java:42) org.neo4j.server.rest.repr.OutputFormat.assemble(OutputFormat.java:179) org.neo4j.server.rest.repr.OutputFormat.formatRepresentation(OutputFormat.java:131) org.neo4j.server.rest.repr.OutputFormat.response(OutputFormat.java:117) org.neo4j.server.rest.repr.OutputFormat.ok(OutputFormat.java:55) org.neo4j.server.rest.web.CypherService.cypher(CypherService.java:94) java.lang.reflect.Method.invoke(Method.java:597) start hour=node:Id_Index(&amp;quot;Hour:[00 TO 02] Hour:[03 TO 05]&amp;quot;) RETURN hour </description>
    </item>
    
    <item>
      <title>neo4j/cypher: Returning a row with zero count when no relationship exists</title>
      <link>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</link>
      <pubDate>Tue, 30 Apr 2013 07:02:09 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/30/neo4jcypher-returning-a-row-with-zero-count-when-no-relationship-exists/</guid>
      <description>START game = node:matches(&#39;match_id:*&#39;) MATCH game&amp;lt;-[:sent_off_in]-player-[:played]-&amp;gt;likeThis-[:in]-&amp;gt;game, likeThis-[:for]-&amp;gt;team RETURN team.name, COUNT(game) AS redCards ORDER BY redCards LIMIT 5 +------------------------------+ | team.name | redCards | +------------------------------+ | &amp;#34;Sunderland&amp;#34; | 1 | | &amp;#34;West Ham United&amp;#34; | 1 | | &amp;#34;Norwich City&amp;#34; | 1 | | &amp;#34;Reading&amp;#34; | 1 | | &amp;#34;Liverpool&amp;#34; | 2 | +------------------------------+ 5 rows START game = node:matches(&#39;match_id:*&#39;) MATCH game&amp;lt;-[?:sent_off_in]-player-[:played]-&amp;gt;likeThis-[:in]-&amp;gt;game, likeThis-[:for]-&amp;gt;team RETURN team.name, COUNT(game) AS redCards ORDER BY redCards ASC LIMIT 5 +-----------------------------+ | team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Redundant relationships</title>
      <link>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</link>
      <pubDate>Tue, 16 Apr 2013 21:41:58 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/04/16/neo4jcypher-redundant-relationships/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:started|as_sub]-playedLike-[:in]-game-[r?:scored_in]-player WITH player, COUNT(DISTINCT game) AS games, COLLECT(r) AS allGoals RETURN player.name, games, LENGTH(allGoals) AS goals ORDER BY goals DESC LIMIT 5 +------------------------------------+ | player.name | games | goals | +------------------------------------+ | &amp;#34;Luis Suárez&amp;#34; | 30 | 22 | | &amp;#34;Robin Van Persie&amp;#34; | 30 | 19 | | &amp;#34;Gareth Bale&amp;#34; | 27 | 17 | | &amp;#34;Michu&amp;#34; | 29 | 16 | | &amp;#34;Demba Ba&amp;#34; | 28 | 15 | +------------------------------------+ 5 rows 1 ms START player = node:players(&#39;name:*&#39;) MATCH player-[:played]-playedLike-[:in]-game-[r?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Playing around with time</title>
      <link>https://markhneedham.com/blog/2013/03/31/neo4jcypher-playing-around-with-time/</link>
      <pubDate>Sun, 31 Mar 2013 21:08:22 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/31/neo4jcypher-playing-around-with-time/</guid>
      <description>&amp;gt; DateTime.now.strftime(&amp;#34;%H%M&amp;#34;) =&amp;gt; &amp;#34;2200&amp;#34; START game=node:times(&#39;time:*&#39;) RETURN game.time, COUNT(game) ORDER BY game.time +-------------------------+ | game.time | COUNT(game) | +-------------------------+ | 1245 | 21 | | 1330 | 21 | | 1500 | 163 | | 1600 | 29 | | 1730 | 22 | | 1945 | 21 | | 2000 | 19 | +-------------------------+ 7 rows START game=node:matches(&#39;match_id:*&#39;) RETURN game.time, COUNT(game) ORDER BY game.time START game=node:times(&#39;time:[1600 TO 2000]&#39;) RETURN game.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CypherTypeException: Failed merging Number with Relationship</title>
      <link>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</link>
      <pubDate>Sun, 24 Mar 2013 13:00:29 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/24/neo4jcypher-cyphertypeexception-failed-merging-number-with-relationship/</guid>
      <description>game-[:on_tv]-channel START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?:on_tv]-channel RETURN player.name, COLLECT([stats.goals, t]) AS games LIMIT 10 CypherTypeException: Failed merging Number with Relationship START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?:on_tv]-channel RETURN player.name, COLLECT([stats.goals, TYPE(t)]) AS games LIMIT 10 +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | player.name | games | +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Djibril Cissé&amp;#34; | [[0,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;]] | | &amp;#34;Markus Rosenberg&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Gabriel Agbonlahor&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Shaun Derry&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Marouane Fellaini&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;#34;on_tv&amp;#34;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[2,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[2,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Jermaine Jenas&amp;#34; | [[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;]] | | &amp;#34;Sean Morrison&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[1,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;]] | | &amp;#34;Claudio Yacob&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Michael Owen&amp;#34; | [[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[1,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | | &amp;#34;Tony Hibbert&amp;#34; | [[0,&amp;#34;on_tv&amp;#34;],[0,&amp;#34;on_tv&amp;#34;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;],[0,&amp;lt;null&amp;gt;]] | +----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 10 rows START player=node:players(&#39;name:*&#39;) MATCH player-[:played|subbed_on]-stats-[:in]-game-[t?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: WITH, COLLECT &amp; EXTRACT</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</link>
      <pubDate>Wed, 20 Mar 2013 02:54:43 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-with-collect-extract/</guid>
      <description>START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[h:home_team|away_team]-game-[:on_day]-day RETURN DISTINCT day.name, COLLECT(TRIM(REPLACE(REPLACE(game.name, &amp;quot;Manchester United&amp;quot;, &amp;quot;&amp;quot;), &amp;quot;vs&amp;quot;, &amp;quot;&amp;quot;))) +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | day.name | opponents | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | &amp;#34;Sunday&amp;#34; | [&amp;#34;Liverpool&amp;#34;,&amp;#34;Everton&amp;#34;,&amp;#34;Southampton&amp;#34;,&amp;#34;Liverpool&amp;#34;,&amp;#34;Newcastle United&amp;#34;,&amp;#34;Chelsea&amp;#34;,&amp;#34;Manchester City&amp;#34;,&amp;#34;Swansea City&amp;#34;,&amp;#34;Tottenham Hotspur&amp;#34;] | | &amp;#34;Wednesday&amp;#34; | [&amp;#34;Southampton&amp;#34;,&amp;#34;West Ham United&amp;#34;,&amp;#34;Newcastle United&amp;#34;] | | &amp;#34;Monday&amp;#34; | [&amp;#34;Everton&amp;#34;] | | &amp;#34;Saturday&amp;#34; | [&amp;#34;Reading&amp;#34;,&amp;#34;Fulham&amp;#34;,&amp;#34;Wigan Athletic&amp;#34;,&amp;#34;Tottenham Hotspur&amp;#34;,&amp;#34;Stoke City&amp;#34;,&amp;#34;Arsenal&amp;#34;,&amp;#34;Queens Park Rangers&amp;#34;,&amp;#34;Sunderland&amp;#34;,&amp;#34;West Bromwich Albion&amp;#34;,&amp;#34;Norwich City&amp;#34;,&amp;#34;Reading&amp;#34;,&amp;#34;Aston Villa&amp;#34;,&amp;#34;Norwich City&amp;#34;,&amp;#34;Fulham&amp;#34;,&amp;#34;Queens Park Rangers&amp;#34;] | | &amp;#34;Tuesday&amp;#34; | [&amp;#34;Wigan Athletic&amp;#34;] | +-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ 5 rows START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[h:home_team|away_team]-game-[:on_day]-day WITH day.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Getting the hang of the WITH statement</title>
      <link>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</link>
      <pubDate>Wed, 20 Mar 2013 00:25:00 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/20/neo4jcypher-getting-the-hang-of-the-with-statement/</guid>
      <description>START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player, game-[:on_day]-day RETURN day.name, game.name +---------------------------------------------------+ | day.name | game.name | +---------------------------------------------------+ | &amp;#34;Saturday&amp;#34; | &amp;#34;Liverpool vs Southampton&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;Southampton vs Liverpool&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;Liverpool vs Reading&amp;#34; | | &amp;#34;Saturday&amp;#34; | &amp;#34;West Bromwich Albion vs Liverpool&amp;#34; | ... +---------------------------------------------------+ 29 rows START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player, game-[:on_day]-day RETURN day.name, COUNT(game.name) +--------------------------------+ | day.name | COUNT(game.name) | +--------------------------------+ | &amp;#34;Sunday&amp;#34; | 13 | | &amp;#34;Wednesday&amp;#34; | 4 | | &amp;#34;Monday&amp;#34; | 1 | | &amp;#34;Saturday&amp;#34; | 11 | +--------------------------------+ 4 rows START player = node:players(&#39;name:&amp;quot;Luis Suárez&amp;quot;&#39;) MATCH game-[:in]-stats-[:played]-player-[r?</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY WITH LIMIT query</title>
      <link>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</link>
      <pubDate>Mon, 18 Mar 2013 23:19:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/18/neo4jcypher-sql-style-group-by-with-limit-query/</guid>
      <description>START team = node:teams(&#39;name:&amp;quot;Manchester United&amp;quot;&#39;) MATCH team-[:home_team|away_team]-game-[:scored_in]-player-[:played]-stats-[:for]-team, stats-[:in]-game RETURN DISTINCT player.name, stats.goals, game.name +--------------------------------------------------------------------------------+ | player.name | stats.goals | game.name | +--------------------------------------------------------------------------------+ | &amp;#34;Javier Hernández&amp;#34; | 1 | &amp;#34;Manchester United vs Wigan Athletic&amp;#34; | | &amp;#34;Robin Van Persie&amp;#34; | 1 | &amp;#34;Manchester United vs Sunderland&amp;#34; | | &amp;#34;Danny Welbeck&amp;#34; | 1 | &amp;#34;Manchester United vs Stoke City&amp;#34; | | &amp;#34;Rafael&amp;#34; | 1 | &amp;#34;Queens Park Rangers vs Manchester United&amp;#34; | | &amp;#34;Wayne Rooney&amp;#34; | 1 | &amp;#34;Manchester United vs Norwich City&amp;#34; | | &amp;#34;Shinji Kagawa&amp;#34; | 1 | &amp;#34;Manchester United vs Fulham&amp;#34; | | &amp;#34;Shinji Kagawa&amp;#34; | 3 | &amp;#34;Manchester United vs Norwich City&amp;#34; | .</description>
    </item>
    
    <item>
      <title>clojure/Java Interop - Importing neo4j spatial data</title>
      <link>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-importing-neo4j-spatial-data/</link>
      <pubDate>Sun, 17 Mar 2013 18:56:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/17/clojurejava-interop-importing-neo4j-spatial-data/</guid>
      <description>package main.java; // imports excluded  public class StadiumsImport { public static void main(String[] args) throws IOException { List&amp;lt;String&amp;gt; lines = readFile(&amp;#34;data/stadiums.csv&amp;#34;); EmbeddedGraphDatabase db = new EmbeddedGraphDatabase(&amp;#34;neo4j-community-1.9.M04/data/graph.db&amp;#34;); Index&amp;lt;Node&amp;gt; stadiumsIndex = createSpatialIndex(db, &amp;#34;stadiumsLocation&amp;#34;); Transaction tx = db.beginTx(); for (String stadium : lines) { String[] columns = stadium.split(&amp;#34;,&amp;#34;); Index&amp;lt;Node&amp;gt; teamsIndex = db.index().forNodes(&amp;#34;teams&amp;#34;); String team = columns[1].replaceAll(&amp;#34;\&amp;#34;&amp;#34;,&amp;#34;&amp;#34;); Node teamNode = teamsIndex.get(&amp;#34;name&amp;#34;, team).getSingle(); if(teamNode != null) { Node stadiumNode = db.createNode(); stadiumNode.setProperty(&amp;#34;wkt&amp;#34;, String.format(&amp;#34;POINT(%s %s)&amp;#34;, columns[4], columns[3])); stadiumNode.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Finding football stadiums near a city using spatial</title>
      <link>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</link>
      <pubDate>Sun, 10 Mar 2013 22:13:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/10/neo4jcypher-finding-football-stadiums-near-a-city-using-spatial/</guid>
      <description>$ git clone git://github.com/neo4j/spatial.git spatial $ cd spatial $ mvn clean package -Dmaven.test.skip=true install $ unzip target/neo4j-spatial-0.11-SNAPSHOT-server-plugin.zip -d /path/to/neo4j-community-1.9.M04/plugins/ $ /path/to/neo4j-community-1.9.M04/bin/neo4j restart $ curl -L http://localhost:7474/db/data { &amp;#34;extensions&amp;#34; : { ... &amp;#34;SpatialPlugin&amp;#34; : { &amp;#34;addEditableLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addEditableLayer&amp;#34;, &amp;#34;addCQLDynamicLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addCQLDynamicLayer&amp;#34;, &amp;#34;findGeometriesWithinDistance&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/findGeometriesWithinDistance&amp;#34;, &amp;#34;updateGeometryFromWKT&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/updateGeometryFromWKT&amp;#34;, &amp;#34;addGeometryWKTToLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addGeometryWKTToLayer&amp;#34;, &amp;#34;getLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/getLayer&amp;#34;, &amp;#34;addSimplePointLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addSimplePointLayer&amp;#34;, &amp;#34;findGeometriesInBBox&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/findGeometriesInBBox&amp;#34;, &amp;#34;addNodeToLayer&amp;#34; : &amp;#34;http://localhost:7474/db/data/ext/SpatialPlugin/graphdb/addNodeToLayer&amp;#34; }, … }, ... &amp;#34;neo4j_version&amp;#34; : &amp;#34;1.9.M04&amp;#34; Name,Team,Capacity,Latitude,Longitude &amp;#34;Adams Park&amp;#34;,&amp;#34;Wycombe Wanderers&amp;#34;,10284,51.</description>
    </item>
    
    <item>
      <title>neo4j: Make properties relationships</title>
      <link>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</link>
      <pubDate>Wed, 06 Mar 2013 00:59:36 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/03/06/neo4j-make-properties-relationships/</guid>
      <description>MATCH-[:in_month]-&amp;gt;MONTH START player = node:players(&#39;name:&amp;quot;Gareth Bale&amp;quot;&#39;), month=node:months(&#39;name:September&#39;) MATCH player-[:played_in]-game WHERE game-[:in_month]-month RETURN game.name, game.home_goals + &amp;quot;-&amp;quot; +game.away_goals AS score, game.date +----------------------------------------------------------------------------------+ | game.name | score | game.date | +----------------------------------------------------------------------------------+ | &amp;#34;Reading vs Tottenham Hotspur&amp;#34; | &amp;#34;1-3&amp;#34; | &amp;#34;2012-09-16 16:00:00 +0100&amp;#34; | | &amp;#34;Tottenham Hotspur vs Norwich City&amp;#34; | &amp;#34;1-1&amp;#34; | &amp;#34;2012-09-01 15:00:00 +0100&amp;#34; | | &amp;#34;Tottenham Hotspur vs Queens Park Rangers&amp;#34; | &amp;#34;2-1&amp;#34; | &amp;#34;2012-09-23 16:00:00 +0100&amp;#34; | | &amp;#34;Manchester United vs Tottenham Hotspur&amp;#34; | &amp;#34;2-3&amp;#34; | &amp;#34;2012-09-29 17:30:00 +0100&amp;#34; | +----------------------------------------------------------------------------------+ START month=node:months(&#39;name:December&#39;) MATCH month-[:in_month]-game WHERE ABS(game.</description>
    </item>
    
    <item>
      <title>neo4j: Loading data - REST API vs Batch Import</title>
      <link>https://markhneedham.com/blog/2013/02/28/neo4j-loading-data-rest-api-vs-batch-import/</link>
      <pubDate>Thu, 28 Feb 2013 23:36:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/28/neo4j-loading-data-rest-api-vs-batch-import/</guid>
      <description>-------------------------------------------------------------------- | Matches | Cache-Hits | Cache-Misses | Lucene | In memory | -------------------------------------------------------------------- | 25 | 501 | 325 | 26.692s | 22.877s | | 50 | 1275 | 373 | 50.491s | 38.304s | | 263 | 8016 | 480 | 4m 11.031s | 2m 49.951s | -------------------------------------------------------------------- ------------------------------------------------------------------- | Matches | Lucene | In memory | Batch Import | ------------------------------------------------------------------- | 25 | 26.692s | 22.877s | 0.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Combining COUNT and COLLECT in one query</title>
      <link>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</link>
      <pubDate>Sun, 24 Feb 2013 19:19:59 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/24/neo4jcypher-combining-count-and-collect-in-one-query/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:missed_penalty_in]-game, player-[:played|subbed_on]-stats-[:in]-game, stats-[:for]-team, game-[:home_team]-home, game-[:away_team]-away RETURN player.name, team.name, home.name, away.name +-------------------------------------------------------------------------------------------------+ | player.name | team.name | home.name | away.name | +-------------------------------------------------------------------------------------------------+ | &amp;#34;Papiss Demba Cisse&amp;#34; | &amp;#34;Newcastle United&amp;#34; | &amp;#34;Newcastle United&amp;#34; | &amp;#34;Norwich City&amp;#34; | | &amp;#34;Wayne Rooney&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Arsenal&amp;#34; | | &amp;#34;Mikel Arteta&amp;#34; | &amp;#34;Arsenal&amp;#34; | &amp;#34;Arsenal&amp;#34; | &amp;#34;Fulham&amp;#34; | | &amp;#34;David Silva&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Southampton&amp;#34; | | &amp;#34;Frank Lampard&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Manchester City&amp;#34; | &amp;#34;Chelsea&amp;#34; | | &amp;#34;Adel Taarabt&amp;#34; | &amp;#34;Queens Park Rangers&amp;#34; | &amp;#34;Queens Park Rangers&amp;#34; | &amp;#34;Norwich City&amp;#34; | | &amp;#34;Javier Hernández&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Wigan Athletic&amp;#34; | | &amp;#34;Robin Van Persie&amp;#34; | &amp;#34;Manchester United&amp;#34; | &amp;#34;Southampton&amp;#34; | &amp;#34;Manchester United&amp;#34; | | &amp;#34;Jonathan Walters&amp;#34; | &amp;#34;Stoke City&amp;#34; | &amp;#34;Fulham&amp;#34; | &amp;#34;Stoke City&amp;#34; | | &amp;#34;Shane Long&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | &amp;#34;Liverpool&amp;#34; | | &amp;#34;Steven Gerrard&amp;#34; | &amp;#34;Liverpool&amp;#34; | &amp;#34;Liverpool&amp;#34; | &amp;#34;West Bromwich Albion&amp;#34; | | &amp;#34;Lucas Piazon&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Chelsea&amp;#34; | &amp;#34;Aston Villa&amp;#34; | +-------------------------------------------------------------------------------------------------+ 12 rows START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:missed_penalty_in]-game, player-[:played|subbed_on]-stats-[:in]-game, stats-[:for]-team RETURN DISTINCT team.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: Using a WHERE clause to filter paths</title>
      <link>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</link>
      <pubDate>Tue, 19 Feb 2013 00:03:18 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/19/neo4jcypher-using-a-where-clause-to-filter-paths/</guid>
      <description>START team = node:teams(&amp;#39;name:&amp;#34;Arsenal&amp;#34;&amp;#39;) MATCH team-[:home_team|away_team]-game-[:played_in]-player RETURN player.name, COUNT(player.name) as games ORDER BY games desc ------------------------------+ | player.name | games | +------------------------------+ | &amp;#34;Cazorla&amp;#34; | 25 | | &amp;#34;Arteta&amp;#34; | 22 | | &amp;#34;Mertesacker&amp;#34; | 22 | | &amp;#34;Vermaelen&amp;#34; | 22 | | &amp;#34;Podolski&amp;#34; | 21 | | &amp;#34;Gibbs&amp;#34; | 18 | | &amp;#34;Szczesny&amp;#34; | 17 | … | &amp;#34;Tiote&amp;#34; | 1 | | &amp;#34;Diame&amp;#34; | 1 | | &amp;#34;Ridgewell&amp;#34; | 1 | | &amp;#34;Lampard&amp;#34; | 1 | | &amp;#34;Bramble&amp;#34; | 1 | | &amp;#34;Simpson&amp;#34; | 1 | +------------------------------+ 258 rows START team = node:teams(&amp;#39;name:&amp;#34;Arsenal&amp;#34;&amp;#39;) MATCH team-[:home_team|away_team]-game-[:played_in]-player, player-[:played]-()-[:for]-team RETURN player.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: SQL style GROUP BY functionality</title>
      <link>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</link>
      <pubDate>Sun, 17 Feb 2013 21:05:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/17/neo4jcypher-sql-style-group-by-functionality/</guid>
      <description>START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month RETURN player.name, month.name +----------------------------+ | player.name | month.name | +----------------------------+ | &amp;#34;Jenkinson&amp;#34; | &amp;#34;February&amp;#34; | | &amp;#34;Chico&amp;#34; | &amp;#34;September&amp;#34; | | &amp;#34;Odemwingie&amp;#34; | &amp;#34;September&amp;#34; | | &amp;#34;Agger&amp;#34; | &amp;#34;August&amp;#34; | | &amp;#34;Cole&amp;#34; | &amp;#34;December&amp;#34; | | &amp;#34;Whitehead&amp;#34; | &amp;#34;August&amp;#34; | ... +----------------------------+ START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month RETURN COUNT(player.name) AS numberOfReds, month.name ORDER BY numberOfReds DESC +----------------------------+ | numberOfReds | month.name | +----------------------------+ | 7 | &amp;#34;October&amp;#34; | | 6 | &amp;#34;December&amp;#34; | | 4 | &amp;#34;September&amp;#34; | | 4 | &amp;#34;November&amp;#34; | | 3 | &amp;#34;August&amp;#34; | | 2 | &amp;#34;January&amp;#34; | | 2 | &amp;#34;February&amp;#34; | +----------------------------+ START player = node:players(&amp;#39;name:*&amp;#39;) MATCH player-[:sent_off_in]-game-[:in_month]-month, game-[:in_match]-stats-[:stats]-player, stats-[:played_for]-team RETURN player.</description>
    </item>
    
    <item>
      <title>neo4j: Handling SUM&#39;s scientific notation</title>
      <link>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</link>
      <pubDate>Sun, 30 Sep 2012 19:47:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/30/neo4j-handling-sums-scientific-notation/</guid>
      <description>In some of the recent work I&amp;rsquo;ve been doing with neo4j the queries I&amp;rsquo;ve written have been summing up the values from multiple nodes and after a certain number is reached the value returned used scientific notation.
For example in a cypher query like this:
START category = node:categories(&amp;#39;category_id:1&amp;#39;) MATCH p = category-[:has_child*1..5]-&amp;gt;subCategory-[:has_product]-&amp;gt;product-[:sold]-&amp;gt;sales RETURN EXTRACT(n in NODES(p) : n.category_id?),subCategory.category_id, SUM(sales.sales) I might get a result set like this:
+------------------------------------------------------------------------------------------------+ | EXTRACT(n in NODES(p) : n.</description>
    </item>
    
    <item>
      <title>neo4j: The Batch Inserter and the sunk cost fallacy</title>
      <link>https://markhneedham.com/blog/2012/09/23/neo4j-the-batch-inserter-and-the-sunk-cost-fallacy/</link>
      <pubDate>Sun, 23 Sep 2012 10:29:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/23/neo4j-the-batch-inserter-and-the-sunk-cost-fallacy/</guid>
      <description>About a year and a half ago I wrote about the sunk cost fallacywhich is defined like so:
The Truth: Your decisions are tainted by the emotional investments you accumulate, and the more you invest in something the harder it becomes to abandon it.
Over the past few weeks Ashokand I have been doing some exploration of one of our client&amp;rsquo;s data by modelling it in a neo4j graph and seeing what interesting things the traversals reveal.</description>
    </item>
    
    <item>
      <title>neo4j/cypher: CREATE UNIQUE - &#34;SyntaxException: string matching regex `$&#39; expected but `p&#39; found&#34;</title>
      <link>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</link>
      <pubDate>Sun, 09 Sep 2012 22:29:33 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/09/09/neo4jcypher-create-unique-syntaxexception-string-matching-regex-expected-but-p-found/</guid>
      <description>I&amp;rsquo;ve been playing around with the mutating cypher syntax of neo4j which allows you to make changes to the graph as well as query it, a feature introduced into cypher in May in release 1.8 M01.
I was trying to make use of the &amp;lsquo;CREATE UNIQUE&amp;rsquo; syntax which allows you to create nodes/relationships if they&amp;rsquo;re missing but won&amp;rsquo;t do anything if they already exists.
I had something like the following:</description>
    </item>
    
    <item>
      <title>neo4j: Creating a custom index with neo4j.rb</title>
      <link>https://markhneedham.com/blog/2012/08/05/neo4j-creating-a-custom-index-with-neo4j-rb/</link>
      <pubDate>Sun, 05 Aug 2012 09:45:08 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/08/05/neo4j-creating-a-custom-index-with-neo4j-rb/</guid>
      <description>As I mentioned in my last postI&amp;rsquo;ve been playing around with the TFL Bus stop location and routes APIand one thing I wanted to do was load all the bus stops into a neo4j database using the neo4j.rbgem.
I initially populated the database via neographybut it was taking around 20 minutes each run and I figured it&amp;rsquo;d probably be much quicker to populate it directly rather than using the REST API.</description>
    </item>
    
    <item>
      <title>neo4j: Multiple starting nodes by index lookup</title>
      <link>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</link>
      <pubDate>Sat, 28 Jul 2012 23:32:28 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/28/neo4j-multiple-starting-nodes-by-index-lookup/</guid>
      <description>I spent a bit of time this evening extracting some data from the ThoughtWorks graph for our marketing team who were interested in anything related to our three European offices in London, Manchester and Hamburg.
The most interesting things we can explore relate to the relationship between people and the offices.
The model around people and offices looks like this:
I added a &amp;lsquo;current_home_office&amp;rsquo; relationship to make it easier to quickly get to the nodes of people who are currently working in a specific office.</description>
    </item>
    
    <item>
      <title>neo4j: Graph Global vs Graph Local queries</title>
      <link>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</link>
      <pubDate>Mon, 23 Jul 2012 22:23:10 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/23/neo4j-graph-global-vs-graph-local-queries/</guid>
      <description>A few weeks ago I did a presentation at the ThoughtWorks EU away day on the graph I&amp;rsquo;ve been developing using neo4j and I wanted to show who the most connected people in each of our European offices were.
I started with the following cypher query:
START n = node(*) MATCH n-[r:colleagues*1..2]-&amp;gt;c, n-[r2:member_of]-&amp;gt;office WHERE n.type? = &amp;#39;person&amp;#39; AND (NOT(HAS(r2.end_date))) AND office.name = &amp;#39;London - UK South&amp;#39; AND (NOT(HAS(c.thoughtquitter))) RETURN n.name, count(distinct(c)) AS connections, office.</description>
    </item>
    
    <item>
      <title>neo4j: Embracing the sub graph</title>
      <link>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</link>
      <pubDate>Sat, 21 Jul 2012 22:46:06 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/21/neo4j-embracing-the-sub-graph/</guid>
      <description>In May I wrote a blog post explaining how I&amp;rsquo;d been designing a neo4j graph by thinking about what questions I wanted to answer about the data.
In the comments Josh Adell gave me the following advice:
Keep your data model rich! Don&amp;rsquo;t be afraid to have as many relationships as you need. The power of graph databases comes from finding surprising results when you have strongly interconnected data.
At the time I didn&amp;rsquo;t really understand the advice but I&amp;rsquo;ve since updated my graph so that it includes &amp;lsquo;colleagues&amp;rsquo; relationships which can be derived by looking at the projects that people had worked together on.</description>
    </item>
    
    <item>
      <title>neo4j: Shortest Path with and without cypher</title>
      <link>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</link>
      <pubDate>Thu, 19 Jul 2012 19:57:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/19/neo4j-shortest-path-with-and-without-cypher/</guid>
      <description>I was looking back at some code I wrote a few months ago to query a neo4j database to find the shortest path between two people via the colleagues relationships that exist.
The initial code, written using neography, looked like this:
neo = Neography::Rest.new start_node = neo.get_node(start_node_id) destination_node = neo.get_node(destination_node_id) neo.get_paths(start_node, destination_node, { &amp;#34;type&amp;#34; =&amp;gt; &amp;#34;colleagues&amp;#34; }, depth = 3, algorithm = &amp;#34;shortestPath&amp;#34;) The neography code eventually makes a POST request to /node/{start_id}/pathsand provides a JSON payload containing the other information about the query.</description>
    </item>
    
    <item>
      <title>neo4j: java.security.NoSuchAlgorithmException: Algorithm [JKS] of type [KeyStore] from provider [org.bouncycastle.jce.provider.BouncyCastleProvider: name=BC version=1.4]</title>
      <link>https://markhneedham.com/blog/2012/07/17/neo4j-java-security-nosuchalgorithmexception-algorithm-jks-of-type-keystore-from-provider-org-bouncycastle-jce-provider-bouncycastleprovider-namebc-version1-4/</link>
      <pubDate>Tue, 17 Jul 2012 00:02:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/07/17/neo4j-java-security-nosuchalgorithmexception-algorithm-jks-of-type-keystore-from-provider-org-bouncycastle-jce-provider-bouncycastleprovider-namebc-version1-4/</guid>
      <description>I&amp;rsquo;ve spent the last couple of hours moving my neo4j graph from my own machine onto a vanilla CentOS VM and initially tried to run neo using a non Sun version of Java which I installed like so:
yum install java This is the version of Java that was installed:
$ java -version java version &amp;#34;1.5.0&amp;#34; gij (GNU libgcj) version 4.4.6 20120305 (Red Hat 4.4.6-4) When I tried to start neo4j:</description>
    </item>
    
    <item>
      <title>neo4j: Handling optional relationships</title>
      <link>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</link>
      <pubDate>Sun, 24 Jun 2012 23:32:17 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/24/neo4j-handling-optional-relationships/</guid>
      <description>On my ThoughtWorks neo4j there are now two different types of relationships between people nodes - they can either be colleagues or one can be the sponsor of the other.
The graph looks like this:
I wanted to get a list of all the sponsor pairs but also have some indicator of whether the two people have worked together.
I started off by getting all of the sponsor pairs:
START n = node(*) MATCH n-[r:sponsor_of]-&amp;gt;n2 RETURN n.</description>
    </item>
    
    <item>
      <title>Visualising a neo4j graph using gephi</title>
      <link>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</link>
      <pubDate>Thu, 21 Jun 2012 05:02:32 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/21/visualising-a-neo4j-graph-using-gephi/</guid>
      <description>At ThoughtWorks we don&amp;rsquo;t have line managers but people can choose to have a sponsor - typically someone who has worked in the company for longer/has more experience in the industry than them - who can help them navigate the organisation better.
From hearing people talk about sponsors over the last 6 years it seemed like quite a few people sponsored the majority and there were probably a few people who didn&amp;rsquo;t have a sponsor.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the most connected node on the graph</title>
      <link>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</link>
      <pubDate>Sat, 16 Jun 2012 10:41:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/06/16/neo4jcypher-finding-the-most-connected-node-on-the-graph/</guid>
      <description>As I mentioned in another post about a month agoI&amp;rsquo;ve been playing around with a neo4j graph in which I have the following relationship between nodes:
One thing I wanted to do was work out which node is the most connected on the graph, which would tell me who&amp;rsquo;s worked with the most people.
I started off with the following cypher query:
query = &amp;#34; START n = node(*)&amp;#34; query &amp;lt;&amp;lt; &amp;#34; MATCH n-[r:colleagues]-&amp;gt;c&amp;#34; query &amp;lt;&amp;lt; &amp;#34; WHERE n.</description>
    </item>
    
    <item>
      <title>neo4j/Cypher: Finding the shortest path between two nodes while applying predicates</title>
      <link>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</link>
      <pubDate>Sat, 12 May 2012 14:55:30 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/12/neo4jcypher-finding-the-shortest-path-between-two-nodes-while-applying-predicates/</guid>
      <description>As I mentioned in a blog post about a week agoI decided to restructure the ThoughtWorks graph I&amp;rsquo;ve modelled in neo4j so that I could explicitly model projects and clients.
As a result I had to update a traversal I&amp;rsquo;d written for finding the shortest path between two people in the graph.
The original traversal query I had was really simple because I had a direct connection between the people nodes:</description>
    </item>
    
    <item>
      <title>neo4j: What question do you want to answer?</title>
      <link>https://markhneedham.com/blog/2012/05/05/neo4j-what-question-do-you-want-to-answer/</link>
      <pubDate>Sat, 05 May 2012 13:20:41 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/05/05/neo4j-what-question-do-you-want-to-answer/</guid>
      <description>Over the past few weeks I&amp;rsquo;ve been modelling ThoughtWorks project data in neo4jand I realised that the way that I&amp;rsquo;ve been doing this is by considering what question I want to answerand then building a graph to answer it.
When I first started doing this the main question I wanted to answer was &amp;lsquo;how connected are people to each other&amp;rsquo; which led to me modelling the data like this:
The &amp;lsquo;colleagues with&amp;rsquo; relationship stored information about the project the two people had worked on together and how long they&amp;rsquo;d worked together.</description>
    </item>
    
    <item>
      <title>gephi: Centring a graph around an individual node</title>
      <link>https://markhneedham.com/blog/2012/04/30/gephi-centring-a-graph-around-an-individual-node/</link>
      <pubDate>Mon, 30 Apr 2012 22:20:45 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/30/gephi-centring-a-graph-around-an-individual-node/</guid>
      <description>I spent some time recently playing around with gephi- an open source platform for creating visualisations of graphs - to get a bit more insight into the ThoughtWorks graph which I&amp;rsquo;ve created in neo4j.
I followed Max De Marxi&amp;rsquo;s blog postto create a GEFX (Graph Exchange XML Format) file to use in gephi although I later learned that you can import directly from neo4j into gephi which I haven&amp;rsquo;t tried yet.</description>
    </item>
    
    <item>
      <title>neo4J: Searching for nodes by name</title>
      <link>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</link>
      <pubDate>Fri, 20 Apr 2012 07:10:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/20/neo4j-searching-for-nodes-by-name/</guid>
      <description>As I mentioned in a post a few days ago I&amp;rsquo;ve been graphing connections between ThoughtWorks people using neo4j and wanted to build auto complete functionality so I can search for the names of people in the graph.
The solution I came up was to create a Lucene index with an entry for each node and a common property on each document in the index so that I&amp;rsquo;d be able to get all the index entries easily.</description>
    </item>
    
    <item>
      <title>Ruby: neo4j gem - LoadError: no such file to load -- active_support/core_ext/class/inheritable_attributes</title>
      <link>https://markhneedham.com/blog/2012/04/14/ruby-neo4j-gem-loaderror-no-such-file-to-load-active_supportcore_extclassinheritable_attributes/</link>
      <pubDate>Sat, 14 Apr 2012 10:21:40 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/04/14/ruby-neo4j-gem-loaderror-no-such-file-to-load-active_supportcore_extclassinheritable_attributes/</guid>
      <description>I&amp;rsquo;ve been playing around with neo4j again over the past couple of days using the neo4j.rbgem to build up a graph.
I installed the gem but then ended up with the following error when I tried to &amp;lsquo;require neo4j&amp;rsquo; in &amp;lsquo;irb&amp;rsquo;:
LoadError: no such file to load -- active_support/core_ext/class/inheritable_attributes require at org/jruby/RubyKernel.java:1033 require at /Users/mneedham/.rbenv/versions/jruby-1.6.7/lib/ruby/site_ruby/1.8/rubygems/custom_require.rb:36 (root) at /Users/mneedham/.rbenv/versions/jruby-1.6.7/lib/ruby/gems/1.8/gems/neo4j-1.3.1-java/lib/neo4j.rb:9 require at org/jruby/RubyKernel.java:1033 require at /Users/mneedham/.rbenv/versions/jruby-1.6.7/lib/ruby/gems/1.8/gems/neo4j-1.3.1-java/lib/neo4j.rb:59 (root) at src/main/ruby/neo_test.rb:2 It seems a few others have come across this problem as welland the problem seems to be that ActiveSupport 3.</description>
    </item>
    
  </channel>
</rss>