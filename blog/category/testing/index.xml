<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Testing on Mark Needham</title>
    <link>http://localhost:8000/blog/category/testing/</link>
    <description>Recent content in Testing on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 30 Sep 2012 15:48:10 +0000</lastBuildDate><atom:link href="http://localhost:8000/blog/category/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Testing XML generation with vimdiff</title>
      <link>http://localhost:8000/blog/2012/09/30/testing-xml-generation-with-vimdiff/</link>
      <pubDate>Sun, 30 Sep 2012 15:48:10 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2012/09/30/testing-xml-generation-with-vimdiff/</guid>
      <description>A couple of weeks ago I spent a bit of time writing a Ruby DSL to automate the setup of load balancers, firewall and NAT rules through the VCloud API.
The VCloud API deals primarily in XML so the DSL is just a thin layer which creates the appropriate mark up.
When we started out we configured everything manually through the web console and then exported the XML so the first thing that the DSL needed to do was create XML that matched what we already had.</description>
    </item>
    
    <item>
      <title>Testing: Trying not to overdo it</title>
      <link>http://localhost:8000/blog/2012/03/28/testing-trying-not-to-overdo-it/</link>
      <pubDate>Wed, 28 Mar 2012 00:10:46 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2012/03/28/testing-trying-not-to-overdo-it/</guid>
      <description>The design of the code which contains the main logic of the application that I’m currently working on looks a bit like the diagram on the right hand side:
We load a bunch of stuff from an Oracle database, construct some objects from the data and then invoke a sequence of methods on those objects in order to execute our domain logic.
Typically we might expect to see unit level test against all the classes described in this diagram but we’ve actually been trying out an approach where we don’t test the orchestration code directly but rather only test it via the resource which makes use of it.</description>
    </item>
    
    <item>
      <title>Kent Beck&#39;s Test Driven Development Screencasts</title>
      <link>http://localhost:8000/blog/2010/07/28/kent-becks-test-driven-development-screencasts/</link>
      <pubDate>Wed, 28 Jul 2010 10:44:05 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/28/kent-becks-test-driven-development-screencasts/</guid>
      <description>Following the recommendations of Corey Haines, Michael Guterl, James Martin and Michael Hunger I decided to get Kent Beck’s screencasts on Test Driven Development which have been published by the Pragmatic Programmers.
I read Kent’s &amp;#39;Test Driven Development By Example&amp;#39; book a couple of years ago and remember enjoying that so I was intrigued as to what it would be like to see some of those ideas put into practice in real time.</description>
    </item>
    
    <item>
      <title>TDD: Call your shots</title>
      <link>http://localhost:8000/blog/2010/07/28/tdd-call-your-shots/</link>
      <pubDate>Wed, 28 Jul 2010 07:39:03 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/28/tdd-call-your-shots/</guid>
      <description>One of the other neat ideas I was reminded of when watching Kent Beck’s TDD screencasts is the value of &amp;#39;calling your shots&amp;#39; i.e. writing a test and then saying what’s going to happen when you run that test.
It reminds me of an exercise we used to do in tennis training when I was younger.
The coach would feed the ball to you and just before you hit it you had to say exactly where on the court you were going to place it - cross court/down the line and short/deep.</description>
    </item>
    
    <item>
      <title>TDD: Testing collections</title>
      <link>http://localhost:8000/blog/2010/07/28/tdd-testing-collections/</link>
      <pubDate>Wed, 28 Jul 2010 06:05:25 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/28/tdd-testing-collections/</guid>
      <description>I’ve been watching Kent Beck’s TDD screencasts and in the 3rd episode he reminded me of a mistake I used to make when I was first learning how to test drive code.
The mistake happens when testing collections and I would write a test which would pass even if the collection had nothing in it.
The code would look something like this:
[Test] public void SomeTestOfACollection() { var someObject = new Object(); var aCollection = someObject.</description>
    </item>
    
    <item>
      <title>TDD, small steps and no need for comments</title>
      <link>http://localhost:8000/blog/2010/07/23/tdd-small-steps-and-no-need-for-comments/</link>
      <pubDate>Fri, 23 Jul 2010 02:52:03 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/23/tdd-small-steps-and-no-need-for-comments/</guid>
      <description>I recently came a blog post written by Matt Ward describing some habits to make you a better coder and while he presented a lot of good ideas I found myself disagreeing with his 2nd tip:
Write Your Logic through Comments When it comes to coding, there are many tenets and ideas I stand by. One of this is that code is 95% logic. Another is that logic doesn&amp;#39;t change when translated from human language into a programming language.</description>
    </item>
    
    <item>
      <title>TDD: I hate deleting unit tests</title>
      <link>http://localhost:8000/blog/2010/07/15/tdd-i-hate-deleting-unit-tests/</link>
      <pubDate>Thu, 15 Jul 2010 23:15:54 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/15/tdd-i-hate-deleting-unit-tests/</guid>
      <description>Following on from my post about the value we found in acceptance tests on our project when doing a large scale refactoring I had an interesting discussion with Jak Charlton and Ben Hall about deleting unit tests when they’re no longer needed.
The following is part of our discussion:
Ben:
@JakCharlton @markhneedham a lot (not all) of the unit tests created can be deleted once the acceptance tests are passing.</description>
    </item>
    
    <item>
      <title>A new found respect for acceptance tests</title>
      <link>http://localhost:8000/blog/2010/07/11/a-new-found-respect-for-acceptance-tests/</link>
      <pubDate>Sun, 11 Jul 2010 17:08:39 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/07/11/a-new-found-respect-for-acceptance-tests/</guid>
      <description>On the project that I’ve been working on over the past few months one of the key benefits of the application was its ability to perform various calculations based on user input.
In order to check that these calculators are producing the correct outputs we created a series of acceptance tests that ran directly against one of the objects in the system.
We did this by defining the inputs and expected outputs for each scenario in an excel spreadsheet which we converted into a CSV file before reading that into an NUnit test.</description>
    </item>
    
    <item>
      <title>TDD: Driving from the assertion up</title>
      <link>http://localhost:8000/blog/2010/06/14/tdd-driving-from-the-assertion-up/</link>
      <pubDate>Mon, 14 Jun 2010 22:46:00 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/06/14/tdd-driving-from-the-assertion-up/</guid>
      <description>About a year ago I wrote a post about a book club we ran in Sydney covering &amp;#39;The readability of tests&amp;#39; from Steve Freeman and Nat Pryce’s book in which they suggest that their preferred way of writing tests is to drive them from the assertion up:
Write Tests Backwards Although we stick to a canonical format for test code, we don’t necessarily write tests from top to bottom. What we often do is: write the test name, which helps us decide what we want to achieve; write the call to the target code, which is the entry point for the feature; write the expectations and assertions, so we know what effects the feature should have; and, write the setup and teardown to define the context for the test.</description>
    </item>
    
    <item>
      <title>Selenium, Firefox and HTTPS pages</title>
      <link>http://localhost:8000/blog/2010/03/25/selenium-firefox-and-https-pages/</link>
      <pubDate>Thu, 25 Mar 2010 08:09:26 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/03/25/selenium-firefox-and-https-pages/</guid>
      <description>A fairly common scenario that we come across when building automated test suites using Selenium is the need to get past the security exception that Firefox pops up when you try to access a self signed HTTPS page.
Luckily there is quite a cool plugin for Firefox called &amp;#39;Remember Certificate Exception&amp;#39; which automatically clicks through the exception and allows the automated tests to keep running and not get stuck on the certificate exception page.</description>
    </item>
    
    <item>
      <title>TDD: Consistent test structure</title>
      <link>http://localhost:8000/blog/2010/03/24/tdd-consistent-test-structure/</link>
      <pubDate>Wed, 24 Mar 2010 06:53:55 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/03/24/tdd-consistent-test-structure/</guid>
      <description>While pairing with Damian we came across the fairly common situation where we’d written two different tests - one to handle the positive case and one the negative case.
While tidying up the tests after we’d got them passing we noticed that the test structure wasn’t exactly the same. The two tests looked a bit like this:
[Test] public void ShouldSetSomethingIfWeHaveAFoo() { var aFoo = FooBuilder.Build.WithBar(&amp;#34;bar&amp;#34;).WithBaz(&amp;#34;baz&amp;#34;).AFoo(); // some random setup // some stubs/expectations var result = new Controller(.</description>
    </item>
    
    <item>
      <title>TDD: Expressive test names</title>
      <link>http://localhost:8000/blog/2010/03/19/tdd-expressive-test-names/</link>
      <pubDate>Fri, 19 Mar 2010 18:06:51 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/03/19/tdd-expressive-test-names/</guid>
      <description>Towards the end of a post I wrote just over a year ago I suggested that I wasn’t really bothered about test names anymore because I could learn what I wanted from reading the test body.
Recently, however, I’ve come across several tests that I wrote previously which were testing the wrong thing and had such generic test names that it wasn’t obvious that it was happening.
The tests in question were around code which partially clones an object but doesn’t copy some fields for various reasons.</description>
    </item>
    
    <item>
      <title>Preventing systematic errors: An example</title>
      <link>http://localhost:8000/blog/2010/03/13/preventing-systematic-errors-an-example/</link>
      <pubDate>Sat, 13 Mar 2010 23:26:23 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/03/13/preventing-systematic-errors-an-example/</guid>
      <description>James Shore has an interesting recent blog post where he describes some alternatives to over reliance on acceptance testing and one of the ideas that he describes is fixing the process whenever a bug is found in exploratory testing.
He describes two ways of preventing bugs from making it through to exploratory testing:
Make the bug impossible
Catch the bug automatically
Sometimes we can prevent defects by changing the design of our system so that type of defect is impossible.</description>
    </item>
    
    <item>
      <title>TDD: Rewriting/refactoring tests</title>
      <link>http://localhost:8000/blog/2010/01/25/tdd-rewritingrefactoring-tests/</link>
      <pubDate>Mon, 25 Jan 2010 22:06:23 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/25/tdd-rewritingrefactoring-tests/</guid>
      <description>I’ve read several times about the dangers of the big rewrite when it comes to production code but I’ve recently been wondering whether or not we should apply the same rules when it comes to test code or not.
I worked with Raphael Speyer for a few weeks last year and on the code base we were working on he often spent some time rewriting tests originally written using rMock to use mockito which was the framework we were driving towards.</description>
    </item>
    
    <item>
      <title>TDD: Simplifying a test with a hand rolled stub</title>
      <link>http://localhost:8000/blog/2010/01/25/tdd-simplifying-a-test-with-a-hand-rolled-stub/</link>
      <pubDate>Mon, 25 Jan 2010 21:23:31 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/25/tdd-simplifying-a-test-with-a-hand-rolled-stub/</guid>
      <description>I wrote a couple of weeks ago about my thoughts on hand written stubs vs framework generated stubs and I noticed an interesting situation where it helped me out while trying to simplify some test code.
The code in question was making use of several framework generated stubs/mocks and one in particular was trying to return different values depending on the value passed as a parameter.
The test was failing and I spent about half an hour unsuccessfully trying to work out why it wasn’t working as expected before I decided to replace it with a hand rolled stub that did exactly what I wanted.</description>
    </item>
    
    <item>
      <title>TDD: Removing the clutter</title>
      <link>http://localhost:8000/blog/2010/01/24/tdd-removing-the-clutter/</link>
      <pubDate>Sun, 24 Jan 2010 01:13:57 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/24/tdd-removing-the-clutter/</guid>
      <description>I got the chance to work with Phil for a couple of weeks last year and one of the most interesting things that he started teaching me was the importance of reducing the clutter in our tests and ensuring that we take some time to refactor them as well as the code as part of the &amp;#39;red-green-refactor&amp;#39; cycle.
I’m still trying to work out the best way to do this but I came across a really interesting post by J.</description>
    </item>
    
    <item>
      <title>TDD: Thoughts on using a clock in tests</title>
      <link>http://localhost:8000/blog/2010/01/15/tdd-thoughts-on-using-a-clock-in-tests/</link>
      <pubDate>Fri, 15 Jan 2010 21:56:48 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/15/tdd-thoughts-on-using-a-clock-in-tests/</guid>
      <description>A few months ago Uncle Bob wrote a post about TDD where he suggested that he preferred to use hand created stubs in his tests wherever possible and only resorted to using a Mockito created stub as a last resort.
I wrote previously about my thoughts of where to use each of the two approaches and one example of where hand written stubs seems to make sense is the clock.</description>
    </item>
    
    <item>
      <title>TDD: Hand written stubs vs Framework generated stubs</title>
      <link>http://localhost:8000/blog/2010/01/15/tdd-hand-written-stubs-vs-framework-generated-stubs/</link>
      <pubDate>Fri, 15 Jan 2010 21:44:36 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/15/tdd-hand-written-stubs-vs-framework-generated-stubs/</guid>
      <description>A few months ago Uncle Bob wrote a post about TDD where he suggested that he preferred to use hand created stubs in his tests wherever possible and only resorted to using a Mockito created stub as a last resort.
I’ve tended to use framework created ones but my colleague Matt Dunn and I noticed that it didn’t seem to work out too well for us writing some tests around a controller where the majority of our tests were making exactly the same call to that repository and expected to receive the same return value but a few select edge cases expected something different.</description>
    </item>
    
    <item>
      <title>TDD: Hungarian notation for mocks/stubs</title>
      <link>http://localhost:8000/blog/2010/01/06/tdd-hungarian-notation-for-mocksstubs/</link>
      <pubDate>Wed, 06 Jan 2010 00:08:14 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2010/01/06/tdd-hungarian-notation-for-mocksstubs/</guid>
      <description>A fairly common discussion that I’ve had with several of my colleagues is around the way that we name the variables used for mocks and stubs in our tests.
There seems to be about a 50/50 split between including &amp;#39;Stub&amp;#39; or &amp;#39;Mock&amp;#39; on the end of those variable names and not doing so.
In a simple example test using Rhino Mocks as the testing framework this would be the contrast between the two approaches:</description>
    </item>
    
    <item>
      <title>TDD: Only mock types you own</title>
      <link>http://localhost:8000/blog/2009/12/13/tdd-only-mock-types-you-own/</link>
      <pubDate>Sun, 13 Dec 2009 21:47:04 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/12/13/tdd-only-mock-types-you-own/</guid>
      <description>Liz recently posted about mock objects and the original &amp;#39;mock roles, not objects&amp;#39; paper and one thing that stood out for me is the idea that we should only mock types that we own.
I think this is quite an important guideline to follow otherwise we can end up in a world of pain.
One area which seems particularly vulnerable to this type of thing is when it comes to testing code which interacts with Hibernate.</description>
    </item>
    
    <item>
      <title>TDD: Big leaps and small steps</title>
      <link>http://localhost:8000/blog/2009/12/10/tdd-big-leaps-and-small-steps/</link>
      <pubDate>Thu, 10 Dec 2009 22:14:26 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/12/10/tdd-big-leaps-and-small-steps/</guid>
      <description>About a month ago or so Gary Bernhardt wrote a post showing how to get started with TDD and while the post is quite interesting, several comments on the post pointed out that he had jumped from iteratively solving the problem straight to the solution with his final step.
Something which I’ve noticed while solving algorithmic problems in couple of different functional programming languages is that the test driven approach doesn’t work so well for these types of problems.</description>
    </item>
    
    <item>
      <title>TDD: Testing delegation</title>
      <link>http://localhost:8000/blog/2009/11/27/tdd-testing-delegation/</link>
      <pubDate>Fri, 27 Nov 2009 14:43:45 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/11/27/tdd-testing-delegation/</guid>
      <description>I recently came across an interesting blog post by Rod Hilton on unit testing and it reminded me of a couple of conversations Phil, Raph and I were having about the best way to test classes which delegate some responsibility to another class.
An example that we ran into recently was where we wrote some code which required one controller to delegate to another.
public class ControllerOne extends Controller { public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception { } } public class ControllerTwo extends Controller { private final ControllerOne controllerOne; public ControllerTwo(ControllerOne controllerOne) { this.</description>
    </item>
    
    <item>
      <title>TDD: Combining the when and then steps</title>
      <link>http://localhost:8000/blog/2009/11/14/tdd-combining-the-when-and-then-steps/</link>
      <pubDate>Sat, 14 Nov 2009 00:17:57 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/11/14/tdd-combining-the-when-and-then-steps/</guid>
      <description>I’ve written before about my favoured approach of writing tests in such a way that they have clear &amp;#39;Given/When/Then&amp;#39; sections and something which I come across quite frequently is tests where the latter steps have been combined into one method call which takes care of both of these.
An example of this which I came across recently was roughly like this:
@Test public void shouldCalculatePercentageDifferences() { verifyPercentage(50, 100, 100); verifyPercentage(100, 100, 0); verifyPercentage(100, 50, -50); } private void verifyPercentage(int originalValue, int newValue, int expectedValue) { assertEquals(expectedValue, new PercentageCalculator().</description>
    </item>
    
    <item>
      <title>TDD: Useful when new on a project</title>
      <link>http://localhost:8000/blog/2009/11/06/tdd-useful-when-new-on-a-project/</link>
      <pubDate>Fri, 06 Nov 2009 21:57:10 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/11/06/tdd-useful-when-new-on-a-project/</guid>
      <description>Something which I’ve noticed over the last few projects that I’ve worked on is that at the beginning when I don’t know very much at all about the code base, domain and so on is that pairing with someone to TDD something seems to make it significantly easier for me to follow what’s going on than other approaches I’ve seen.
I thought that it was probably because I’m more used to that approach than any other but in Michael Feathers&amp;#39; description of TDD in &amp;#39;Working Effectively With Legacy Code&amp;#39; he points out the following:</description>
    </item>
    
    <item>
      <title>Testing End Points: Integration tests vs Contract tests</title>
      <link>http://localhost:8000/blog/2009/10/25/testing-integration-points-integration-tests-vs-contract-tests/</link>
      <pubDate>Sun, 25 Oct 2009 00:04:12 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/10/25/testing-integration-points-integration-tests-vs-contract-tests/</guid>
      <description>We recently changed the way that we test against our main integration point on the project I’ve been working on so that in our tests we retrieve the service object from our dependency injection container instead of &amp;#39;newing&amp;#39; one up.
Our tests therefore went from looking like this:
[Test] public void ShouldTestSomeService() { var someService = new SomeService(); // and so on } To something more like this:
[Test] public void ShouldTestSomeService() { var someService = UnityFactory.</description>
    </item>
    
    <item>
      <title>TDD: Keeping assertions clear</title>
      <link>http://localhost:8000/blog/2009/10/10/tdd-keeping-assertions-clear/</link>
      <pubDate>Sat, 10 Oct 2009 11:07:21 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/10/10/tdd-keeping-assertions-clear/</guid>
      <description>Something which I noticed was a problem with the first example test that I provided in my post about API readability and testability is that the assertion we are making is not that great.
[Test] public void ShouldConstructModelForSomeSituation() { Assert.AreEqual(DateTime.Today.ToDisplayFormat(), model.SomeDate()); } It’s not really obvious what the expected result is supposed to be except that it should be the &amp;#39;DisplayFormat&amp;#39;. If that fails then we’ll need to navigate to the &amp;#39;ToDisplayFormat&amp;#39; method to work out what that method does.</description>
    </item>
    
    <item>
      <title>TDD: It makes you question what you&#39;re doing</title>
      <link>http://localhost:8000/blog/2009/09/25/tdd-it-makes-you-question-what-youre-doing/</link>
      <pubDate>Fri, 25 Sep 2009 23:48:33 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/25/tdd-it-makes-you-question-what-youre-doing/</guid>
      <description>My colleague Matt Dunn and I have been putting a lot of tests around some code over the last few days so that we can safely make some changes around that area and having finally created our safety net we’ve moved onto adding in the new functionality.
We’re test driving the new bit of functionality whereas with the previous code only the code had been written with no unit tests and it’s been quite interesting seeing the contrast in the style of code which seems to come out from these differing styles.</description>
    </item>
    
    <item>
      <title>TDD: Copying and pasting tests</title>
      <link>http://localhost:8000/blog/2009/09/22/tdd-copying-and-pasting-tests/</link>
      <pubDate>Tue, 22 Sep 2009 23:39:56 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/22/tdd-copying-and-pasting-tests/</guid>
      <description>I’ve been re-reading a post my colleague Ian Cartwright wrote earlier this year about treating test code the same way as production code and one thing which stands out as something which I’m certainly guilty off is copying and pasting tests.
Ian lists the following problems with doing this:
The first one is cut &amp;amp; paste, for some reason when it comes to unit tests people suddenly start cutting and pasting all over the place.</description>
    </item>
    
    <item>
      <title>TDD: Tests that give us a false confidence of coverage</title>
      <link>http://localhost:8000/blog/2009/09/21/tdd-tests-that-give-us-a-false-confidence-of-coverage/</link>
      <pubDate>Mon, 21 Sep 2009 22:49:49 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/21/tdd-tests-that-give-us-a-false-confidence-of-coverage/</guid>
      <description>During J.B. Rainsberger’s presentation at Agile 2009 titled &amp;#39;Integration tests are a scam&amp;#39; he suggests that having lots of integrationt tests covering our code can give us a false sense of confidence that we are testing our code and I think the same can happen with unit tests as well if we’re not careful how we write them.
It’s important to ensure that our unit tests are actually testing something useful otherwise the cost of writing and maintaining them will outweigh the benefits that we derive from doing so.</description>
    </item>
    
    <item>
      <title>TDD: Keeping test intent when using test builders</title>
      <link>http://localhost:8000/blog/2009/09/20/tdd-keeping-test-intent-when-using-test-builders/</link>
      <pubDate>Sun, 20 Sep 2009 12:06:04 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/20/tdd-keeping-test-intent-when-using-test-builders/</guid>
      <description>While the test data builder pattern is quite a useful one for simplifying the creation of test data in our tests I think we need to be quite careful when using it that we don’t lose the intent of the test that we’re writing.
The main advantage that I see with this pattern is that by using it we can provide default values for properties of our objects which aren’t important for the bit of functionality that we’re currently testing but which need to be provided otherwise the test can’t actually be run.</description>
    </item>
    
    <item>
      <title>TDD: Testing with generic abstract classes</title>
      <link>http://localhost:8000/blog/2009/09/18/tdd-testing-with-generic-abstract-classes/</link>
      <pubDate>Fri, 18 Sep 2009 00:40:09 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/18/tdd-testing-with-generic-abstract-classes/</guid>
      <description>In a post I wrote earlier in the week I described a dilemma we were having testing some code which made use of abstract classes and Perryn Fowler, Liz Keogh and Pat Maddox pointed out that a useful approach for this problem would be to make use of an abstract test class.
The idea here is that we create an equivalent hierarchy to our production code for our tests which in the example that I provided would mean that we have roughly the following setup:</description>
    </item>
    
    <item>
      <title>TDD: Testing sub classes</title>
      <link>http://localhost:8000/blog/2009/09/13/tdd-testing-sub-classes/</link>
      <pubDate>Sun, 13 Sep 2009 22:21:22 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/13/tdd-testing-sub-classes/</guid>
      <description>We ran into another interesting testing dilemma while refactoring the view model code which I described in an earlier post to the point where we have an abstract class and three sub classes which means that we now have 3 classes which did the same thing 80% of the time.
As I mentioned in a post a couple of weeks ago one of the main refactorings that we did was to move some calls to dependency methods from the constructor and into properties so that those calls would only be made if necessary.</description>
    </item>
    
    <item>
      <title>TDD: Test only constructors</title>
      <link>http://localhost:8000/blog/2009/09/12/tdd-test-only-constructors/</link>
      <pubDate>Sat, 12 Sep 2009 00:35:12 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/12/tdd-test-only-constructors/</guid>
      <description>I wrote previously how we’d been doing some work to change the way that we get a &amp;#39;User&amp;#39; object into our system and one mistake that we made intially was to have another constructor on the &amp;#39;User&amp;#39; object which was being used in all our unit tests which involved the user in some way.
The original reason that this &amp;#39;test constructor&amp;#39; was created was to make it easier to construct a &amp;#39;fake user&amp;#39; which we were using in some of our functional tests but had ended up being used in unit tests as well.</description>
    </item>
    
    <item>
      <title>Impersonators: Using them in showcases</title>
      <link>http://localhost:8000/blog/2009/09/10/impersonators-using-them-in-showcases/</link>
      <pubDate>Thu, 10 Sep 2009 00:23:33 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/10/impersonators-using-them-in-showcases/</guid>
      <description>Towards the end of my colleague Julio Maia’s blog post about the impersonator pattern he suggests that the standalone environment that we can create through the use of impersonators can be quite useful for showcases and we actually had a recent occasion where we had to switch mid-showcase from using the integration environment to make use of an impersonator.
In this case part of the environment went down in the middle of the showcase so if we wanted to keep on going then that was our only option but in general the expectation of the business is that our showcases show them the functionality of the application end to end.</description>
    </item>
    
    <item>
      <title>TDD: Test the behaviour rather than implementation</title>
      <link>http://localhost:8000/blog/2009/09/02/tdd-test-the-behaviour-rather-than-implementation/</link>
      <pubDate>Wed, 02 Sep 2009 00:42:52 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/09/02/tdd-test-the-behaviour-rather-than-implementation/</guid>
      <description>I previously wrote about some duplicated code we’d taken the time to remove from our code base and one something else that we found when working with this code is that a lot of the tests around this code were testing the implementation/internal state of the object rather than testing the behaviour that they expected to see.
I find it makes more sense to test the behaviour since this is the way that the object will most likely be used in our production code.</description>
    </item>
    
    <item>
      <title>Rock Scissors Paper: TDD as if you meant it</title>
      <link>http://localhost:8000/blog/2009/08/24/rock-scissors-paper-tdd-as-if-you-meant-it/</link>
      <pubDate>Mon, 24 Aug 2009 22:11:26 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/08/24/rock-scissors-paper-tdd-as-if-you-meant-it/</guid>
      <description>I decided to spend a bit of time on Saturday having another go at writing Rock Scissors Paper while following Keith Braithwaite’s TDD as if you meant it exercise.
We previously did this exercise at a coding dojo but I wanted to see what happens when you code for a longer period of time with this exercise since we typically only code for maybe a couple of hours at a dojo.</description>
    </item>
    
    <item>
      <title>TDD: Asserting on test dependency code</title>
      <link>http://localhost:8000/blog/2009/08/19/tdd-asserting-on-test-dependency-code/</link>
      <pubDate>Wed, 19 Aug 2009 23:19:45 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/08/19/tdd-asserting-on-test-dependency-code/</guid>
      <description>Something I’ve noticed a bit lately is tests which setup a load of dependencies for a test and then do assertions on that setup before getting on to calling the system under test.
The code tends to be similar to this:
public void ShouldHopefullyDoSomeAwesomeStuff() { // setup via expectations for dependency1 and dependency2 Assert.IsNotNull(dependency1.DependedOnMethod); new SystemUnderTest(dependency1, dependency2).DoThatStuff(); // test assertions } I’ve done this a fair few times myself and I used to believe that it actually made the test more valuable since we were ensuring that the dependencies were in a good state before we executed the test.</description>
    </item>
    
    <item>
      <title>Impersonators: Finding the enabling point</title>
      <link>http://localhost:8000/blog/2009/08/19/impersonators-finding-the-enabling-point/</link>
      <pubDate>Wed, 19 Aug 2009 00:43:18 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/08/19/impersonators-finding-the-enabling-point/</guid>
      <description>One of the other interesting problems that we’ve come across while making use of different impersonators in our build process, and which Julio mentions at the end of his comment on Gil Zilberfeld’s blog post, is trying to work out where the correct place for the impersonator is.
Ideally we want to put the impersonator in a place where we can easily turn it on or off depending on whether we want to use the impersonator or the real end point.</description>
    </item>
    
    <item>
      <title>Impersonators: Why do we need them?</title>
      <link>http://localhost:8000/blog/2009/08/16/impersonators-why-do-we-need-them/</link>
      <pubDate>Sun, 16 Aug 2009 22:11:25 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/08/16/impersonators-why-do-we-need-them/</guid>
      <description>I wrote previously about an impersonator we are using on my project which Martin Fowler has dubbed the &amp;#39;self initializing fake&amp;#39; and although I thought this was the only type of situation where we might use this approach, from discussing this with my colleague Julio Maia and from experiences on the project I’m working on I realise there are other advantages to this approach as well.
To deal with unstable/slow integration points This is the main reason that we use the self initializing fake and provides perhaps the most obvious reason why we might create an impersonator because we will remain in pain if we don’t create one.</description>
    </item>
    
    <item>
      <title>Test Doubles: My current approach</title>
      <link>http://localhost:8000/blog/2009/07/14/test-doubles-my-current-approach/</link>
      <pubDate>Tue, 14 Jul 2009 13:23:52 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/07/14/test-doubles-my-current-approach/</guid>
      <description>My colleague Sarah Taraporewalla recently wrote about her thoughts on test doubles (to use Gerard Meszaros&amp;#39; language) and it got me thinking about the approach I generally take in this area.
Stub objects I use stubs mostly to control the output of depended on components of the system under test where we don’t want to verify those outputs.
Most of the time I make use of the mocking library’s ability to stub out method calls on these dependencies.</description>
    </item>
    
    <item>
      <title>TDD: Making the test green quickly</title>
      <link>http://localhost:8000/blog/2009/05/24/tdd-making-the-test-green-quickly/</link>
      <pubDate>Sun, 24 May 2009 23:43:28 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/05/24/tdd-making-the-test-green-quickly/</guid>
      <description>Although I pointed out some things that I disagreed with in Nick’s post about pair programming one thing that I really liked in that post was that he emphasised the importance of getting tests from red to green as quickly as possible.
I remember the best programming sessions I’ve had was with Stacy Curl, now an ex-thoughtworker and whom I believe was also a chess player. He would always look to quickly make my tests pass, even if it was to just echo the output that my tests would sometimes expect.</description>
    </item>
    
    <item>
      <title>Writing unit tests can be fun</title>
      <link>http://localhost:8000/blog/2009/04/25/writing-unit-tests-can-be-fun/</link>
      <pubDate>Sat, 25 Apr 2009 19:51:10 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/04/25/writing-unit-tests-can-be-fun/</guid>
      <description>I recently came across Pavel Brodzinski’s blog and while browsing through some of his most recent posts I came across one discussing when unit testing doesn’t work.
The majority of what Pavel says I’ve seen happen before on projects I’ve worked on but I disagree with his suggestion that writing unit tests is boring:
Writing unit tests is boring. That’s not amusing or challenging algorithmic problem. That’s not cool hacking trick which you can show off with in front of your geeky friends.</description>
    </item>
    
    <item>
      <title>I don&#39;t have time not to test!</title>
      <link>http://localhost:8000/blog/2009/04/18/i-dont-have-time-not-to-test/</link>
      <pubDate>Sat, 18 Apr 2009 09:25:17 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/04/18/i-dont-have-time-not-to-test/</guid>
      <description>I recently read a blog post by Joshua Lockwood where he spoke of some people who claim they don’t have time to test.
Learning the TDD approach to writing code has been one of best things that I’ve learnt over the last few years - before I worked at ThoughtWorks I didn’t know how to do it and the only way I could verify whether something worked was to load up the application and manually check it.</description>
    </item>
    
    <item>
      <title>TDD: Balancing DRYness and Readability</title>
      <link>http://localhost:8000/blog/2009/04/13/tdd-balancing-dryness-and-readability/</link>
      <pubDate>Mon, 13 Apr 2009 00:47:00 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/04/13/tdd-balancing-dryness-and-readability/</guid>
      <description>I wrote previously about creating DRY tests and after some conversations with my colleagues recently about the balance between reducing duplication but maintaining readability I think I’ve found the compromise between the two that works best for me.
The underlying idea is that in any unit test I want to be aiming for a distinct 3 sections in the test - Given/When/Then, Arrange/Act/Assert or whatever your favourite description for those is.</description>
    </item>
    
    <item>
      <title>TDD: Testing mapping code</title>
      <link>http://localhost:8000/blog/2009/04/02/tdd-testing-mapping-code/</link>
      <pubDate>Thu, 02 Apr 2009 23:11:12 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/04/02/tdd-testing-mapping-code/</guid>
      <description>I’ve previously written about some of the aspects of the mapping efforts that we’ve done on recent projects and what we’ve found from our testing (or lack of) around this type of code is that somewhere along the line you are going to have to check that you’re mapping these values correctly, be it in an automated test or just by manually checking that the correct values are being sent across our integration points and into other systems.</description>
    </item>
    
    <item>
      <title>TDD: Test DRYness</title>
      <link>http://localhost:8000/blog/2009/01/30/tdd-test-dryness/</link>
      <pubDate>Fri, 30 Jan 2009 11:16:27 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/01/30/tdd-test-dryness/</guid>
      <description>I had a discussion recently with Fabio about DRYness in our tests and how we don’t tend to adhere to this principal as often in test code as in production code.
I think certainly some of the reason for this is that we don’t take as much care of our test code as we do production code but for me at least some of it is down to the fact that if we make our tests too DRY then they become very difficult to read and perhaps more importantly, very difficult to debug when there is a failure.</description>
    </item>
    
    <item>
      <title>TDD: Design tests for failure</title>
      <link>http://localhost:8000/blog/2009/01/28/tdd-design-tests-for-failure/</link>
      <pubDate>Wed, 28 Jan 2009 00:48:16 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2009/01/28/tdd-design-tests-for-failure/</guid>
      <description>As with most code, tests are read many more times than they are written and as the majority of the time the reason for reading them is to identify a test failure I think it makes sense that we should be designing our tests with failure in mind.
Several ideas come to mind when thinking about ways to write/design our tests so that when we do have to read them our task is made easier.</description>
    </item>
    
    <item>
      <title>TDD: Does it make you slower?</title>
      <link>http://localhost:8000/blog/2008/12/25/tdd-does-it-make-you-slower/</link>
      <pubDate>Thu, 25 Dec 2008 09:41:50 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/25/tdd-does-it-make-you-slower/</guid>
      <description>There have been several times where we have been writing code in a test driven way and it has been suggested that we would be able to go much quicker if we stopped writing the tests and just wrote the code.
I feel this is a very short term way of looking at the problem and it does eventually come back to haunt you.
One of the problems seems to be that in many organisations only the first release of a piece of software is considered, and in this case then yes maybe it would be quicker to develop code in a non TDD fashion.</description>
    </item>
    
    <item>
      <title>Testing First vs Testing Last</title>
      <link>http://localhost:8000/blog/2008/12/22/testing-first-vs-testing-last/</link>
      <pubDate>Mon, 22 Dec 2008 21:39:22 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/22/testing-first-vs-testing-last/</guid>
      <description>I recently posted about my experiences of testing last where it became clear to me how important writing the test before the code is.
If we view the tests purely as a way of determining whether or not our code works correctly for a given set of examples then it doesn’t make much difference whether we test before or after we have written the code.
If on the other hand we want to get more value out of our tests such as having them the tests act as documentation, drive the design of our APIs and generally prove useful reading to ourself and others in future then a test first approach is the way to go.</description>
    </item>
    
    <item>
      <title>TDD: Mock expectations in Setup</title>
      <link>http://localhost:8000/blog/2008/12/19/tdd-mock-expectations-in-setup/</link>
      <pubDate>Fri, 19 Dec 2008 20:57:23 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/19/tdd-mock-expectations-in-setup/</guid>
      <description>One of the ideas that I mentioned in a recent post about what I consider to be a good unit test was the ideas that we shouldn’t necessarily consider the DRY (Don’t Repeat Yourself) principle to be our number one driver.
I consider putting mock expectations in the setup methods of our tests to be one of those occasions where we shouldn’t obey this principle and I thought this would be fairly unanimously agreed upon but putting the question to the Twittersphere led to mixed opinions.</description>
    </item>
    
    <item>
      <title>Testing: What is a defect?</title>
      <link>http://localhost:8000/blog/2008/12/18/testing-what-is-a-defect/</link>
      <pubDate>Thu, 18 Dec 2008 22:34:48 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/18/testing-what-is-a-defect/</guid>
      <description>One of the key ideas that I have learnt from my readings of The Toyota Way and Taaichi Ohno’s Workplace Management is that we should strive not to pass defects through the system to the next process, which you should consider to be your customer.
As a developer the next process for each story is the testing phase where the testers will (amongst other things) run through the acceptance criteria and then do some exploratory testing for scenarios which weren’t explicitly part of the acceptance criteria.</description>
    </item>
    
    <item>
      <title>TDD: One test at a time</title>
      <link>http://localhost:8000/blog/2008/12/09/tdd-one-test-at-a-time/</link>
      <pubDate>Tue, 09 Dec 2008 22:07:37 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/09/tdd-one-test-at-a-time/</guid>
      <description>My colleague Sarah Taraporewalla has written a series of posts recently about her experiences with TDD and introducing it at her current client.
While I agreed with the majority of the posts, one thing I found interesting was that in the conversation with a TDDer there were two tests being worked on at the same time (at least as far as I understand from the example).
This means that there will be two tests failing if we run our test suite, something which I try to avoid wherever possible.</description>
    </item>
    
    <item>
      <title>What makes a good unit test?</title>
      <link>http://localhost:8000/blog/2008/12/04/what-make-a-good-unit-test/</link>
      <pubDate>Thu, 04 Dec 2008 00:31:29 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/12/04/what-make-a-good-unit-test/</guid>
      <description>Following on from my post around the definition of a unit test, a recent discussion on the Test Driven Development mailing list led me to question what my own approach is for writing unit tests.
To self quote from my previous post:
A well written unit test in my book should be simple to understand and run quickly.
Quite simple in theory but as I have learnt (and am still learning) the hard way, much harder to do in practice.</description>
    </item>
    
    <item>
      <title>TDD: If it&#39;s hard to test reflect on your approach</title>
      <link>http://localhost:8000/blog/2008/11/30/tdd-if-its-hard-to-test-reflect-on-your-approach/</link>
      <pubDate>Sun, 30 Nov 2008 18:42:29 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/11/30/tdd-if-its-hard-to-test-reflect-on-your-approach/</guid>
      <description>Chad Myers gets it spot on in his recent post about not testing private methods - private methods are private because they should be inaccessible from outside the class and their functionality should be tested via one of the public methods that calls them.
I’ve found that when a piece of code seems really difficult to test without exposing a private method then we’re probably trying to test that functionality from the wrong place.</description>
    </item>
    
    <item>
      <title>TDD: Suffering from testing last</title>
      <link>http://localhost:8000/blog/2008/11/28/tdd-suffering-from-testing-last/</link>
      <pubDate>Fri, 28 Nov 2008 00:34:24 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/11/28/tdd-suffering-from-testing-last/</guid>
      <description>I’ve always been a big proponent of writing tests before writing code, and I roll off the standard reasons to people who question this approach:
They help to drive the design
They provide a safety net when making future changes
They provide a way of communicating the intent of the code to the rest of the team
And so on. Despite knowing all this I recently took a non test driven approach to writing some bits of code - we were keen to get the system working end to end so it seemed a trade off worth making to prove that it was doable.</description>
    </item>
    
    <item>
      <title>Testing Test Code</title>
      <link>http://localhost:8000/blog/2008/11/23/testing-test-code/</link>
      <pubDate>Sun, 23 Nov 2008 23:21:46 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/11/23/testing-test-code/</guid>
      <description>One of the interesting discussions that has come up on several projects I’ve worked on is whether or not we should test code that was written purely to help us test production code.
One of the main arguments used against testing test utility code is that it is not production code and therefore perhaps doesn’t need to be held to the same standards because it lacks the complexity of production code.</description>
    </item>
    
    <item>
      <title>Testing Hibernate mappings: Setting up test data</title>
      <link>http://localhost:8000/blog/2008/10/30/testing-hibernate-mappings-setting-up-test-data/</link>
      <pubDate>Thu, 30 Oct 2008 23:24:14 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/30/testing-hibernate-mappings-setting-up-test-data/</guid>
      <description>Continuing with my mini Hibernate mappings series, this post talks about the different ways of setting up the test data for our Hibernate tests.
Where to test the mappings from?
How to test for equality?
How to setup the test data?
There are a couple of ways that we can setup data for Hibernate tests.
Insert Hibernate Object This approach involves creating a new object and saving it to the database using the save method on the Hibernate session.</description>
    </item>
    
    <item>
      <title>Testing Hibernate mappings: Testing Equality</title>
      <link>http://localhost:8000/blog/2008/10/29/testing-hibernate-mappings-testing-equality/</link>
      <pubDate>Wed, 29 Oct 2008 18:03:36 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/29/testing-hibernate-mappings-testing-equality/</guid>
      <description>I started a mini Hibernate series with my last post where I spoke of there being three main areas to think about when it comes to testing:
Where to test the mappings from?
How to test for equality?
How to setup the test data?
Once we have worked out where to test the mappings from, if we have decided to test them through either our repository tests or directly from the Hibernate session then we have some choices to make around how to test for equality.</description>
    </item>
    
    <item>
      <title>Testing Hibernate mappings: Where to test from?</title>
      <link>http://localhost:8000/blog/2008/10/27/testing-hibernate-mappings-where-to-test-from/</link>
      <pubDate>Mon, 27 Oct 2008 22:55:15 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/27/testing-hibernate-mappings-where-to-test-from/</guid>
      <description>I’ve had the opportunity to work with Hibernate and it’s .NET twin NHibernate on several of my projects and one of the more interesting decisions around its use is working out the best way to test the hibernate mappings that hook together our domain model and the database.
There are three decisions to make around how best to do this:
Where to test the mappings from?
How to test for equality?</description>
    </item>
    
    <item>
      <title>Selenium - Selecting the original window</title>
      <link>http://localhost:8000/blog/2008/10/25/selenium-selecting-the-original-window/</link>
      <pubDate>Sat, 25 Oct 2008 01:55:18 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/25/selenium-selecting-the-original-window/</guid>
      <description>I’ve not used Selenium much in my time - all of my previous projects have been client side applications or service layers - but I’ve spent a bit of time getting acquainted with it this week.
While activating some acceptance tests this week I noticed quite a strange error happening if the tests ran in a certain order:
com.thoughtworks.selenium.SeleniumException: ERROR: Current window or frame is closed! at com.thoughtworks.selenium.HttpCommandProcessor.doCommand(HttpCommandProcessor.java:73) at com.</description>
    </item>
    
    <item>
      <title>Using test guided techniques for spiking</title>
      <link>http://localhost:8000/blog/2008/10/12/using-test-guided-techniques-for-spiking/</link>
      <pubDate>Sun, 12 Oct 2008 13:49:35 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/12/using-test-guided-techniques-for-spiking/</guid>
      <description>I think that out of all the Extreme Programming practices Test Driven Development is the one which I like the best. I feel it provides a structure for development work and helps me to remain focused on what I am trying to achieve rather than writing code which may not necessarily be needed.
However, there are times when it’s difficult to use a TDD approach, and Pat Kua suggested earlier this year that if you’re using a TDD approach all the time you’re doing something wrong.</description>
    </item>
    
    <item>
      <title>What is a unit test?</title>
      <link>http://localhost:8000/blog/2008/10/10/what-is-a-unit-test/</link>
      <pubDate>Fri, 10 Oct 2008 23:21:43 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/10/what-is-a-unit-test/</guid>
      <description>One of the questions which came up during the Sydney Alt.NET User Group meeting at the start of October was around what a unit test actually is.
I suppose the somewhat naive or simplistic definition is that it is just any test written using an xUnit framework such as NUnit or JUnit. However, integration or acceptance tests are often written using these frameworks so this definition doesn’t hold.
While discussing this last week a colleague came up with what I considered to be a very clear yet precise definition.</description>
    </item>
    
    <item>
      <title>It&#39;s not all about the acceptance tests</title>
      <link>http://localhost:8000/blog/2008/10/03/its-not-all-about-the-acceptance-tests/</link>
      <pubDate>Fri, 03 Oct 2008 01:26:13 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/03/its-not-all-about-the-acceptance-tests/</guid>
      <description>A few of my colleagues recently posted their opinions about acceptance tests which tied in nicely with a discussion about acceptance testing that was had at the Alt.NET conference in London.
For the sake of argument I will assume that when we refer to acceptance tests we are talking about tests at the GUI level which are being automatically driven by a tool, usually Selenium but maybe something like White if it is a client side application.</description>
    </item>
    
    <item>
      <title>TDD without the design</title>
      <link>http://localhost:8000/blog/2008/10/01/tdd-without-the-design/</link>
      <pubDate>Wed, 01 Oct 2008 00:32:20 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/10/01/tdd-without-the-design/</guid>
      <description>Roy Osherove and several others have posted recently about introducing TDD to the &amp;#39;masses&amp;#39;
As I understand it Roy’s idea is to separate the learning of TDD from the learning of good design principles - good design principles in this case being the OOP principles described in Uncle Bob’s Agile Software Development Principles, Practices and Practices or on the Object Mentor website.
I am usually in favour of an approach that breaks a skill down into chunks so that it is easier to learn but in this case I feel that some of the big gains in coding in a TDD way is the decoupled design it encourages, which in my experience is more likely to follow good design principles.</description>
    </item>
    
    <item>
      <title>Testing file system operations</title>
      <link>http://localhost:8000/blog/2008/09/17/testing-file-system-operations/</link>
      <pubDate>Wed, 17 Sep 2008 15:48:37 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/09/17/testing-file-system-operations/</guid>
      <description>On my previous project one of the areas that we needed to work out how to test was around interaction with the file system.
The decision that we needed to make was whether we should unit test this type of functionality or whether it could just be covered by a functional test.
To Unit Test One of the patterns to use when unit testing things like this is the Gateway pattern.</description>
    </item>
    
    <item>
      <title>BDD style unit test names</title>
      <link>http://localhost:8000/blog/2008/09/04/bdd-style-unit-test-names/</link>
      <pubDate>Thu, 04 Sep 2008 00:05:18 +0000</pubDate>
      
      <guid>http://localhost:8000/blog/2008/09/04/bdd-style-unit-test-names/</guid>
      <description>A couple of my colleagues have been posting about how to name your unit tests based on this original post by Jay Fields.
I think that test names are useful, especially when written in a BDD style expressing what a test is supposed to be doing.
For example, in a C# NUnit test we might see the following as a test name:
[Test] public void ShouldDoSomething() { // Code testing that we&amp;#39;re doing something } I write all my tests like this and I’m often asked what the point of the &amp;#39;Should&amp;#39; is, why not just name it &amp;#39;DoSomething&amp;#39;.</description>
    </item>
    
  </channel>
</rss>
