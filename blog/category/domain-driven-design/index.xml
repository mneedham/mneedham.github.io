<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Domain Driven Design on Mark Needham</title>
    <link>https://markhneedham.com/blog/category/domain-driven-design/</link>
    <description>Recent content in Domain Driven Design on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 23 Oct 2009 23:39:05 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/category/domain-driven-design/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Value objects: Immutability and Equality</title>
      <link>https://markhneedham.com/blog/2009/10/23/value-objects-immutability-and-equality/</link>
      <pubDate>Fri, 23 Oct 2009 23:39:05 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/10/23/value-objects-immutability-and-equality/</guid>
      <description>A couple of weeks ago I was working on some code where I wanted to create an object composed of the attributes of several other objects.
The object that I wanted to construct was a read only object so it seemed to make sense to make it a value object. The object would be immutable and once created none of the attributes of the object would change.
This was my first attempt at writing the code for this object:</description>
    </item>
    
    <item>
      <title>Domain Driven Design: Anti Corruption Layer</title>
      <link>https://markhneedham.com/blog/2009/07/07/domain-driven-design-anti-corruption-layer/</link>
      <pubDate>Tue, 07 Jul 2009 09:05:57 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/07/07/domain-driven-design-anti-corruption-layer/</guid>
      <description>I previously wrote about someoftheDomain Driven Designpatterns we have noticed on my project and I think the pattern which ties all these together is the anti corruption layer.
The reason why you might use an anti corruption layer is to create a little padding between subsystems so that they do not leak into each other too much.
Even if the model we are using is being defined by an external subsystem I think it still makes sense to have an anti corruption layer, no matter how thin, to restrict any future changes we need to make in our code as a result of external system changes to that layer.</description>
    </item>
    
    <item>
      <title>Domain Driven Design: Conformist</title>
      <link>https://markhneedham.com/blog/2009/07/04/domain-driven-design-conformist/</link>
      <pubDate>Sat, 04 Jul 2009 10:17:31 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/07/04/domain-driven-design-conformist/</guid>
      <description>Something which constantly surprises me about Domain Driven Designis how there is a pattern described in the book for just about every possible situation you find yourself in when coding on projects.
A lot of these patterns appear in the &amp;lsquo;Strategic Design&amp;rsquo; section of the book and one which is very relevant for the project I&amp;rsquo;m currently working on is the &amp;lsquo;Conformist&amp;rsquo; pattern which is described like so:
We are working on the front end of an application which interacts with some services to get and save the data from the website.</description>
    </item>
    
    <item>
      <title>DDD: Making implicit concepts explicit</title>
      <link>https://markhneedham.com/blog/2009/04/23/ddd-making-implicit-concepts-explicit/</link>
      <pubDate>Thu, 23 Apr 2009 12:36:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/04/23/ddd-making-implicit-concepts-explicit/</guid>
      <description>One of my favourite parts of the Domain Driven Designbook is where Eric Evans talks about making implicit concepts in our domain model explicit.
The book describes this process like so:
Lu and I were working on a small application to parse the WCF message log file on our project into more readable chunks whereby each request in the file would be outputted into another file so that it would be possible to read them individually.</description>
    </item>
    
    <item>
      <title>DDD: Only for complex projects?</title>
      <link>https://markhneedham.com/blog/2009/04/06/ddd-only-for-complex-projects/</link>
      <pubDate>Mon, 06 Apr 2009 19:21:55 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/04/06/ddd-only-for-complex-projects/</guid>
      <description>One of the things I find a bit confusing when it comes to Domain Driven Design is that some of the higher profile speakers/user group contributors on the subject have expressed the opinion that DDD is more suitablewhen we are dealing with complex projects.
I think this means complex in terms of the domain but I&amp;rsquo;ve certainly worked on some projects where we&amp;rsquo;ve been following certainly some of the ideas of DDD and have got some value out of doing so in domains which I wouldn&amp;rsquo;t say were particularly complex.</description>
    </item>
    
    <item>
      <title>DDD: Recognising relationships between bounded contexts</title>
      <link>https://markhneedham.com/blog/2009/03/30/ddd-recognising-relationships-between-bounded-contexts/</link>
      <pubDate>Mon, 30 Mar 2009 22:52:52 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/03/30/ddd-recognising-relationships-between-bounded-contexts/</guid>
      <description>One of the big takeaways for mefrom the Domain Driven Design trackat the recent QCon Londonconference was that the organisational patterns in the second half of the book are probably more important than the actual patterns themselves.
There are various patterns used to describe the relationships between different bounded contexts:
I think it&amp;rsquo;s useful for us to know which situation we are in because then we can make decisions on what we want to do while being aware of the various trade offs we will need to make.</description>
    </item>
    
    <item>
      <title>DDD: Repository pattern</title>
      <link>https://markhneedham.com/blog/2009/03/10/ddd-repository-not-only-for-databases/</link>
      <pubDate>Tue, 10 Mar 2009 10:31:27 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/03/10/ddd-repository-not-only-for-databases/</guid>
      <description>The Repositorypattern from Domain Driven Design is one of the cleanest ways I have come across for separating our domain objects from their persistence mechanism.
Until recently every single implementation I had seen of this pattern involved directly using a database as the persistence mechanism with the repository acting as a wrapper around the Object Relational Mapper (Hibernate/NHibernate).
Now I consider there to be two parts to the repository pattern:</description>
    </item>
    
    <item>
      <title>DDD: Bounded Contexts</title>
      <link>https://markhneedham.com/blog/2009/03/07/ddd-bounded-contexts/</link>
      <pubDate>Sat, 07 Mar 2009 10:03:38 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/03/07/ddd-bounded-contexts/</guid>
      <description>I&amp;rsquo;ve been reading Casey Charlton&amp;rsquo;s excellent series of posts on Domain Driven Designrecently and today came across his thoughts about which types of applications Domain Driven Design is suited to.
Towards the end of the post he talks about the fact that there is a lot of excellent ideas in Domain Driven Design even if you don&amp;rsquo;t have the chance to use all of them.
A pattern which I think is applicable in the majority of systems is bounded context- if I remember correctly this isn&amp;rsquo;t mentioned in InfoQ&amp;rsquo;s Domain Driven Quickly bookbut is extensively covered in the big blue book.</description>
    </item>
    
    <item>
      <title>How does the user language fit in with the ubiquitous language?</title>
      <link>https://markhneedham.com/blog/2009/01/10/how-does-the-user-language-fit-in-with-the-ubiquitous-language/</link>
      <pubDate>Sat, 10 Jan 2009 15:38:01 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2009/01/10/how-does-the-user-language-fit-in-with-the-ubiquitous-language/</guid>
      <description>We&amp;rsquo;ve been doing some work this week around trying to ensure that we have a ubiquitous languageto describe aspects of the domain across the various different systems on my project.
It&amp;rsquo;s not easy as there are several different teams involved but one thing we realised while working on the language is that the language of the business is not the same as the language of the user.
Although this is the first time that I recall working on a project where the language of the user is different to the language of the domain I&amp;rsquo;m sure there must be other domains where this is the case as well.</description>
    </item>
    
    <item>
      <title>Internal/External Domain Models</title>
      <link>https://markhneedham.com/blog/2008/12/28/internalexternal-domain-models/</link>
      <pubDate>Sun, 28 Dec 2008 00:19:13 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2008/12/28/internalexternal-domain-models/</guid>
      <description>One of the underlying characteristic of most of the projects I have worked on is that we have defined our own domain model.
On my current project due to the fact that most of the logic in the system is being handled through other services we decided to use WCFmessages as the domain model, meaning that our domain model is being defined externally by the team defining the message contracts.</description>
    </item>
    
    <item>
      <title>Similarities between Domain Driven Design &amp; Object Oriented Programming</title>
      <link>https://markhneedham.com/blog/2008/09/20/similarities-between-domain-driven-design-object-oriented-programming/</link>
      <pubDate>Sat, 20 Sep 2008 13:12:25 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2008/09/20/similarities-between-domain-driven-design-object-oriented-programming/</guid>
      <description>At the Alt.NET UK Conferencewhich I attendedover the weekend it occurred to me while listening to some of the discussions on Domain Driven Designthat a lot of the ideas in DDD are actually very similar to those being practiced in Object Oriented Programmingand related best practices.
There was quite a bit of discussion in the session about anaemic domain models.
An anaemic domain model is one where a lot of the objects are merely data holders and do not actually have any behaviour inside them.</description>
    </item>
    
    <item>
      <title>Should we always use Domain Model?</title>
      <link>https://markhneedham.com/blog/2008/09/19/should-we-always-use-domain-mode/</link>
      <pubDate>Fri, 19 Sep 2008 08:34:35 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2008/09/19/should-we-always-use-domain-mode/</guid>
      <description>During the discussionabout Domain Driven Design at the Alt.NETconference I felt like the idea of the Rich Domain Model was being represented as the only way to design software but I don&amp;rsquo;t feel that this is the case.
As always in software we never have a silver bulletand there are times when Domain Model is not necessarily the best choice, just as there are times when OOP is not necessarily the best choice.</description>
    </item>
    
  </channel>
</rss>