<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Micro Services on Mark Needham</title>
    <link>https://markhneedham.com/blog/category/micro-services/</link>
    <description>Recent content in Micro Services on Mark Needham</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 28 Feb 2013 00:00:03 +0000</lastBuildDate>
    
	<atom:link href="https://markhneedham.com/blog/category/micro-services/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Micro Services: Where does the complexity go?</title>
      <link>https://markhneedham.com/blog/2013/02/28/micro-services-where-does-the-complexity-go/</link>
      <pubDate>Thu, 28 Feb 2013 00:00:03 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/28/micro-services-where-does-the-complexity-go/</guid>
      <description>For the past year every system that I&amp;#8217;ve worked on has been designed around a micro services architecture and while there are benefits with this approach there is an inherent complexity in software which has to go somewhere!
 I thought it&amp;#8217;d be interesting to run through some of the new complexities that I&amp;#8217;ve noticed in what may well be an acknowledgement of the difficulty of designing distributed systems.
 Interactions between components One of the advantages of having lots of small applications is that each one is conceptually easier to understand and we only need to keep the mental model of how that one application works when we&amp;#8217;re working on it.</description>
    </item>
    
    <item>
      <title>Micro Services: Readme files</title>
      <link>https://markhneedham.com/blog/2013/02/25/micro-services-readme-files/</link>
      <pubDate>Mon, 25 Feb 2013 23:58:51 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2013/02/25/micro-services-readme-files/</guid>
      <description>By my latest count I have around 15 different micro services/applications checked out on my machine which comprise the system that I&amp;#8217;m currently working on.
 Most of these are Ruby related so it&amp;#8217;s easy to figure out how to start up a local copy because it&amp;#8217;s either bundle exec rails server if it&amp;#8217;s a rails application or bundle exec backup if it&amp;#8217;s a sinatra/rack application.
 The clojure applications follow a similar convention and we use rake to run any offline tasks.</description>
    </item>
    
    <item>
      <title>Micro Services: Plugging in 3rd party components</title>
      <link>https://markhneedham.com/blog/2012/12/04/micro-services-plugging-in-3rd-party-components/</link>
      <pubDate>Tue, 04 Dec 2012 23:38:39 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/12/04/micro-services-plugging-in-3rd-party-components/</guid>
      <description>Over the past few weeks I&amp;#8217;ve been involved in conversations with different clients around micro services and one thing about this architecture that seems quite popular is the ability to easily plug in 3rd party components.
 In one case we were talking through the design of a system which would calculate and then apply price optimisations on products. The parts of the system we were discussing looked roughly like this:</description>
    </item>
    
    <item>
      <title>Micro Services: The curse of code &#39;duplication&#39;</title>
      <link>https://markhneedham.com/blog/2012/11/28/micro-services-the-curse-of-code-duplication/</link>
      <pubDate>Wed, 28 Nov 2012 08:11:04 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/11/28/micro-services-the-curse-of-code-duplication/</guid>
      <description>A common approach we&amp;#8217;ve been taking on some of the applications I&amp;#8217;ve worked on recently is to decompose the system we&amp;#8217;re building into smaller micro services which are independently deployable and communicate with each other over HTTP.
 An advantage of decomposing systems like that is that we could have separate teams working on each service and then make use of a consumer driven contract as a way of ensuring the contract between them is correct.</description>
    </item>
    
    <item>
      <title>Micro Services: A simple example</title>
      <link>https://markhneedham.com/blog/2012/03/31/micro-services-a-simple-example/</link>
      <pubDate>Sat, 31 Mar 2012 09:06:14 +0000</pubDate>
      
      <guid>https://markhneedham.com/blog/2012/03/31/micro-services-a-simple-example/</guid>
      <description>In our code base we had the concept of a &#39;ProductSpeed&#39; with two different constructors which initialised the object in different ways:
 public class ProductSpeed { public ProductSpeed(String name) { ... } public ProductSpeed(String name, int order)) { } }   In the cases where the first constructor was used the order of the product was irrelevant.
 When the second constructor was used we did care about it because we wanted to be able sort the products before showing them in a drop down list to the user.</description>
    </item>
    
  </channel>
</rss>