+++
draft = false
date="2016-05-22 09:58:38"
title="Neo4j vs Relational: Refactoring - Extracting node/table"
tag=['neo4j']
category=['neo4j']
+++

<p>In my <a href="http://www.markhneedham.com/blog/2016/05/22/neo4j-vs-relational-refactoring-add-a-new-fieldproperty/">previous blog post</a> I showed how to add a new property/field to a node with a label/record in a table for a football transfers dataset that I've been playing with. 
</p>


<p>After introducing this 'nationality' property I realised that I now had some duplication in the model:</p>


</p>


<div>
<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/05/2016-05-22_10-15-15.png" alt="2016 05 22 10 15 15" title="2016-05-22_10-15-15.png" border="0" width="401" height="191" />
</div>

<p>
<cite>players.nationality</cite> and <cite>clubs.country</cite> are referring to the same countries but they've both got them stored as strings so we can't ensure the integrity of our countries and ensure that we're referring to the same country.
</p>


<p>We have the same issue in the graph model as well:</p>


<div>

<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/05/2016-05-22_10-40-40.png" alt="2016 05 22 10 40 40" title="2016-05-22_10-40-40.png" border="0" width="401" /></div>

<p>This time <cite>Player.nationality</cite> and <cite>Club.country</cite> refer to the same countries.</p>
 

<p>We can solve our problem by introducing a countries table in the relational model and a set of nodes with a 'Country' label in the graph model. Let's start with relational.
</p>


<p>This is the model we're driving towards:</p>


<div>

<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/05/2016-05-22_10-50-43.png" alt="2016 05 22 10 50 43" title="2016-05-22_10-50-43.png" border="0" width="395" height="196" />
</div>

<p>The first thing we need to do is create a countries table and populate it:</p>



~~~sql

CREATE TABLE countries (
    "code" character varying(3) NOT NULL PRIMARY KEY,
    "name" character varying(50) NOT NULL
);
~~~


~~~sql

INSERT INTO countries VALUES('MNE', 'Montenegro');
INSERT INTO countries VALUES('SWZ', 'Swaziland');
...
~~~

<p>
Next let's update the clubs table to reference the countries table:
</p>



~~~sql

ALTER TABLE clubs
ADD COLUMN country_id character varying(3)
REFERENCES countries(code);
~~~

<p>And let's run a query to populate that column:</p>



~~~sql

UPDATE clubs AS cl
SET country_id = c.code
FROM clubs
INNER JOIN countries AS c 
ON c.name = clubs.country
WHERE cl.id = clubs.id;
~~~

<p>This query iterates over all the clubs, queries the country table to find the country id for that row and then stores it in the 'country_id' field. Finally we can remove the 'country' field: </p>



~~~sql

ALTER TABLE clubs
DROP COLUMN country;
~~~

<p>Now we do the same drill for the players table:</p>



~~~sql

ALTER TABLE players
ADD COLUMN country_id character varying(3)
REFERENCES countries(code);
~~~


~~~sql

UPDATE players AS p
SET country_id = c.code
FROM players
INNER JOIN countries AS c 
ON c.name = players.nationality
WHERE p.id = players.id;
~~~


~~~sql

ALTER TABLE players
DROP COLUMN nationality;
~~~

<p>Now it's time for the graph. This is the model we want to get to:</p>


<div>
<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/05/2016-05-22_10-51-49.png" alt="2016 05 22 10 51 49" title="2016-05-22_10-51-49.png" border="0" width="334" height="218" />
</div>

<p>
First we'll create the countries:
</p>



~~~cypher

CREATE CONSTRAINT ON (c:Country)
ASSERT c.id IS UNIQUE
~~~


~~~cypher

LOAD CSV WITH HEADERS FROM "file:///countries.csv"
AS row
MERGE (country:Country {id: row.countryCode})
ON CREATE SET country.name = row.country
~~~

<p>And now let's get clubs and players to point at those countries nodes and get rid of their respective nationality/country properties:
</p>



~~~cypher

MATCH (club:Club)
MATCH (country:Country {name: club.country})
MERGE (club)-[:PART_OF]->(country)
REMOVE club.country
~~~


~~~cypher

MATCH (player:Player)
MATCH (country:Country {name: player.nationality})
MERGE (player)-[:PLAYS_FOR]->(country)
REMOVE player.nationality
~~~

<p>And that's it, we can now write queries against our new model.</p>

