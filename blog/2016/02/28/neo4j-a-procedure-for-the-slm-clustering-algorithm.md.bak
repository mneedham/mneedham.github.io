+++
draft = false
date="2016-02-28 20:40:11"
title="Neo4j: A procedure for the SLM clustering algorithm"
tag=['neo4j']
category=['neo4j']
+++

<p>
In the middle of last year <a href="http://www.markhneedham.com/blog/2015/06/17/coding-explore-and-retreat/">I blogged about the Smart Local Moving algorithm </a>which is used for community detection in networks and with the <a href="http://jexp.de/blog/2016/02/neo4j-3-0-stored-procedures/">upcoming introduction of procedures</a> in Neo4j I thought it'd be fun to make that code accessible as one.
</p>


<p>
If you want to grab the code and follow along it's sitting on the <a href="https://github.com/mneedham/slm">SLM repository on my github</a>.
</p>


<P>At the moment the procedure is hard coded to work with a <cite>KNOWS</cite> relationship between two nodes but that could easily be changed.</p>


<p>
To check it's working correctly I thought it'd make most sense to use the Karate Club data set described on the <a href="http://www.ludowaltman.nl/slm/">SLM home page</a>. I think this data set is originally from <a href="https://www.cs.cornell.edu/home/kleinber/networks-book/networks-book.pdf">Networks, Crowds and Markets</a>.
</p>


<p>I wrote the following LOAD CSV script to create the graph in Neo4j:</p>



~~~cypher

LOAD CSV FROM "file:///Users/markneedham/projects/slm/karate_club_network.txt" as row
FIELDTERMINATOR "\t"
MERGE (person1:Person {id: row[0]})
MERGE (person2:Person {id: row[1]})
MERGE (person1)-[:KNOWS]->(person2)
~~~
<div>
<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/02/graph.png" alt="Graph" title="graph.png" border="0" width="566" height="181" />
</div>

<p>
Next we need to call the procedure which will add an appropriate label to each node depending which community it belongs to. This is what the procedure code looks like:
</p>




~~~java

public class ClusterAllTheThings
{
    @Context
    public org.neo4j.graphdb.GraphDatabaseService db;

    @Procedure
    @PerformsWrites
    public Stream<Cluster> knows() throws IOException
    {
        String query = "MATCH (person1:Person)-[r:KNOWS]->(person2:Person) \n" +
                       "RETURN person1.id AS p1, person2.id AS p2, toFloat(1) AS weight";

        Result rows = db.execute( query );

        ModularityOptimizer.ModularityFunction modularityFunction = ModularityOptimizer.ModularityFunction.Standard;
        Network network = Network.create( modularityFunction, rows );

        double resolution = 1.0;
        int nRandomStarts = 1;
        int nIterations = 10;
        long randomSeed = 0;

        double modularity;

        Random random = new Random( randomSeed );

        double resolution2 = modularityFunction.resolution( resolution, network );

        Map<Integer, Node> cluster = new HashMap<>();
        double maxModularity = Double.NEGATIVE_INFINITY;

        for ( int randomStart = 0; randomStart < nRandomStarts; randomStart++ )
        {
            network.initSingletonClusters();

            int iteration = 0;
            do
            {
                network.runSmartLocalMovingAlgorithm( resolution2, random );
                iteration++;

                modularity = network.calcQualityFunction( resolution2 );
            } while ( (iteration < nIterations) );

            if ( modularity > maxModularity )
            {
                network.orderClustersByNNodes();
                cluster = network.getNodes();
                maxModularity = modularity;
            }
        }

        for ( Map.Entry<Integer, Node> entry : cluster.entrySet() )
        {
            Map<String, Object> params = new HashMap<>();
            params.put("userId", String.valueOf(entry.getKey()));

            db.execute("MATCH (person:Person {id: {userId}})\n" +
                       "SET person:`" + (format( "Community-%d`", entry.getValue().getCluster() )),
                    params);
        }

        return cluster
                .entrySet()
                .stream()
                .map( ( entry ) -> new Cluster( entry.getKey(), entry.getValue().getCluster() ) );
    }

    public static class Cluster
    {
        public long id;
        public long clusterId;

        public Cluster( int id, int clusterId )
        {
            this.id = id;
            this.clusterId = clusterId;
        }
    }
}
~~~

<p>I've hardcoded some parameters to use defaults which could be exposed through the procedure to allow more control if necessary. The <cite><a href="https://github.com/mneedham/slm/blob/master/src/main/java/org/neo4j/slm/Network.java#L69">Network#create</a></cite> function assumes it is going to receive a stream of rows containing columns 'p1', 'p2' and 'weight' to represent the 'source', 'destination' and 'weight' of the relationship between them.</p>


<p>We call the procedure like this:</p>



~~~cypher

CALL org.neo4j.slm.knows()
~~~

<p>It will return each of the nodes and the cluster it's been assigned to and if we then visualise the network in the neo4j browser we'll see this:</p>


<div>
<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/02/graph-1.png" alt="Graph  1" title="graph (1).png" border="0" width="591" height="314" />
</div>

<p>which is similar to the visualisation from the SLM home page:</p>


<div>

<img src="http://www.markhneedham.com/blog/wp-content/uploads/2016/02/network.png" alt="Network" title="network.png" border="0"  /></div>

<p>
If you want to play around with the code feel free. You'll need to run the following commands to create the JAR for the plugin and deploy it.
</p>



~~~bash

$ mvn clean package 
$ cp target/slm-1.0.jar /path/to/neo4j/plugins/ 
$ ./path/to/neo4j/bin/neo4j restart
~~~

<p>
And you'll need <a href="http://neo4j.com/download/other-releases/">the latest milestone of Neo4j</a> which has procedures enabled.
</p>

